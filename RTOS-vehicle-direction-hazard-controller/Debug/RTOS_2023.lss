
RTOS_2023.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000065c4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002c  00800060  000065c4  00006658  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006a8  0080008c  0080008c  00006684  2**0
                  ALLOC
  3 .stab         00009468  00000000  00000000  00006684  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000557d  00000000  00000000  0000faec  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 ec       	ldi	r30, 0xC4	; 196
      68:	f5 e6       	ldi	r31, 0x65	; 101
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 38       	cpi	r26, 0x8C	; 140
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac e8       	ldi	r26, 0x8C	; 140
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 33       	cpi	r26, 0x34	; 52
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 81 31 	call	0x6302	; 0x6302 <main>
      8a:	0c 94 e0 32 	jmp	0x65c0	; 0x65c0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <pvPortMalloc+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <pvPortMalloc+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
      a2:	1a 82       	std	Y+2, r1	; 0x02
      a4:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
      a6:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
      aa:	80 91 8e 00 	lds	r24, 0x008E
      ae:	90 91 8f 00 	lds	r25, 0x008F
      b2:	00 97       	sbiw	r24, 0x00	; 0
      b4:	31 f4       	brne	.+12     	; 0xc2 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
      b6:	80 e9       	ldi	r24, 0x90	; 144
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	90 93 8f 00 	sts	0x008F, r25
      be:	80 93 8e 00 	sts	0x008E, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
      c2:	8b 81       	ldd	r24, Y+3	; 0x03
      c4:	9c 81       	ldd	r25, Y+4	; 0x04
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	99 f1       	breq	.+102    	; 0x130 <pvPortMalloc+0x9e>
      ca:	80 91 8c 00 	lds	r24, 0x008C
      ce:	90 91 8d 00 	lds	r25, 0x008D
      d2:	2b 81       	ldd	r18, Y+3	; 0x03
      d4:	3c 81       	ldd	r19, Y+4	; 0x04
      d6:	82 0f       	add	r24, r18
      d8:	93 1f       	adc	r25, r19
      da:	25 e0       	ldi	r18, 0x05	; 5
      dc:	8b 3d       	cpi	r24, 0xDB	; 219
      de:	92 07       	cpc	r25, r18
      e0:	38 f5       	brcc	.+78     	; 0x130 <pvPortMalloc+0x9e>
      e2:	20 91 8c 00 	lds	r18, 0x008C
      e6:	30 91 8d 00 	lds	r19, 0x008D
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	9c 81       	ldd	r25, Y+4	; 0x04
      ee:	28 0f       	add	r18, r24
      f0:	39 1f       	adc	r19, r25
      f2:	80 91 8c 00 	lds	r24, 0x008C
      f6:	90 91 8d 00 	lds	r25, 0x008D
      fa:	82 17       	cp	r24, r18
      fc:	93 07       	cpc	r25, r19
      fe:	c0 f4       	brcc	.+48     	; 0x130 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     100:	20 91 8e 00 	lds	r18, 0x008E
     104:	30 91 8f 00 	lds	r19, 0x008F
     108:	80 91 8c 00 	lds	r24, 0x008C
     10c:	90 91 8d 00 	lds	r25, 0x008D
     110:	82 0f       	add	r24, r18
     112:	93 1f       	adc	r25, r19
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     118:	20 91 8c 00 	lds	r18, 0x008C
     11c:	30 91 8d 00 	lds	r19, 0x008D
     120:	8b 81       	ldd	r24, Y+3	; 0x03
     122:	9c 81       	ldd	r25, Y+4	; 0x04
     124:	82 0f       	add	r24, r18
     126:	93 1f       	adc	r25, r19
     128:	90 93 8d 00 	sts	0x008D, r25
     12c:	80 93 8c 00 	sts	0x008C, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     130:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     134:	89 81       	ldd	r24, Y+1	; 0x01
     136:	9a 81       	ldd	r25, Y+2	; 0x02
}
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	0f 90       	pop	r0
     140:	cf 91       	pop	r28
     142:	df 91       	pop	r29
     144:	08 95       	ret

00000146 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     146:	df 93       	push	r29
     148:	cf 93       	push	r28
     14a:	00 d0       	rcall	.+0      	; 0x14c <vPortFree+0x6>
     14c:	cd b7       	in	r28, 0x3d	; 61
     14e:	de b7       	in	r29, 0x3e	; 62
     150:	9a 83       	std	Y+2, r25	; 0x02
     152:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     154:	0f 90       	pop	r0
     156:	0f 90       	pop	r0
     158:	cf 91       	pop	r28
     15a:	df 91       	pop	r29
     15c:	08 95       	ret

0000015e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     15e:	df 93       	push	r29
     160:	cf 93       	push	r28
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     166:	10 92 8d 00 	sts	0x008D, r1
     16a:	10 92 8c 00 	sts	0x008C, r1
}
     16e:	cf 91       	pop	r28
     170:	df 91       	pop	r29
     172:	08 95       	ret

00000174 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     174:	df 93       	push	r29
     176:	cf 93       	push	r28
     178:	cd b7       	in	r28, 0x3d	; 61
     17a:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     17c:	20 91 8c 00 	lds	r18, 0x008C
     180:	30 91 8d 00 	lds	r19, 0x008D
     184:	8b ed       	ldi	r24, 0xDB	; 219
     186:	95 e0       	ldi	r25, 0x05	; 5
     188:	82 1b       	sub	r24, r18
     18a:	93 0b       	sbc	r25, r19
}
     18c:	cf 91       	pop	r28
     18e:	df 91       	pop	r29
     190:	08 95       	ret

00000192 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     192:	df 93       	push	r29
     194:	cf 93       	push	r28
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	28 97       	sbiw	r28, 0x08	; 8
     19c:	0f b6       	in	r0, 0x3f	; 63
     19e:	f8 94       	cli
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	0f be       	out	0x3f, r0	; 63
     1a4:	cd bf       	out	0x3d, r28	; 61
     1a6:	9c 83       	std	Y+4, r25	; 0x04
     1a8:	8b 83       	std	Y+3, r24	; 0x03
     1aa:	7e 83       	std	Y+6, r23	; 0x06
     1ac:	6d 83       	std	Y+5, r22	; 0x05
     1ae:	58 87       	std	Y+8, r21	; 0x08
     1b0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1b2:	eb 81       	ldd	r30, Y+3	; 0x03
     1b4:	fc 81       	ldd	r31, Y+4	; 0x04
     1b6:	81 e1       	ldi	r24, 0x11	; 17
     1b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     1ba:	8b 81       	ldd	r24, Y+3	; 0x03
     1bc:	9c 81       	ldd	r25, Y+4	; 0x04
     1be:	01 97       	sbiw	r24, 0x01	; 1
     1c0:	9c 83       	std	Y+4, r25	; 0x04
     1c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     1c4:	eb 81       	ldd	r30, Y+3	; 0x03
     1c6:	fc 81       	ldd	r31, Y+4	; 0x04
     1c8:	82 e2       	ldi	r24, 0x22	; 34
     1ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	01 97       	sbiw	r24, 0x01	; 1
     1d2:	9c 83       	std	Y+4, r25	; 0x04
     1d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     1d6:	eb 81       	ldd	r30, Y+3	; 0x03
     1d8:	fc 81       	ldd	r31, Y+4	; 0x04
     1da:	83 e3       	ldi	r24, 0x33	; 51
     1dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     1de:	8b 81       	ldd	r24, Y+3	; 0x03
     1e0:	9c 81       	ldd	r25, Y+4	; 0x04
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	9c 83       	std	Y+4, r25	; 0x04
     1e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     1e8:	8d 81       	ldd	r24, Y+5	; 0x05
     1ea:	9e 81       	ldd	r25, Y+6	; 0x06
     1ec:	9a 83       	std	Y+2, r25	; 0x02
     1ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1f0:	89 81       	ldd	r24, Y+1	; 0x01
     1f2:	eb 81       	ldd	r30, Y+3	; 0x03
     1f4:	fc 81       	ldd	r31, Y+4	; 0x04
     1f6:	80 83       	st	Z, r24
	pxTopOfStack--;
     1f8:	8b 81       	ldd	r24, Y+3	; 0x03
     1fa:	9c 81       	ldd	r25, Y+4	; 0x04
     1fc:	01 97       	sbiw	r24, 0x01	; 1
     1fe:	9c 83       	std	Y+4, r25	; 0x04
     200:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     202:	89 81       	ldd	r24, Y+1	; 0x01
     204:	9a 81       	ldd	r25, Y+2	; 0x02
     206:	89 2f       	mov	r24, r25
     208:	99 27       	eor	r25, r25
     20a:	9a 83       	std	Y+2, r25	; 0x02
     20c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	eb 81       	ldd	r30, Y+3	; 0x03
     212:	fc 81       	ldd	r31, Y+4	; 0x04
     214:	80 83       	st	Z, r24
	pxTopOfStack--;
     216:	8b 81       	ldd	r24, Y+3	; 0x03
     218:	9c 81       	ldd	r25, Y+4	; 0x04
     21a:	01 97       	sbiw	r24, 0x01	; 1
     21c:	9c 83       	std	Y+4, r25	; 0x04
     21e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     220:	eb 81       	ldd	r30, Y+3	; 0x03
     222:	fc 81       	ldd	r31, Y+4	; 0x04
     224:	10 82       	st	Z, r1
	pxTopOfStack--;
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	9c 81       	ldd	r25, Y+4	; 0x04
     22a:	01 97       	sbiw	r24, 0x01	; 1
     22c:	9c 83       	std	Y+4, r25	; 0x04
     22e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     230:	eb 81       	ldd	r30, Y+3	; 0x03
     232:	fc 81       	ldd	r31, Y+4	; 0x04
     234:	80 e8       	ldi	r24, 0x80	; 128
     236:	80 83       	st	Z, r24
	pxTopOfStack--;
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	9c 83       	std	Y+4, r25	; 0x04
     240:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     242:	eb 81       	ldd	r30, Y+3	; 0x03
     244:	fc 81       	ldd	r31, Y+4	; 0x04
     246:	10 82       	st	Z, r1
	pxTopOfStack--;
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	01 97       	sbiw	r24, 0x01	; 1
     24e:	9c 83       	std	Y+4, r25	; 0x04
     250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     252:	eb 81       	ldd	r30, Y+3	; 0x03
     254:	fc 81       	ldd	r31, Y+4	; 0x04
     256:	82 e0       	ldi	r24, 0x02	; 2
     258:	80 83       	st	Z, r24
	pxTopOfStack--;
     25a:	8b 81       	ldd	r24, Y+3	; 0x03
     25c:	9c 81       	ldd	r25, Y+4	; 0x04
     25e:	01 97       	sbiw	r24, 0x01	; 1
     260:	9c 83       	std	Y+4, r25	; 0x04
     262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     264:	eb 81       	ldd	r30, Y+3	; 0x03
     266:	fc 81       	ldd	r31, Y+4	; 0x04
     268:	83 e0       	ldi	r24, 0x03	; 3
     26a:	80 83       	st	Z, r24
	pxTopOfStack--;
     26c:	8b 81       	ldd	r24, Y+3	; 0x03
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	9c 83       	std	Y+4, r25	; 0x04
     274:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     276:	eb 81       	ldd	r30, Y+3	; 0x03
     278:	fc 81       	ldd	r31, Y+4	; 0x04
     27a:	84 e0       	ldi	r24, 0x04	; 4
     27c:	80 83       	st	Z, r24
	pxTopOfStack--;
     27e:	8b 81       	ldd	r24, Y+3	; 0x03
     280:	9c 81       	ldd	r25, Y+4	; 0x04
     282:	01 97       	sbiw	r24, 0x01	; 1
     284:	9c 83       	std	Y+4, r25	; 0x04
     286:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     288:	eb 81       	ldd	r30, Y+3	; 0x03
     28a:	fc 81       	ldd	r31, Y+4	; 0x04
     28c:	85 e0       	ldi	r24, 0x05	; 5
     28e:	80 83       	st	Z, r24
	pxTopOfStack--;
     290:	8b 81       	ldd	r24, Y+3	; 0x03
     292:	9c 81       	ldd	r25, Y+4	; 0x04
     294:	01 97       	sbiw	r24, 0x01	; 1
     296:	9c 83       	std	Y+4, r25	; 0x04
     298:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     29a:	eb 81       	ldd	r30, Y+3	; 0x03
     29c:	fc 81       	ldd	r31, Y+4	; 0x04
     29e:	86 e0       	ldi	r24, 0x06	; 6
     2a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	9c 83       	std	Y+4, r25	; 0x04
     2aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2ac:	eb 81       	ldd	r30, Y+3	; 0x03
     2ae:	fc 81       	ldd	r31, Y+4	; 0x04
     2b0:	87 e0       	ldi	r24, 0x07	; 7
     2b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     2b4:	8b 81       	ldd	r24, Y+3	; 0x03
     2b6:	9c 81       	ldd	r25, Y+4	; 0x04
     2b8:	01 97       	sbiw	r24, 0x01	; 1
     2ba:	9c 83       	std	Y+4, r25	; 0x04
     2bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2be:	eb 81       	ldd	r30, Y+3	; 0x03
     2c0:	fc 81       	ldd	r31, Y+4	; 0x04
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	80 83       	st	Z, r24
	pxTopOfStack--;
     2c6:	8b 81       	ldd	r24, Y+3	; 0x03
     2c8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ca:	01 97       	sbiw	r24, 0x01	; 1
     2cc:	9c 83       	std	Y+4, r25	; 0x04
     2ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2d0:	eb 81       	ldd	r30, Y+3	; 0x03
     2d2:	fc 81       	ldd	r31, Y+4	; 0x04
     2d4:	89 e0       	ldi	r24, 0x09	; 9
     2d6:	80 83       	st	Z, r24
	pxTopOfStack--;
     2d8:	8b 81       	ldd	r24, Y+3	; 0x03
     2da:	9c 81       	ldd	r25, Y+4	; 0x04
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	9c 83       	std	Y+4, r25	; 0x04
     2e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2e2:	eb 81       	ldd	r30, Y+3	; 0x03
     2e4:	fc 81       	ldd	r31, Y+4	; 0x04
     2e6:	80 e1       	ldi	r24, 0x10	; 16
     2e8:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ea:	8b 81       	ldd	r24, Y+3	; 0x03
     2ec:	9c 81       	ldd	r25, Y+4	; 0x04
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	9c 83       	std	Y+4, r25	; 0x04
     2f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2f4:	eb 81       	ldd	r30, Y+3	; 0x03
     2f6:	fc 81       	ldd	r31, Y+4	; 0x04
     2f8:	81 e1       	ldi	r24, 0x11	; 17
     2fa:	80 83       	st	Z, r24
	pxTopOfStack--;
     2fc:	8b 81       	ldd	r24, Y+3	; 0x03
     2fe:	9c 81       	ldd	r25, Y+4	; 0x04
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	9c 83       	std	Y+4, r25	; 0x04
     304:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	82 e1       	ldi	r24, 0x12	; 18
     30c:	80 83       	st	Z, r24
	pxTopOfStack--;
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	9c 81       	ldd	r25, Y+4	; 0x04
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9c 83       	std	Y+4, r25	; 0x04
     316:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     318:	eb 81       	ldd	r30, Y+3	; 0x03
     31a:	fc 81       	ldd	r31, Y+4	; 0x04
     31c:	83 e1       	ldi	r24, 0x13	; 19
     31e:	80 83       	st	Z, r24
	pxTopOfStack--;
     320:	8b 81       	ldd	r24, Y+3	; 0x03
     322:	9c 81       	ldd	r25, Y+4	; 0x04
     324:	01 97       	sbiw	r24, 0x01	; 1
     326:	9c 83       	std	Y+4, r25	; 0x04
     328:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     32a:	eb 81       	ldd	r30, Y+3	; 0x03
     32c:	fc 81       	ldd	r31, Y+4	; 0x04
     32e:	84 e1       	ldi	r24, 0x14	; 20
     330:	80 83       	st	Z, r24
	pxTopOfStack--;
     332:	8b 81       	ldd	r24, Y+3	; 0x03
     334:	9c 81       	ldd	r25, Y+4	; 0x04
     336:	01 97       	sbiw	r24, 0x01	; 1
     338:	9c 83       	std	Y+4, r25	; 0x04
     33a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     33c:	eb 81       	ldd	r30, Y+3	; 0x03
     33e:	fc 81       	ldd	r31, Y+4	; 0x04
     340:	85 e1       	ldi	r24, 0x15	; 21
     342:	80 83       	st	Z, r24
	pxTopOfStack--;
     344:	8b 81       	ldd	r24, Y+3	; 0x03
     346:	9c 81       	ldd	r25, Y+4	; 0x04
     348:	01 97       	sbiw	r24, 0x01	; 1
     34a:	9c 83       	std	Y+4, r25	; 0x04
     34c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34e:	eb 81       	ldd	r30, Y+3	; 0x03
     350:	fc 81       	ldd	r31, Y+4	; 0x04
     352:	86 e1       	ldi	r24, 0x16	; 22
     354:	80 83       	st	Z, r24
	pxTopOfStack--;
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	9c 81       	ldd	r25, Y+4	; 0x04
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	9c 83       	std	Y+4, r25	; 0x04
     35e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     360:	eb 81       	ldd	r30, Y+3	; 0x03
     362:	fc 81       	ldd	r31, Y+4	; 0x04
     364:	87 e1       	ldi	r24, 0x17	; 23
     366:	80 83       	st	Z, r24
	pxTopOfStack--;
     368:	8b 81       	ldd	r24, Y+3	; 0x03
     36a:	9c 81       	ldd	r25, Y+4	; 0x04
     36c:	01 97       	sbiw	r24, 0x01	; 1
     36e:	9c 83       	std	Y+4, r25	; 0x04
     370:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     372:	eb 81       	ldd	r30, Y+3	; 0x03
     374:	fc 81       	ldd	r31, Y+4	; 0x04
     376:	88 e1       	ldi	r24, 0x18	; 24
     378:	80 83       	st	Z, r24
	pxTopOfStack--;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	9c 81       	ldd	r25, Y+4	; 0x04
     37e:	01 97       	sbiw	r24, 0x01	; 1
     380:	9c 83       	std	Y+4, r25	; 0x04
     382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     384:	eb 81       	ldd	r30, Y+3	; 0x03
     386:	fc 81       	ldd	r31, Y+4	; 0x04
     388:	89 e1       	ldi	r24, 0x19	; 25
     38a:	80 83       	st	Z, r24
	pxTopOfStack--;
     38c:	8b 81       	ldd	r24, Y+3	; 0x03
     38e:	9c 81       	ldd	r25, Y+4	; 0x04
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	9c 83       	std	Y+4, r25	; 0x04
     394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     396:	eb 81       	ldd	r30, Y+3	; 0x03
     398:	fc 81       	ldd	r31, Y+4	; 0x04
     39a:	80 e2       	ldi	r24, 0x20	; 32
     39c:	80 83       	st	Z, r24
	pxTopOfStack--;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	81 e2       	ldi	r24, 0x21	; 33
     3ae:	80 83       	st	Z, r24
	pxTopOfStack--;
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	01 97       	sbiw	r24, 0x01	; 1
     3b6:	9c 83       	std	Y+4, r25	; 0x04
     3b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3ba:	eb 81       	ldd	r30, Y+3	; 0x03
     3bc:	fc 81       	ldd	r31, Y+4	; 0x04
     3be:	82 e2       	ldi	r24, 0x22	; 34
     3c0:	80 83       	st	Z, r24
	pxTopOfStack--;
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	01 97       	sbiw	r24, 0x01	; 1
     3c8:	9c 83       	std	Y+4, r25	; 0x04
     3ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	83 e2       	ldi	r24, 0x23	; 35
     3d2:	80 83       	st	Z, r24
	pxTopOfStack--;
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	9c 81       	ldd	r25, Y+4	; 0x04
     3d8:	01 97       	sbiw	r24, 0x01	; 1
     3da:	9c 83       	std	Y+4, r25	; 0x04
     3dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     3de:	8f 81       	ldd	r24, Y+7	; 0x07
     3e0:	98 85       	ldd	r25, Y+8	; 0x08
     3e2:	9a 83       	std	Y+2, r25	; 0x02
     3e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	eb 81       	ldd	r30, Y+3	; 0x03
     3ea:	fc 81       	ldd	r31, Y+4	; 0x04
     3ec:	80 83       	st	Z, r24
	pxTopOfStack--;
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	9c 81       	ldd	r25, Y+4	; 0x04
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	9c 83       	std	Y+4, r25	; 0x04
     3f6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     3f8:	89 81       	ldd	r24, Y+1	; 0x01
     3fa:	9a 81       	ldd	r25, Y+2	; 0x02
     3fc:	89 2f       	mov	r24, r25
     3fe:	99 27       	eor	r25, r25
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     404:	89 81       	ldd	r24, Y+1	; 0x01
     406:	eb 81       	ldd	r30, Y+3	; 0x03
     408:	fc 81       	ldd	r31, Y+4	; 0x04
     40a:	80 83       	st	Z, r24
	pxTopOfStack--;
     40c:	8b 81       	ldd	r24, Y+3	; 0x03
     40e:	9c 81       	ldd	r25, Y+4	; 0x04
     410:	01 97       	sbiw	r24, 0x01	; 1
     412:	9c 83       	std	Y+4, r25	; 0x04
     414:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     416:	eb 81       	ldd	r30, Y+3	; 0x03
     418:	fc 81       	ldd	r31, Y+4	; 0x04
     41a:	86 e2       	ldi	r24, 0x26	; 38
     41c:	80 83       	st	Z, r24
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     428:	eb 81       	ldd	r30, Y+3	; 0x03
     42a:	fc 81       	ldd	r31, Y+4	; 0x04
     42c:	87 e2       	ldi	r24, 0x27	; 39
     42e:	80 83       	st	Z, r24
	pxTopOfStack--;
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	9c 81       	ldd	r25, Y+4	; 0x04
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	9c 83       	std	Y+4, r25	; 0x04
     438:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     43a:	eb 81       	ldd	r30, Y+3	; 0x03
     43c:	fc 81       	ldd	r31, Y+4	; 0x04
     43e:	88 e2       	ldi	r24, 0x28	; 40
     440:	80 83       	st	Z, r24
	pxTopOfStack--;
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	9c 81       	ldd	r25, Y+4	; 0x04
     446:	01 97       	sbiw	r24, 0x01	; 1
     448:	9c 83       	std	Y+4, r25	; 0x04
     44a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     44c:	eb 81       	ldd	r30, Y+3	; 0x03
     44e:	fc 81       	ldd	r31, Y+4	; 0x04
     450:	89 e2       	ldi	r24, 0x29	; 41
     452:	80 83       	st	Z, r24
	pxTopOfStack--;
     454:	8b 81       	ldd	r24, Y+3	; 0x03
     456:	9c 81       	ldd	r25, Y+4	; 0x04
     458:	01 97       	sbiw	r24, 0x01	; 1
     45a:	9c 83       	std	Y+4, r25	; 0x04
     45c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     45e:	eb 81       	ldd	r30, Y+3	; 0x03
     460:	fc 81       	ldd	r31, Y+4	; 0x04
     462:	80 e3       	ldi	r24, 0x30	; 48
     464:	80 83       	st	Z, r24
	pxTopOfStack--;
     466:	8b 81       	ldd	r24, Y+3	; 0x03
     468:	9c 81       	ldd	r25, Y+4	; 0x04
     46a:	01 97       	sbiw	r24, 0x01	; 1
     46c:	9c 83       	std	Y+4, r25	; 0x04
     46e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     470:	eb 81       	ldd	r30, Y+3	; 0x03
     472:	fc 81       	ldd	r31, Y+4	; 0x04
     474:	81 e3       	ldi	r24, 0x31	; 49
     476:	80 83       	st	Z, r24
	pxTopOfStack--;
     478:	8b 81       	ldd	r24, Y+3	; 0x03
     47a:	9c 81       	ldd	r25, Y+4	; 0x04
     47c:	01 97       	sbiw	r24, 0x01	; 1
     47e:	9c 83       	std	Y+4, r25	; 0x04
     480:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
}
     486:	28 96       	adiw	r28, 0x08	; 8
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	cf 91       	pop	r28
     494:	df 91       	pop	r29
     496:	08 95       	ret

00000498 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     498:	df 93       	push	r29
     49a:	cf 93       	push	r28
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4a0:	0e 94 3e 03 	call	0x67c	; 0x67c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4a4:	a0 91 a6 06 	lds	r26, 0x06A6
     4a8:	b0 91 a7 06 	lds	r27, 0x06A7
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     4fa:	81 e0       	ldi	r24, 0x01	; 1
}
     4fc:	cf 91       	pop	r28
     4fe:	df 91       	pop	r29
     500:	08 95       	ret

00000502 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     502:	df 93       	push	r29
     504:	cf 93       	push	r28
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     50a:	cf 91       	pop	r28
     50c:	df 91       	pop	r29
     50e:	08 95       	ret

00000510 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     510:	0f 92       	push	r0
     512:	0f b6       	in	r0, 0x3f	; 63
     514:	f8 94       	cli
     516:	0f 92       	push	r0
     518:	1f 92       	push	r1
     51a:	11 24       	eor	r1, r1
     51c:	2f 92       	push	r2
     51e:	3f 92       	push	r3
     520:	4f 92       	push	r4
     522:	5f 92       	push	r5
     524:	6f 92       	push	r6
     526:	7f 92       	push	r7
     528:	8f 92       	push	r8
     52a:	9f 92       	push	r9
     52c:	af 92       	push	r10
     52e:	bf 92       	push	r11
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	ef 93       	push	r30
     556:	ff 93       	push	r31
     558:	a0 91 a6 06 	lds	r26, 0x06A6
     55c:	b0 91 a7 06 	lds	r27, 0x06A7
     560:	0d b6       	in	r0, 0x3d	; 61
     562:	0d 92       	st	X+, r0
     564:	0e b6       	in	r0, 0x3e	; 62
     566:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     568:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     56c:	a0 91 a6 06 	lds	r26, 0x06A6
     570:	b0 91 a7 06 	lds	r27, 0x06A7
     574:	cd 91       	ld	r28, X+
     576:	cd bf       	out	0x3d, r28	; 61
     578:	dd 91       	ld	r29, X+
     57a:	de bf       	out	0x3e, r29	; 62
     57c:	ff 91       	pop	r31
     57e:	ef 91       	pop	r30
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	bf 91       	pop	r27
     586:	af 91       	pop	r26
     588:	9f 91       	pop	r25
     58a:	8f 91       	pop	r24
     58c:	7f 91       	pop	r23
     58e:	6f 91       	pop	r22
     590:	5f 91       	pop	r21
     592:	4f 91       	pop	r20
     594:	3f 91       	pop	r19
     596:	2f 91       	pop	r18
     598:	1f 91       	pop	r17
     59a:	0f 91       	pop	r16
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	bf 90       	pop	r11
     5a6:	af 90       	pop	r10
     5a8:	9f 90       	pop	r9
     5aa:	8f 90       	pop	r8
     5ac:	7f 90       	pop	r7
     5ae:	6f 90       	pop	r6
     5b0:	5f 90       	pop	r5
     5b2:	4f 90       	pop	r4
     5b4:	3f 90       	pop	r3
     5b6:	2f 90       	pop	r2
     5b8:	1f 90       	pop	r1
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63
     5be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5c0:	08 95       	ret

000005c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	f8 94       	cli
     5c8:	0f 92       	push	r0
     5ca:	1f 92       	push	r1
     5cc:	11 24       	eor	r1, r1
     5ce:	2f 92       	push	r2
     5d0:	3f 92       	push	r3
     5d2:	4f 92       	push	r4
     5d4:	5f 92       	push	r5
     5d6:	6f 92       	push	r6
     5d8:	7f 92       	push	r7
     5da:	8f 92       	push	r8
     5dc:	9f 92       	push	r9
     5de:	af 92       	push	r10
     5e0:	bf 92       	push	r11
     5e2:	cf 92       	push	r12
     5e4:	df 92       	push	r13
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	2f 93       	push	r18
     5f0:	3f 93       	push	r19
     5f2:	4f 93       	push	r20
     5f4:	5f 93       	push	r21
     5f6:	6f 93       	push	r22
     5f8:	7f 93       	push	r23
     5fa:	8f 93       	push	r24
     5fc:	9f 93       	push	r25
     5fe:	af 93       	push	r26
     600:	bf 93       	push	r27
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	ef 93       	push	r30
     608:	ff 93       	push	r31
     60a:	a0 91 a6 06 	lds	r26, 0x06A6
     60e:	b0 91 a7 06 	lds	r27, 0x06A7
     612:	0d b6       	in	r0, 0x3d	; 61
     614:	0d 92       	st	X+, r0
     616:	0e b6       	in	r0, 0x3e	; 62
     618:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     61a:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <xTaskIncrementTick>
     61e:	88 23       	and	r24, r24
     620:	11 f0       	breq	.+4      	; 0x626 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     622:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     626:	a0 91 a6 06 	lds	r26, 0x06A6
     62a:	b0 91 a7 06 	lds	r27, 0x06A7
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     67c:	df 93       	push	r29
     67e:	cf 93       	push	r28
     680:	00 d0       	rcall	.+0      	; 0x682 <prvSetupTimerInterrupt+0x6>
     682:	00 d0       	rcall	.+0      	; 0x684 <prvSetupTimerInterrupt+0x8>
     684:	00 d0       	rcall	.+0      	; 0x686 <prvSetupTimerInterrupt+0xa>
     686:	cd b7       	in	r28, 0x3d	; 61
     688:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     68a:	80 e4       	ldi	r24, 0x40	; 64
     68c:	9f e1       	ldi	r25, 0x1F	; 31
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	8b 83       	std	Y+3, r24	; 0x03
     694:	9c 83       	std	Y+4, r25	; 0x04
     696:	ad 83       	std	Y+5, r26	; 0x05
     698:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     69a:	8b 81       	ldd	r24, Y+3	; 0x03
     69c:	9c 81       	ldd	r25, Y+4	; 0x04
     69e:	ad 81       	ldd	r26, Y+5	; 0x05
     6a0:	be 81       	ldd	r27, Y+6	; 0x06
     6a2:	68 94       	set
     6a4:	15 f8       	bld	r1, 5
     6a6:	b6 95       	lsr	r27
     6a8:	a7 95       	ror	r26
     6aa:	97 95       	ror	r25
     6ac:	87 95       	ror	r24
     6ae:	16 94       	lsr	r1
     6b0:	d1 f7       	brne	.-12     	; 0x6a6 <prvSetupTimerInterrupt+0x2a>
     6b2:	8b 83       	std	Y+3, r24	; 0x03
     6b4:	9c 83       	std	Y+4, r25	; 0x04
     6b6:	ad 83       	std	Y+5, r26	; 0x05
     6b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	9c 81       	ldd	r25, Y+4	; 0x04
     6be:	ad 81       	ldd	r26, Y+5	; 0x05
     6c0:	be 81       	ldd	r27, Y+6	; 0x06
     6c2:	01 97       	sbiw	r24, 0x01	; 1
     6c4:	a1 09       	sbc	r26, r1
     6c6:	b1 09       	sbc	r27, r1
     6c8:	8b 83       	std	Y+3, r24	; 0x03
     6ca:	9c 83       	std	Y+4, r25	; 0x04
     6cc:	ad 83       	std	Y+5, r26	; 0x05
     6ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	ad 81       	ldd	r26, Y+5	; 0x05
     6da:	be 81       	ldd	r27, Y+6	; 0x06
     6dc:	89 2f       	mov	r24, r25
     6de:	9a 2f       	mov	r25, r26
     6e0:	ab 2f       	mov	r26, r27
     6e2:	bb 27       	eor	r27, r27
     6e4:	8b 83       	std	Y+3, r24	; 0x03
     6e6:	9c 83       	std	Y+4, r25	; 0x04
     6e8:	ad 83       	std	Y+5, r26	; 0x05
     6ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6ec:	8b 81       	ldd	r24, Y+3	; 0x03
     6ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     6f0:	eb e4       	ldi	r30, 0x4B	; 75
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	8a 81       	ldd	r24, Y+2	; 0x02
     6f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     6f8:	ea e4       	ldi	r30, 0x4A	; 74
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
     6fc:	89 81       	ldd	r24, Y+1	; 0x01
     6fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     700:	8b e0       	ldi	r24, 0x0B	; 11
     702:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     704:	ee e4       	ldi	r30, 0x4E	; 78
     706:	f0 e0       	ldi	r31, 0x00	; 0
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     70c:	e9 e5       	ldi	r30, 0x59	; 89
     70e:	f0 e0       	ldi	r31, 0x00	; 0
     710:	80 81       	ld	r24, Z
     712:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	80 61       	ori	r24, 0x10	; 16
     718:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     71a:	e9 e5       	ldi	r30, 0x59	; 89
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	80 83       	st	Z, r24
}
     722:	26 96       	adiw	r28, 0x06	; 6
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <READ_IGNITON>:


#include "Btn_Handler.h"
#include "DIO.h"

uint8_t READ_IGNITON(void){
     73a:	df 93       	push	r29
     73c:	cf 93       	push	r28
     73e:	0f 92       	push	r0
     740:	cd b7       	in	r28, 0x3d	; 61
     742:	de b7       	in	r29, 0x3e	; 62

	DIO_SetPinDir(DIO_PORTA ,Pin0, INPUT);
     744:	80 e0       	ldi	r24, 0x00	; 0
     746:	60 e0       	ldi	r22, 0x00	; 0
     748:	42 e0       	ldi	r20, 0x02	; 2
     74a:	0e 94 ed 03 	call	0x7da	; 0x7da <DIO_SetPinDir>
	uint8_t IGNITION_data = DIO_GetPinVal(DIO_PORTA ,Pin0) ;
     74e:	80 e0       	ldi	r24, 0x00	; 0
     750:	60 e0       	ldi	r22, 0x00	; 0
     752:	0e 94 c7 05 	call	0xb8e	; 0xb8e <DIO_GetPinVal>
     756:	89 83       	std	Y+1, r24	; 0x01
	return IGNITION_data;
     758:	89 81       	ldd	r24, Y+1	; 0x01
}
     75a:	0f 90       	pop	r0
     75c:	cf 91       	pop	r28
     75e:	df 91       	pop	r29
     760:	08 95       	ret

00000762 <READ_HAZARD_Button>:
uint8_t READ_HAZARD_Button(void){
     762:	df 93       	push	r29
     764:	cf 93       	push	r28
     766:	0f 92       	push	r0
     768:	cd b7       	in	r28, 0x3d	; 61
     76a:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin1, INPUT);
     76c:	80 e0       	ldi	r24, 0x00	; 0
     76e:	61 e0       	ldi	r22, 0x01	; 1
     770:	42 e0       	ldi	r20, 0x02	; 2
     772:	0e 94 ed 03 	call	0x7da	; 0x7da <DIO_SetPinDir>
	uint8_t HAZARD_data = DIO_GetPinVal(DIO_PORTA ,Pin1) ;
     776:	80 e0       	ldi	r24, 0x00	; 0
     778:	61 e0       	ldi	r22, 0x01	; 1
     77a:	0e 94 c7 05 	call	0xb8e	; 0xb8e <DIO_GetPinVal>
     77e:	89 83       	std	Y+1, r24	; 0x01
	 return pressed ;
	 }else{
	 return unpressed;
	 }
	 */
	return HAZARD_data;
     780:	89 81       	ldd	r24, Y+1	; 0x01
}
     782:	0f 90       	pop	r0
     784:	cf 91       	pop	r28
     786:	df 91       	pop	r29
     788:	08 95       	ret

0000078a <READ_RIGHT_Button>:
uint8_t READ_RIGHT_Button(void){
     78a:	df 93       	push	r29
     78c:	cf 93       	push	r28
     78e:	0f 92       	push	r0
     790:	cd b7       	in	r28, 0x3d	; 61
     792:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin2, INPUT);
     794:	80 e0       	ldi	r24, 0x00	; 0
     796:	62 e0       	ldi	r22, 0x02	; 2
     798:	42 e0       	ldi	r20, 0x02	; 2
     79a:	0e 94 ed 03 	call	0x7da	; 0x7da <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin2) ;
     79e:	80 e0       	ldi	r24, 0x00	; 0
     7a0:	62 e0       	ldi	r22, 0x02	; 2
     7a2:	0e 94 c7 05 	call	0xb8e	; 0xb8e <DIO_GetPinVal>
     7a6:	89 83       	std	Y+1, r24	; 0x01
	return right_data ;
     7a8:	89 81       	ldd	r24, Y+1	; 0x01
}
     7aa:	0f 90       	pop	r0
     7ac:	cf 91       	pop	r28
     7ae:	df 91       	pop	r29
     7b0:	08 95       	ret

000007b2 <READ_LEFT_Button>:
uint8_t READ_LEFT_Button(void){
     7b2:	df 93       	push	r29
     7b4:	cf 93       	push	r28
     7b6:	0f 92       	push	r0
     7b8:	cd b7       	in	r28, 0x3d	; 61
     7ba:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin3, INPUT);
     7bc:	80 e0       	ldi	r24, 0x00	; 0
     7be:	63 e0       	ldi	r22, 0x03	; 3
     7c0:	42 e0       	ldi	r20, 0x02	; 2
     7c2:	0e 94 ed 03 	call	0x7da	; 0x7da <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin3) ;
     7c6:	80 e0       	ldi	r24, 0x00	; 0
     7c8:	63 e0       	ldi	r22, 0x03	; 3
     7ca:	0e 94 c7 05 	call	0xb8e	; 0xb8e <DIO_GetPinVal>
     7ce:	89 83       	std	Y+1, r24	; 0x01
	return right_data;
     7d0:	89 81       	ldd	r24, Y+1	; 0x01

}
     7d2:	0f 90       	pop	r0
     7d4:	cf 91       	pop	r28
     7d6:	df 91       	pop	r29
     7d8:	08 95       	ret

000007da <DIO_SetPinDir>:


#include "DIO.h"

void DIO_SetPinDir(uint8_t port ,uint8_t pin, uint8_t dir)
{
     7da:	df 93       	push	r29
     7dc:	cf 93       	push	r28
     7de:	cd b7       	in	r28, 0x3d	; 61
     7e0:	de b7       	in	r29, 0x3e	; 62
     7e2:	2d 97       	sbiw	r28, 0x0d	; 13
     7e4:	0f b6       	in	r0, 0x3f	; 63
     7e6:	f8 94       	cli
     7e8:	de bf       	out	0x3e, r29	; 62
     7ea:	0f be       	out	0x3f, r0	; 63
     7ec:	cd bf       	out	0x3d, r28	; 61
     7ee:	89 83       	std	Y+1, r24	; 0x01
     7f0:	6a 83       	std	Y+2, r22	; 0x02
     7f2:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     7f4:	89 81       	ldd	r24, Y+1	; 0x01
     7f6:	28 2f       	mov	r18, r24
     7f8:	30 e0       	ldi	r19, 0x00	; 0
     7fa:	3d 87       	std	Y+13, r19	; 0x0d
     7fc:	2c 87       	std	Y+12, r18	; 0x0c
     7fe:	8c 85       	ldd	r24, Y+12	; 0x0c
     800:	9d 85       	ldd	r25, Y+13	; 0x0d
     802:	81 30       	cpi	r24, 0x01	; 1
     804:	91 05       	cpc	r25, r1
     806:	09 f4       	brne	.+2      	; 0x80a <DIO_SetPinDir+0x30>
     808:	44 c0       	rjmp	.+136    	; 0x892 <__stack+0x33>
     80a:	2c 85       	ldd	r18, Y+12	; 0x0c
     80c:	3d 85       	ldd	r19, Y+13	; 0x0d
     80e:	22 30       	cpi	r18, 0x02	; 2
     810:	31 05       	cpc	r19, r1
     812:	2c f4       	brge	.+10     	; 0x81e <DIO_SetPinDir+0x44>
     814:	8c 85       	ldd	r24, Y+12	; 0x0c
     816:	9d 85       	ldd	r25, Y+13	; 0x0d
     818:	00 97       	sbiw	r24, 0x00	; 0
     81a:	71 f0       	breq	.+28     	; 0x838 <DIO_SetPinDir+0x5e>
     81c:	c2 c0       	rjmp	.+388    	; 0x9a2 <__stack+0x143>
     81e:	2c 85       	ldd	r18, Y+12	; 0x0c
     820:	3d 85       	ldd	r19, Y+13	; 0x0d
     822:	22 30       	cpi	r18, 0x02	; 2
     824:	31 05       	cpc	r19, r1
     826:	09 f4       	brne	.+2      	; 0x82a <DIO_SetPinDir+0x50>
     828:	62 c0       	rjmp	.+196    	; 0x8ee <__stack+0x8f>
     82a:	8c 85       	ldd	r24, Y+12	; 0x0c
     82c:	9d 85       	ldd	r25, Y+13	; 0x0d
     82e:	83 30       	cpi	r24, 0x03	; 3
     830:	91 05       	cpc	r25, r1
     832:	09 f4       	brne	.+2      	; 0x836 <DIO_SetPinDir+0x5c>
     834:	89 c0       	rjmp	.+274    	; 0x948 <__stack+0xe9>
     836:	b5 c0       	rjmp	.+362    	; 0x9a2 <__stack+0x143>
	{
		case DIO_PORTA:
		(dir == OUTPUT)? (SET_BIT(DDRA,pin)):(CLR_BIT(DDRA,pin));
     838:	8b 81       	ldd	r24, Y+3	; 0x03
     83a:	83 30       	cpi	r24, 0x03	; 3
     83c:	a9 f4       	brne	.+42     	; 0x868 <__stack+0x9>
     83e:	aa e3       	ldi	r26, 0x3A	; 58
     840:	b0 e0       	ldi	r27, 0x00	; 0
     842:	ea e3       	ldi	r30, 0x3A	; 58
     844:	f0 e0       	ldi	r31, 0x00	; 0
     846:	80 81       	ld	r24, Z
     848:	48 2f       	mov	r20, r24
     84a:	8a 81       	ldd	r24, Y+2	; 0x02
     84c:	28 2f       	mov	r18, r24
     84e:	30 e0       	ldi	r19, 0x00	; 0
     850:	81 e0       	ldi	r24, 0x01	; 1
     852:	90 e0       	ldi	r25, 0x00	; 0
     854:	02 2e       	mov	r0, r18
     856:	02 c0       	rjmp	.+4      	; 0x85c <DIO_SetPinDir+0x82>
     858:	88 0f       	add	r24, r24
     85a:	99 1f       	adc	r25, r25
     85c:	0a 94       	dec	r0
     85e:	e2 f7       	brpl	.-8      	; 0x858 <DIO_SetPinDir+0x7e>
     860:	84 2b       	or	r24, r20
     862:	8c 93       	st	X, r24
     864:	9c 91       	ld	r25, X
     866:	9d c0       	rjmp	.+314    	; 0x9a2 <__stack+0x143>
     868:	aa e3       	ldi	r26, 0x3A	; 58
     86a:	b0 e0       	ldi	r27, 0x00	; 0
     86c:	ea e3       	ldi	r30, 0x3A	; 58
     86e:	f0 e0       	ldi	r31, 0x00	; 0
     870:	80 81       	ld	r24, Z
     872:	48 2f       	mov	r20, r24
     874:	8a 81       	ldd	r24, Y+2	; 0x02
     876:	28 2f       	mov	r18, r24
     878:	30 e0       	ldi	r19, 0x00	; 0
     87a:	81 e0       	ldi	r24, 0x01	; 1
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	02 c0       	rjmp	.+4      	; 0x884 <__stack+0x25>
     880:	88 0f       	add	r24, r24
     882:	99 1f       	adc	r25, r25
     884:	2a 95       	dec	r18
     886:	e2 f7       	brpl	.-8      	; 0x880 <__stack+0x21>
     888:	80 95       	com	r24
     88a:	84 23       	and	r24, r20
     88c:	8c 93       	st	X, r24
     88e:	2c 91       	ld	r18, X
     890:	88 c0       	rjmp	.+272    	; 0x9a2 <__stack+0x143>
		break;

		case DIO_PORTB:
		(dir == OUTPUT)? (SET_BIT(DDRB,pin)):(CLR_BIT(DDRB,pin));
     892:	8b 81       	ldd	r24, Y+3	; 0x03
     894:	83 30       	cpi	r24, 0x03	; 3
     896:	a9 f4       	brne	.+42     	; 0x8c2 <__stack+0x63>
     898:	a7 e3       	ldi	r26, 0x37	; 55
     89a:	b0 e0       	ldi	r27, 0x00	; 0
     89c:	e7 e3       	ldi	r30, 0x37	; 55
     89e:	f0 e0       	ldi	r31, 0x00	; 0
     8a0:	80 81       	ld	r24, Z
     8a2:	48 2f       	mov	r20, r24
     8a4:	8a 81       	ldd	r24, Y+2	; 0x02
     8a6:	28 2f       	mov	r18, r24
     8a8:	30 e0       	ldi	r19, 0x00	; 0
     8aa:	81 e0       	ldi	r24, 0x01	; 1
     8ac:	90 e0       	ldi	r25, 0x00	; 0
     8ae:	02 2e       	mov	r0, r18
     8b0:	02 c0       	rjmp	.+4      	; 0x8b6 <__stack+0x57>
     8b2:	88 0f       	add	r24, r24
     8b4:	99 1f       	adc	r25, r25
     8b6:	0a 94       	dec	r0
     8b8:	e2 f7       	brpl	.-8      	; 0x8b2 <__stack+0x53>
     8ba:	84 2b       	or	r24, r20
     8bc:	8c 93       	st	X, r24
     8be:	3c 91       	ld	r19, X
     8c0:	70 c0       	rjmp	.+224    	; 0x9a2 <__stack+0x143>
     8c2:	a7 e3       	ldi	r26, 0x37	; 55
     8c4:	b0 e0       	ldi	r27, 0x00	; 0
     8c6:	e7 e3       	ldi	r30, 0x37	; 55
     8c8:	f0 e0       	ldi	r31, 0x00	; 0
     8ca:	80 81       	ld	r24, Z
     8cc:	48 2f       	mov	r20, r24
     8ce:	8a 81       	ldd	r24, Y+2	; 0x02
     8d0:	28 2f       	mov	r18, r24
     8d2:	30 e0       	ldi	r19, 0x00	; 0
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	90 e0       	ldi	r25, 0x00	; 0
     8d8:	02 2e       	mov	r0, r18
     8da:	02 c0       	rjmp	.+4      	; 0x8e0 <__stack+0x81>
     8dc:	88 0f       	add	r24, r24
     8de:	99 1f       	adc	r25, r25
     8e0:	0a 94       	dec	r0
     8e2:	e2 f7       	brpl	.-8      	; 0x8dc <__stack+0x7d>
     8e4:	80 95       	com	r24
     8e6:	84 23       	and	r24, r20
     8e8:	8c 93       	st	X, r24
     8ea:	8c 91       	ld	r24, X
     8ec:	5a c0       	rjmp	.+180    	; 0x9a2 <__stack+0x143>
		break;

		case DIO_PORTC:
		(dir == OUTPUT)? (SET_BIT(DDRC,pin)):(CLR_BIT(DDRC,pin));
     8ee:	8b 81       	ldd	r24, Y+3	; 0x03
     8f0:	83 30       	cpi	r24, 0x03	; 3
     8f2:	a9 f4       	brne	.+42     	; 0x91e <__stack+0xbf>
     8f4:	a4 e3       	ldi	r26, 0x34	; 52
     8f6:	b0 e0       	ldi	r27, 0x00	; 0
     8f8:	e4 e3       	ldi	r30, 0x34	; 52
     8fa:	f0 e0       	ldi	r31, 0x00	; 0
     8fc:	80 81       	ld	r24, Z
     8fe:	48 2f       	mov	r20, r24
     900:	8a 81       	ldd	r24, Y+2	; 0x02
     902:	28 2f       	mov	r18, r24
     904:	30 e0       	ldi	r19, 0x00	; 0
     906:	81 e0       	ldi	r24, 0x01	; 1
     908:	90 e0       	ldi	r25, 0x00	; 0
     90a:	02 2e       	mov	r0, r18
     90c:	02 c0       	rjmp	.+4      	; 0x912 <__stack+0xb3>
     90e:	88 0f       	add	r24, r24
     910:	99 1f       	adc	r25, r25
     912:	0a 94       	dec	r0
     914:	e2 f7       	brpl	.-8      	; 0x90e <__stack+0xaf>
     916:	84 2b       	or	r24, r20
     918:	8c 93       	st	X, r24
     91a:	9c 91       	ld	r25, X
     91c:	42 c0       	rjmp	.+132    	; 0x9a2 <__stack+0x143>
     91e:	a4 e3       	ldi	r26, 0x34	; 52
     920:	b0 e0       	ldi	r27, 0x00	; 0
     922:	e4 e3       	ldi	r30, 0x34	; 52
     924:	f0 e0       	ldi	r31, 0x00	; 0
     926:	80 81       	ld	r24, Z
     928:	48 2f       	mov	r20, r24
     92a:	8a 81       	ldd	r24, Y+2	; 0x02
     92c:	28 2f       	mov	r18, r24
     92e:	30 e0       	ldi	r19, 0x00	; 0
     930:	81 e0       	ldi	r24, 0x01	; 1
     932:	90 e0       	ldi	r25, 0x00	; 0
     934:	02 c0       	rjmp	.+4      	; 0x93a <__stack+0xdb>
     936:	88 0f       	add	r24, r24
     938:	99 1f       	adc	r25, r25
     93a:	2a 95       	dec	r18
     93c:	e2 f7       	brpl	.-8      	; 0x936 <__stack+0xd7>
     93e:	80 95       	com	r24
     940:	84 23       	and	r24, r20
     942:	8c 93       	st	X, r24
     944:	2c 91       	ld	r18, X
     946:	2d c0       	rjmp	.+90     	; 0x9a2 <__stack+0x143>
		break;

		case DIO_PORTD:
		(dir == OUTPUT)? (SET_BIT(DDRD,pin)):(CLR_BIT(DDRD,pin));
     948:	8b 81       	ldd	r24, Y+3	; 0x03
     94a:	83 30       	cpi	r24, 0x03	; 3
     94c:	a9 f4       	brne	.+42     	; 0x978 <__stack+0x119>
     94e:	a1 e3       	ldi	r26, 0x31	; 49
     950:	b0 e0       	ldi	r27, 0x00	; 0
     952:	e1 e3       	ldi	r30, 0x31	; 49
     954:	f0 e0       	ldi	r31, 0x00	; 0
     956:	80 81       	ld	r24, Z
     958:	48 2f       	mov	r20, r24
     95a:	8a 81       	ldd	r24, Y+2	; 0x02
     95c:	28 2f       	mov	r18, r24
     95e:	30 e0       	ldi	r19, 0x00	; 0
     960:	81 e0       	ldi	r24, 0x01	; 1
     962:	90 e0       	ldi	r25, 0x00	; 0
     964:	02 2e       	mov	r0, r18
     966:	02 c0       	rjmp	.+4      	; 0x96c <__stack+0x10d>
     968:	88 0f       	add	r24, r24
     96a:	99 1f       	adc	r25, r25
     96c:	0a 94       	dec	r0
     96e:	e2 f7       	brpl	.-8      	; 0x968 <__stack+0x109>
     970:	84 2b       	or	r24, r20
     972:	8c 93       	st	X, r24
     974:	3c 91       	ld	r19, X
     976:	15 c0       	rjmp	.+42     	; 0x9a2 <__stack+0x143>
     978:	a1 e3       	ldi	r26, 0x31	; 49
     97a:	b0 e0       	ldi	r27, 0x00	; 0
     97c:	e1 e3       	ldi	r30, 0x31	; 49
     97e:	f0 e0       	ldi	r31, 0x00	; 0
     980:	80 81       	ld	r24, Z
     982:	48 2f       	mov	r20, r24
     984:	8a 81       	ldd	r24, Y+2	; 0x02
     986:	28 2f       	mov	r18, r24
     988:	30 e0       	ldi	r19, 0x00	; 0
     98a:	81 e0       	ldi	r24, 0x01	; 1
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	02 2e       	mov	r0, r18
     990:	02 c0       	rjmp	.+4      	; 0x996 <__stack+0x137>
     992:	88 0f       	add	r24, r24
     994:	99 1f       	adc	r25, r25
     996:	0a 94       	dec	r0
     998:	e2 f7       	brpl	.-8      	; 0x992 <__stack+0x133>
     99a:	80 95       	com	r24
     99c:	84 23       	and	r24, r20
     99e:	8c 93       	st	X, r24
     9a0:	8c 91       	ld	r24, X
		break;
	}
}
     9a2:	2d 96       	adiw	r28, 0x0d	; 13
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	de bf       	out	0x3e, r29	; 62
     9aa:	0f be       	out	0x3f, r0	; 63
     9ac:	cd bf       	out	0x3d, r28	; 61
     9ae:	cf 91       	pop	r28
     9b0:	df 91       	pop	r29
     9b2:	08 95       	ret

000009b4 <DIO_SetPinVal>:


void DIO_SetPinVal(uint8_t port ,uint8_t pin , uint8_t val)
{
     9b4:	df 93       	push	r29
     9b6:	cf 93       	push	r28
     9b8:	cd b7       	in	r28, 0x3d	; 61
     9ba:	de b7       	in	r29, 0x3e	; 62
     9bc:	2d 97       	sbiw	r28, 0x0d	; 13
     9be:	0f b6       	in	r0, 0x3f	; 63
     9c0:	f8 94       	cli
     9c2:	de bf       	out	0x3e, r29	; 62
     9c4:	0f be       	out	0x3f, r0	; 63
     9c6:	cd bf       	out	0x3d, r28	; 61
     9c8:	89 83       	std	Y+1, r24	; 0x01
     9ca:	6a 83       	std	Y+2, r22	; 0x02
     9cc:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     9ce:	89 81       	ldd	r24, Y+1	; 0x01
     9d0:	28 2f       	mov	r18, r24
     9d2:	30 e0       	ldi	r19, 0x00	; 0
     9d4:	3d 87       	std	Y+13, r19	; 0x0d
     9d6:	2c 87       	std	Y+12, r18	; 0x0c
     9d8:	8c 85       	ldd	r24, Y+12	; 0x0c
     9da:	9d 85       	ldd	r25, Y+13	; 0x0d
     9dc:	81 30       	cpi	r24, 0x01	; 1
     9de:	91 05       	cpc	r25, r1
     9e0:	09 f4       	brne	.+2      	; 0x9e4 <DIO_SetPinVal+0x30>
     9e2:	44 c0       	rjmp	.+136    	; 0xa6c <DIO_SetPinVal+0xb8>
     9e4:	2c 85       	ldd	r18, Y+12	; 0x0c
     9e6:	3d 85       	ldd	r19, Y+13	; 0x0d
     9e8:	22 30       	cpi	r18, 0x02	; 2
     9ea:	31 05       	cpc	r19, r1
     9ec:	2c f4       	brge	.+10     	; 0x9f8 <DIO_SetPinVal+0x44>
     9ee:	8c 85       	ldd	r24, Y+12	; 0x0c
     9f0:	9d 85       	ldd	r25, Y+13	; 0x0d
     9f2:	00 97       	sbiw	r24, 0x00	; 0
     9f4:	71 f0       	breq	.+28     	; 0xa12 <DIO_SetPinVal+0x5e>
     9f6:	c2 c0       	rjmp	.+388    	; 0xb7c <DIO_SetPinVal+0x1c8>
     9f8:	2c 85       	ldd	r18, Y+12	; 0x0c
     9fa:	3d 85       	ldd	r19, Y+13	; 0x0d
     9fc:	22 30       	cpi	r18, 0x02	; 2
     9fe:	31 05       	cpc	r19, r1
     a00:	09 f4       	brne	.+2      	; 0xa04 <DIO_SetPinVal+0x50>
     a02:	62 c0       	rjmp	.+196    	; 0xac8 <DIO_SetPinVal+0x114>
     a04:	8c 85       	ldd	r24, Y+12	; 0x0c
     a06:	9d 85       	ldd	r25, Y+13	; 0x0d
     a08:	83 30       	cpi	r24, 0x03	; 3
     a0a:	91 05       	cpc	r25, r1
     a0c:	09 f4       	brne	.+2      	; 0xa10 <DIO_SetPinVal+0x5c>
     a0e:	89 c0       	rjmp	.+274    	; 0xb22 <DIO_SetPinVal+0x16e>
     a10:	b5 c0       	rjmp	.+362    	; 0xb7c <DIO_SetPinVal+0x1c8>
	{
		case DIO_PORTA:
		(val == HIGH)? (SET_BIT(PORTA,pin)):(CLR_BIT(PORTA,pin));
     a12:	8b 81       	ldd	r24, Y+3	; 0x03
     a14:	81 30       	cpi	r24, 0x01	; 1
     a16:	a9 f4       	brne	.+42     	; 0xa42 <DIO_SetPinVal+0x8e>
     a18:	ab e3       	ldi	r26, 0x3B	; 59
     a1a:	b0 e0       	ldi	r27, 0x00	; 0
     a1c:	eb e3       	ldi	r30, 0x3B	; 59
     a1e:	f0 e0       	ldi	r31, 0x00	; 0
     a20:	80 81       	ld	r24, Z
     a22:	48 2f       	mov	r20, r24
     a24:	8a 81       	ldd	r24, Y+2	; 0x02
     a26:	28 2f       	mov	r18, r24
     a28:	30 e0       	ldi	r19, 0x00	; 0
     a2a:	81 e0       	ldi	r24, 0x01	; 1
     a2c:	90 e0       	ldi	r25, 0x00	; 0
     a2e:	02 2e       	mov	r0, r18
     a30:	02 c0       	rjmp	.+4      	; 0xa36 <DIO_SetPinVal+0x82>
     a32:	88 0f       	add	r24, r24
     a34:	99 1f       	adc	r25, r25
     a36:	0a 94       	dec	r0
     a38:	e2 f7       	brpl	.-8      	; 0xa32 <DIO_SetPinVal+0x7e>
     a3a:	84 2b       	or	r24, r20
     a3c:	8c 93       	st	X, r24
     a3e:	9c 91       	ld	r25, X
     a40:	9d c0       	rjmp	.+314    	; 0xb7c <DIO_SetPinVal+0x1c8>
     a42:	ab e3       	ldi	r26, 0x3B	; 59
     a44:	b0 e0       	ldi	r27, 0x00	; 0
     a46:	eb e3       	ldi	r30, 0x3B	; 59
     a48:	f0 e0       	ldi	r31, 0x00	; 0
     a4a:	80 81       	ld	r24, Z
     a4c:	48 2f       	mov	r20, r24
     a4e:	8a 81       	ldd	r24, Y+2	; 0x02
     a50:	28 2f       	mov	r18, r24
     a52:	30 e0       	ldi	r19, 0x00	; 0
     a54:	81 e0       	ldi	r24, 0x01	; 1
     a56:	90 e0       	ldi	r25, 0x00	; 0
     a58:	02 c0       	rjmp	.+4      	; 0xa5e <DIO_SetPinVal+0xaa>
     a5a:	88 0f       	add	r24, r24
     a5c:	99 1f       	adc	r25, r25
     a5e:	2a 95       	dec	r18
     a60:	e2 f7       	brpl	.-8      	; 0xa5a <DIO_SetPinVal+0xa6>
     a62:	80 95       	com	r24
     a64:	84 23       	and	r24, r20
     a66:	8c 93       	st	X, r24
     a68:	2c 91       	ld	r18, X
     a6a:	88 c0       	rjmp	.+272    	; 0xb7c <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTB:
		(val == HIGH)? (SET_BIT(PORTB,pin)):(CLR_BIT(PORTB,pin));
     a6c:	8b 81       	ldd	r24, Y+3	; 0x03
     a6e:	81 30       	cpi	r24, 0x01	; 1
     a70:	a9 f4       	brne	.+42     	; 0xa9c <DIO_SetPinVal+0xe8>
     a72:	a8 e3       	ldi	r26, 0x38	; 56
     a74:	b0 e0       	ldi	r27, 0x00	; 0
     a76:	e8 e3       	ldi	r30, 0x38	; 56
     a78:	f0 e0       	ldi	r31, 0x00	; 0
     a7a:	80 81       	ld	r24, Z
     a7c:	48 2f       	mov	r20, r24
     a7e:	8a 81       	ldd	r24, Y+2	; 0x02
     a80:	28 2f       	mov	r18, r24
     a82:	30 e0       	ldi	r19, 0x00	; 0
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	02 2e       	mov	r0, r18
     a8a:	02 c0       	rjmp	.+4      	; 0xa90 <DIO_SetPinVal+0xdc>
     a8c:	88 0f       	add	r24, r24
     a8e:	99 1f       	adc	r25, r25
     a90:	0a 94       	dec	r0
     a92:	e2 f7       	brpl	.-8      	; 0xa8c <DIO_SetPinVal+0xd8>
     a94:	84 2b       	or	r24, r20
     a96:	8c 93       	st	X, r24
     a98:	3c 91       	ld	r19, X
     a9a:	70 c0       	rjmp	.+224    	; 0xb7c <DIO_SetPinVal+0x1c8>
     a9c:	a8 e3       	ldi	r26, 0x38	; 56
     a9e:	b0 e0       	ldi	r27, 0x00	; 0
     aa0:	e8 e3       	ldi	r30, 0x38	; 56
     aa2:	f0 e0       	ldi	r31, 0x00	; 0
     aa4:	80 81       	ld	r24, Z
     aa6:	48 2f       	mov	r20, r24
     aa8:	8a 81       	ldd	r24, Y+2	; 0x02
     aaa:	28 2f       	mov	r18, r24
     aac:	30 e0       	ldi	r19, 0x00	; 0
     aae:	81 e0       	ldi	r24, 0x01	; 1
     ab0:	90 e0       	ldi	r25, 0x00	; 0
     ab2:	02 2e       	mov	r0, r18
     ab4:	02 c0       	rjmp	.+4      	; 0xaba <DIO_SetPinVal+0x106>
     ab6:	88 0f       	add	r24, r24
     ab8:	99 1f       	adc	r25, r25
     aba:	0a 94       	dec	r0
     abc:	e2 f7       	brpl	.-8      	; 0xab6 <DIO_SetPinVal+0x102>
     abe:	80 95       	com	r24
     ac0:	84 23       	and	r24, r20
     ac2:	8c 93       	st	X, r24
     ac4:	8c 91       	ld	r24, X
     ac6:	5a c0       	rjmp	.+180    	; 0xb7c <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTC:
		(val == HIGH)? (SET_BIT(PORTC,pin)):(CLR_BIT(PORTC,pin));
     ac8:	8b 81       	ldd	r24, Y+3	; 0x03
     aca:	81 30       	cpi	r24, 0x01	; 1
     acc:	a9 f4       	brne	.+42     	; 0xaf8 <DIO_SetPinVal+0x144>
     ace:	a5 e3       	ldi	r26, 0x35	; 53
     ad0:	b0 e0       	ldi	r27, 0x00	; 0
     ad2:	e5 e3       	ldi	r30, 0x35	; 53
     ad4:	f0 e0       	ldi	r31, 0x00	; 0
     ad6:	80 81       	ld	r24, Z
     ad8:	48 2f       	mov	r20, r24
     ada:	8a 81       	ldd	r24, Y+2	; 0x02
     adc:	28 2f       	mov	r18, r24
     ade:	30 e0       	ldi	r19, 0x00	; 0
     ae0:	81 e0       	ldi	r24, 0x01	; 1
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	02 2e       	mov	r0, r18
     ae6:	02 c0       	rjmp	.+4      	; 0xaec <DIO_SetPinVal+0x138>
     ae8:	88 0f       	add	r24, r24
     aea:	99 1f       	adc	r25, r25
     aec:	0a 94       	dec	r0
     aee:	e2 f7       	brpl	.-8      	; 0xae8 <DIO_SetPinVal+0x134>
     af0:	84 2b       	or	r24, r20
     af2:	8c 93       	st	X, r24
     af4:	9c 91       	ld	r25, X
     af6:	42 c0       	rjmp	.+132    	; 0xb7c <DIO_SetPinVal+0x1c8>
     af8:	a5 e3       	ldi	r26, 0x35	; 53
     afa:	b0 e0       	ldi	r27, 0x00	; 0
     afc:	e5 e3       	ldi	r30, 0x35	; 53
     afe:	f0 e0       	ldi	r31, 0x00	; 0
     b00:	80 81       	ld	r24, Z
     b02:	48 2f       	mov	r20, r24
     b04:	8a 81       	ldd	r24, Y+2	; 0x02
     b06:	28 2f       	mov	r18, r24
     b08:	30 e0       	ldi	r19, 0x00	; 0
     b0a:	81 e0       	ldi	r24, 0x01	; 1
     b0c:	90 e0       	ldi	r25, 0x00	; 0
     b0e:	02 c0       	rjmp	.+4      	; 0xb14 <DIO_SetPinVal+0x160>
     b10:	88 0f       	add	r24, r24
     b12:	99 1f       	adc	r25, r25
     b14:	2a 95       	dec	r18
     b16:	e2 f7       	brpl	.-8      	; 0xb10 <DIO_SetPinVal+0x15c>
     b18:	80 95       	com	r24
     b1a:	84 23       	and	r24, r20
     b1c:	8c 93       	st	X, r24
     b1e:	2c 91       	ld	r18, X
     b20:	2d c0       	rjmp	.+90     	; 0xb7c <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTD:
		(val == HIGH)? (SET_BIT(PORTD,pin)):(CLR_BIT(PORTD,pin));
     b22:	8b 81       	ldd	r24, Y+3	; 0x03
     b24:	81 30       	cpi	r24, 0x01	; 1
     b26:	a9 f4       	brne	.+42     	; 0xb52 <DIO_SetPinVal+0x19e>
     b28:	a2 e3       	ldi	r26, 0x32	; 50
     b2a:	b0 e0       	ldi	r27, 0x00	; 0
     b2c:	e2 e3       	ldi	r30, 0x32	; 50
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	80 81       	ld	r24, Z
     b32:	48 2f       	mov	r20, r24
     b34:	8a 81       	ldd	r24, Y+2	; 0x02
     b36:	28 2f       	mov	r18, r24
     b38:	30 e0       	ldi	r19, 0x00	; 0
     b3a:	81 e0       	ldi	r24, 0x01	; 1
     b3c:	90 e0       	ldi	r25, 0x00	; 0
     b3e:	02 2e       	mov	r0, r18
     b40:	02 c0       	rjmp	.+4      	; 0xb46 <DIO_SetPinVal+0x192>
     b42:	88 0f       	add	r24, r24
     b44:	99 1f       	adc	r25, r25
     b46:	0a 94       	dec	r0
     b48:	e2 f7       	brpl	.-8      	; 0xb42 <DIO_SetPinVal+0x18e>
     b4a:	84 2b       	or	r24, r20
     b4c:	8c 93       	st	X, r24
     b4e:	3c 91       	ld	r19, X
     b50:	15 c0       	rjmp	.+42     	; 0xb7c <DIO_SetPinVal+0x1c8>
     b52:	a2 e3       	ldi	r26, 0x32	; 50
     b54:	b0 e0       	ldi	r27, 0x00	; 0
     b56:	e2 e3       	ldi	r30, 0x32	; 50
     b58:	f0 e0       	ldi	r31, 0x00	; 0
     b5a:	80 81       	ld	r24, Z
     b5c:	48 2f       	mov	r20, r24
     b5e:	8a 81       	ldd	r24, Y+2	; 0x02
     b60:	28 2f       	mov	r18, r24
     b62:	30 e0       	ldi	r19, 0x00	; 0
     b64:	81 e0       	ldi	r24, 0x01	; 1
     b66:	90 e0       	ldi	r25, 0x00	; 0
     b68:	02 2e       	mov	r0, r18
     b6a:	02 c0       	rjmp	.+4      	; 0xb70 <DIO_SetPinVal+0x1bc>
     b6c:	88 0f       	add	r24, r24
     b6e:	99 1f       	adc	r25, r25
     b70:	0a 94       	dec	r0
     b72:	e2 f7       	brpl	.-8      	; 0xb6c <DIO_SetPinVal+0x1b8>
     b74:	80 95       	com	r24
     b76:	84 23       	and	r24, r20
     b78:	8c 93       	st	X, r24
     b7a:	8c 91       	ld	r24, X
		break;
	}
}
     b7c:	2d 96       	adiw	r28, 0x0d	; 13
     b7e:	0f b6       	in	r0, 0x3f	; 63
     b80:	f8 94       	cli
     b82:	de bf       	out	0x3e, r29	; 62
     b84:	0f be       	out	0x3f, r0	; 63
     b86:	cd bf       	out	0x3d, r28	; 61
     b88:	cf 91       	pop	r28
     b8a:	df 91       	pop	r29
     b8c:	08 95       	ret

00000b8e <DIO_GetPinVal>:


uint8_t  DIO_GetPinVal(uint8_t port ,uint8_t pin)
{
     b8e:	df 93       	push	r29
     b90:	cf 93       	push	r28
     b92:	00 d0       	rcall	.+0      	; 0xb94 <DIO_GetPinVal+0x6>
     b94:	00 d0       	rcall	.+0      	; 0xb96 <DIO_GetPinVal+0x8>
     b96:	00 d0       	rcall	.+0      	; 0xb98 <DIO_GetPinVal+0xa>
     b98:	cd b7       	in	r28, 0x3d	; 61
     b9a:	de b7       	in	r29, 0x3e	; 62
     b9c:	89 83       	std	Y+1, r24	; 0x01
     b9e:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	28 2f       	mov	r18, r24
     ba4:	30 e0       	ldi	r19, 0x00	; 0
     ba6:	3d 83       	std	Y+5, r19	; 0x05
     ba8:	2c 83       	std	Y+4, r18	; 0x04
     baa:	4c 81       	ldd	r20, Y+4	; 0x04
     bac:	5d 81       	ldd	r21, Y+5	; 0x05
     bae:	41 30       	cpi	r20, 0x01	; 1
     bb0:	51 05       	cpc	r21, r1
     bb2:	49 f1       	breq	.+82     	; 0xc06 <DIO_GetPinVal+0x78>
     bb4:	8c 81       	ldd	r24, Y+4	; 0x04
     bb6:	9d 81       	ldd	r25, Y+5	; 0x05
     bb8:	82 30       	cpi	r24, 0x02	; 2
     bba:	91 05       	cpc	r25, r1
     bbc:	34 f4       	brge	.+12     	; 0xbca <DIO_GetPinVal+0x3c>
     bbe:	2c 81       	ldd	r18, Y+4	; 0x04
     bc0:	3d 81       	ldd	r19, Y+5	; 0x05
     bc2:	21 15       	cp	r18, r1
     bc4:	31 05       	cpc	r19, r1
     bc6:	61 f0       	breq	.+24     	; 0xbe0 <DIO_GetPinVal+0x52>
     bc8:	57 c0       	rjmp	.+174    	; 0xc78 <DIO_GetPinVal+0xea>
     bca:	4c 81       	ldd	r20, Y+4	; 0x04
     bcc:	5d 81       	ldd	r21, Y+5	; 0x05
     bce:	42 30       	cpi	r20, 0x02	; 2
     bd0:	51 05       	cpc	r21, r1
     bd2:	61 f1       	breq	.+88     	; 0xc2c <DIO_GetPinVal+0x9e>
     bd4:	8c 81       	ldd	r24, Y+4	; 0x04
     bd6:	9d 81       	ldd	r25, Y+5	; 0x05
     bd8:	83 30       	cpi	r24, 0x03	; 3
     bda:	91 05       	cpc	r25, r1
     bdc:	d1 f1       	breq	.+116    	; 0xc52 <DIO_GetPinVal+0xc4>
     bde:	4c c0       	rjmp	.+152    	; 0xc78 <DIO_GetPinVal+0xea>
	{
		case  DIO_PORTA :
			return GET_BIT(PINA,pin);
     be0:	e9 e3       	ldi	r30, 0x39	; 57
     be2:	f0 e0       	ldi	r31, 0x00	; 0
     be4:	80 81       	ld	r24, Z
     be6:	28 2f       	mov	r18, r24
     be8:	30 e0       	ldi	r19, 0x00	; 0
     bea:	8a 81       	ldd	r24, Y+2	; 0x02
     bec:	88 2f       	mov	r24, r24
     bee:	90 e0       	ldi	r25, 0x00	; 0
     bf0:	a9 01       	movw	r20, r18
     bf2:	02 c0       	rjmp	.+4      	; 0xbf8 <DIO_GetPinVal+0x6a>
     bf4:	55 95       	asr	r21
     bf6:	47 95       	ror	r20
     bf8:	8a 95       	dec	r24
     bfa:	e2 f7       	brpl	.-8      	; 0xbf4 <DIO_GetPinVal+0x66>
     bfc:	ca 01       	movw	r24, r20
     bfe:	58 2f       	mov	r21, r24
     c00:	51 70       	andi	r21, 0x01	; 1
     c02:	5b 83       	std	Y+3, r21	; 0x03
     c04:	3a c0       	rjmp	.+116    	; 0xc7a <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTB :
			return GET_BIT(PINB,pin);
     c06:	e6 e3       	ldi	r30, 0x36	; 54
     c08:	f0 e0       	ldi	r31, 0x00	; 0
     c0a:	80 81       	ld	r24, Z
     c0c:	28 2f       	mov	r18, r24
     c0e:	30 e0       	ldi	r19, 0x00	; 0
     c10:	8a 81       	ldd	r24, Y+2	; 0x02
     c12:	88 2f       	mov	r24, r24
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	a9 01       	movw	r20, r18
     c18:	02 c0       	rjmp	.+4      	; 0xc1e <DIO_GetPinVal+0x90>
     c1a:	55 95       	asr	r21
     c1c:	47 95       	ror	r20
     c1e:	8a 95       	dec	r24
     c20:	e2 f7       	brpl	.-8      	; 0xc1a <DIO_GetPinVal+0x8c>
     c22:	ca 01       	movw	r24, r20
     c24:	58 2f       	mov	r21, r24
     c26:	51 70       	andi	r21, 0x01	; 1
     c28:	5b 83       	std	Y+3, r21	; 0x03
     c2a:	27 c0       	rjmp	.+78     	; 0xc7a <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTC :
			return GET_BIT(PINC,pin);
     c2c:	e3 e3       	ldi	r30, 0x33	; 51
     c2e:	f0 e0       	ldi	r31, 0x00	; 0
     c30:	80 81       	ld	r24, Z
     c32:	28 2f       	mov	r18, r24
     c34:	30 e0       	ldi	r19, 0x00	; 0
     c36:	8a 81       	ldd	r24, Y+2	; 0x02
     c38:	88 2f       	mov	r24, r24
     c3a:	90 e0       	ldi	r25, 0x00	; 0
     c3c:	a9 01       	movw	r20, r18
     c3e:	02 c0       	rjmp	.+4      	; 0xc44 <DIO_GetPinVal+0xb6>
     c40:	55 95       	asr	r21
     c42:	47 95       	ror	r20
     c44:	8a 95       	dec	r24
     c46:	e2 f7       	brpl	.-8      	; 0xc40 <DIO_GetPinVal+0xb2>
     c48:	ca 01       	movw	r24, r20
     c4a:	58 2f       	mov	r21, r24
     c4c:	51 70       	andi	r21, 0x01	; 1
     c4e:	5b 83       	std	Y+3, r21	; 0x03
     c50:	14 c0       	rjmp	.+40     	; 0xc7a <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTD :
			return GET_BIT(PIND,pin);
     c52:	e0 e3       	ldi	r30, 0x30	; 48
     c54:	f0 e0       	ldi	r31, 0x00	; 0
     c56:	80 81       	ld	r24, Z
     c58:	28 2f       	mov	r18, r24
     c5a:	30 e0       	ldi	r19, 0x00	; 0
     c5c:	8a 81       	ldd	r24, Y+2	; 0x02
     c5e:	88 2f       	mov	r24, r24
     c60:	90 e0       	ldi	r25, 0x00	; 0
     c62:	a9 01       	movw	r20, r18
     c64:	02 c0       	rjmp	.+4      	; 0xc6a <DIO_GetPinVal+0xdc>
     c66:	55 95       	asr	r21
     c68:	47 95       	ror	r20
     c6a:	8a 95       	dec	r24
     c6c:	e2 f7       	brpl	.-8      	; 0xc66 <DIO_GetPinVal+0xd8>
     c6e:	ca 01       	movw	r24, r20
     c70:	58 2f       	mov	r21, r24
     c72:	51 70       	andi	r21, 0x01	; 1
     c74:	5b 83       	std	Y+3, r21	; 0x03
     c76:	01 c0       	rjmp	.+2      	; 0xc7a <DIO_GetPinVal+0xec>
     c78:	02 c0       	rjmp	.+4      	; 0xc7e <DIO_GetPinVal+0xf0>
			break;
	}
}
     c7a:	8b 81       	ldd	r24, Y+3	; 0x03
     c7c:	8e 83       	std	Y+6, r24	; 0x06
     c7e:	8e 81       	ldd	r24, Y+6	; 0x06
     c80:	26 96       	adiw	r28, 0x06	; 6
     c82:	0f b6       	in	r0, 0x3f	; 63
     c84:	f8 94       	cli
     c86:	de bf       	out	0x3e, r29	; 62
     c88:	0f be       	out	0x3f, r0	; 63
     c8a:	cd bf       	out	0x3d, r28	; 61
     c8c:	cf 91       	pop	r28
     c8e:	df 91       	pop	r29
     c90:	08 95       	ret

00000c92 <DIO_TogPinVal>:


void  DIO_TogPinVal(uint8_t port ,uint8_t pin)
{
     c92:	df 93       	push	r29
     c94:	cf 93       	push	r28
     c96:	00 d0       	rcall	.+0      	; 0xc98 <DIO_TogPinVal+0x6>
     c98:	00 d0       	rcall	.+0      	; 0xc9a <DIO_TogPinVal+0x8>
     c9a:	cd b7       	in	r28, 0x3d	; 61
     c9c:	de b7       	in	r29, 0x3e	; 62
     c9e:	89 83       	std	Y+1, r24	; 0x01
     ca0:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     ca2:	89 81       	ldd	r24, Y+1	; 0x01
     ca4:	28 2f       	mov	r18, r24
     ca6:	30 e0       	ldi	r19, 0x00	; 0
     ca8:	3c 83       	std	Y+4, r19	; 0x04
     caa:	2b 83       	std	Y+3, r18	; 0x03
     cac:	8b 81       	ldd	r24, Y+3	; 0x03
     cae:	9c 81       	ldd	r25, Y+4	; 0x04
     cb0:	81 30       	cpi	r24, 0x01	; 1
     cb2:	91 05       	cpc	r25, r1
     cb4:	49 f1       	breq	.+82     	; 0xd08 <DIO_TogPinVal+0x76>
     cb6:	2b 81       	ldd	r18, Y+3	; 0x03
     cb8:	3c 81       	ldd	r19, Y+4	; 0x04
     cba:	22 30       	cpi	r18, 0x02	; 2
     cbc:	31 05       	cpc	r19, r1
     cbe:	2c f4       	brge	.+10     	; 0xcca <DIO_TogPinVal+0x38>
     cc0:	8b 81       	ldd	r24, Y+3	; 0x03
     cc2:	9c 81       	ldd	r25, Y+4	; 0x04
     cc4:	00 97       	sbiw	r24, 0x00	; 0
     cc6:	61 f0       	breq	.+24     	; 0xce0 <DIO_TogPinVal+0x4e>
     cc8:	5a c0       	rjmp	.+180    	; 0xd7e <DIO_TogPinVal+0xec>
     cca:	2b 81       	ldd	r18, Y+3	; 0x03
     ccc:	3c 81       	ldd	r19, Y+4	; 0x04
     cce:	22 30       	cpi	r18, 0x02	; 2
     cd0:	31 05       	cpc	r19, r1
     cd2:	71 f1       	breq	.+92     	; 0xd30 <DIO_TogPinVal+0x9e>
     cd4:	8b 81       	ldd	r24, Y+3	; 0x03
     cd6:	9c 81       	ldd	r25, Y+4	; 0x04
     cd8:	83 30       	cpi	r24, 0x03	; 3
     cda:	91 05       	cpc	r25, r1
     cdc:	e9 f1       	breq	.+122    	; 0xd58 <DIO_TogPinVal+0xc6>
     cde:	4f c0       	rjmp	.+158    	; 0xd7e <DIO_TogPinVal+0xec>
	{
		case  DIO_PORTA :	TOG_BIT(PORTA,pin);
     ce0:	ab e3       	ldi	r26, 0x3B	; 59
     ce2:	b0 e0       	ldi	r27, 0x00	; 0
     ce4:	eb e3       	ldi	r30, 0x3B	; 59
     ce6:	f0 e0       	ldi	r31, 0x00	; 0
     ce8:	80 81       	ld	r24, Z
     cea:	48 2f       	mov	r20, r24
     cec:	8a 81       	ldd	r24, Y+2	; 0x02
     cee:	28 2f       	mov	r18, r24
     cf0:	30 e0       	ldi	r19, 0x00	; 0
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	90 e0       	ldi	r25, 0x00	; 0
     cf6:	02 2e       	mov	r0, r18
     cf8:	02 c0       	rjmp	.+4      	; 0xcfe <DIO_TogPinVal+0x6c>
     cfa:	88 0f       	add	r24, r24
     cfc:	99 1f       	adc	r25, r25
     cfe:	0a 94       	dec	r0
     d00:	e2 f7       	brpl	.-8      	; 0xcfa <DIO_TogPinVal+0x68>
     d02:	84 27       	eor	r24, r20
     d04:	8c 93       	st	X, r24
     d06:	3b c0       	rjmp	.+118    	; 0xd7e <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTB :   TOG_BIT(PORTB,pin);
     d08:	a8 e3       	ldi	r26, 0x38	; 56
     d0a:	b0 e0       	ldi	r27, 0x00	; 0
     d0c:	e8 e3       	ldi	r30, 0x38	; 56
     d0e:	f0 e0       	ldi	r31, 0x00	; 0
     d10:	80 81       	ld	r24, Z
     d12:	48 2f       	mov	r20, r24
     d14:	8a 81       	ldd	r24, Y+2	; 0x02
     d16:	28 2f       	mov	r18, r24
     d18:	30 e0       	ldi	r19, 0x00	; 0
     d1a:	81 e0       	ldi	r24, 0x01	; 1
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	02 2e       	mov	r0, r18
     d20:	02 c0       	rjmp	.+4      	; 0xd26 <DIO_TogPinVal+0x94>
     d22:	88 0f       	add	r24, r24
     d24:	99 1f       	adc	r25, r25
     d26:	0a 94       	dec	r0
     d28:	e2 f7       	brpl	.-8      	; 0xd22 <DIO_TogPinVal+0x90>
     d2a:	84 27       	eor	r24, r20
     d2c:	8c 93       	st	X, r24
     d2e:	27 c0       	rjmp	.+78     	; 0xd7e <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTC :   TOG_BIT(PORTC,pin);
     d30:	a5 e3       	ldi	r26, 0x35	; 53
     d32:	b0 e0       	ldi	r27, 0x00	; 0
     d34:	e5 e3       	ldi	r30, 0x35	; 53
     d36:	f0 e0       	ldi	r31, 0x00	; 0
     d38:	80 81       	ld	r24, Z
     d3a:	48 2f       	mov	r20, r24
     d3c:	8a 81       	ldd	r24, Y+2	; 0x02
     d3e:	28 2f       	mov	r18, r24
     d40:	30 e0       	ldi	r19, 0x00	; 0
     d42:	81 e0       	ldi	r24, 0x01	; 1
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	02 2e       	mov	r0, r18
     d48:	02 c0       	rjmp	.+4      	; 0xd4e <DIO_TogPinVal+0xbc>
     d4a:	88 0f       	add	r24, r24
     d4c:	99 1f       	adc	r25, r25
     d4e:	0a 94       	dec	r0
     d50:	e2 f7       	brpl	.-8      	; 0xd4a <DIO_TogPinVal+0xb8>
     d52:	84 27       	eor	r24, r20
     d54:	8c 93       	st	X, r24
     d56:	13 c0       	rjmp	.+38     	; 0xd7e <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTD :   TOG_BIT(PORTD,pin);
     d58:	a2 e3       	ldi	r26, 0x32	; 50
     d5a:	b0 e0       	ldi	r27, 0x00	; 0
     d5c:	e2 e3       	ldi	r30, 0x32	; 50
     d5e:	f0 e0       	ldi	r31, 0x00	; 0
     d60:	80 81       	ld	r24, Z
     d62:	48 2f       	mov	r20, r24
     d64:	8a 81       	ldd	r24, Y+2	; 0x02
     d66:	28 2f       	mov	r18, r24
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	81 e0       	ldi	r24, 0x01	; 1
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	02 2e       	mov	r0, r18
     d70:	02 c0       	rjmp	.+4      	; 0xd76 <DIO_TogPinVal+0xe4>
     d72:	88 0f       	add	r24, r24
     d74:	99 1f       	adc	r25, r25
     d76:	0a 94       	dec	r0
     d78:	e2 f7       	brpl	.-8      	; 0xd72 <DIO_TogPinVal+0xe0>
     d7a:	84 27       	eor	r24, r20
     d7c:	8c 93       	st	X, r24
		break;
	}
}
     d7e:	0f 90       	pop	r0
     d80:	0f 90       	pop	r0
     d82:	0f 90       	pop	r0
     d84:	0f 90       	pop	r0
     d86:	cf 91       	pop	r28
     d88:	df 91       	pop	r29
     d8a:	08 95       	ret

00000d8c <Blink_Right>:
 */

#include"LED.h"
#include"PWM.h"

void Blink_Right(char led_mode ){
     d8c:	df 93       	push	r29
     d8e:	cf 93       	push	r28
     d90:	0f 92       	push	r0
     d92:	cd b7       	in	r28, 0x3d	; 61
     d94:	de b7       	in	r29, 0x3e	; 62
     d96:	89 83       	std	Y+1, r24	; 0x01
		if(led_mode){
     d98:	89 81       	ldd	r24, Y+1	; 0x01
     d9a:	88 23       	and	r24, r24
     d9c:	19 f0       	breq	.+6      	; 0xda4 <Blink_Right+0x18>
			Start_PWM1();
     d9e:	0e 94 0d 07 	call	0xe1a	; 0xe1a <Start_PWM1>
     da2:	02 c0       	rjmp	.+4      	; 0xda8 <Blink_Right+0x1c>
		}else{
			Stop_PWM1();
     da4:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <Stop_PWM1>
	}
}
     da8:	0f 90       	pop	r0
     daa:	cf 91       	pop	r28
     dac:	df 91       	pop	r29
     dae:	08 95       	ret

00000db0 <Blink_LEFT>:

void Blink_LEFT(char led_mode){
     db0:	df 93       	push	r29
     db2:	cf 93       	push	r28
     db4:	0f 92       	push	r0
     db6:	cd b7       	in	r28, 0x3d	; 61
     db8:	de b7       	in	r29, 0x3e	; 62
     dba:	89 83       	std	Y+1, r24	; 0x01
		if(led_mode){
     dbc:	89 81       	ldd	r24, Y+1	; 0x01
     dbe:	88 23       	and	r24, r24
     dc0:	19 f0       	breq	.+6      	; 0xdc8 <Blink_LEFT+0x18>
			Start_PWM2();
     dc2:	0e 94 34 07 	call	0xe68	; 0xe68 <Start_PWM2>
     dc6:	02 c0       	rjmp	.+4      	; 0xdcc <Blink_LEFT+0x1c>
		}else{
			Stop_PWM2();
     dc8:	0e 94 70 07 	call	0xee0	; 0xee0 <Stop_PWM2>
		}
}
     dcc:	0f 90       	pop	r0
     dce:	cf 91       	pop	r28
     dd0:	df 91       	pop	r29
     dd2:	08 95       	ret

00000dd4 <Stop_Blinking_Right>:
void Stop_Blinking_Right(void){
     dd4:	df 93       	push	r29
     dd6:	cf 93       	push	r28
     dd8:	cd b7       	in	r28, 0x3d	; 61
     dda:	de b7       	in	r29, 0x3e	; 62
	Stop_PWM1();
     ddc:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <Stop_PWM1>
}
     de0:	cf 91       	pop	r28
     de2:	df 91       	pop	r29
     de4:	08 95       	ret

00000de6 <Stop_Blinking_Left>:
void Stop_Blinking_Left(void){
     de6:	df 93       	push	r29
     de8:	cf 93       	push	r28
     dea:	cd b7       	in	r28, 0x3d	; 61
     dec:	de b7       	in	r29, 0x3e	; 62
	Stop_PWM2();
     dee:	0e 94 70 07 	call	0xee0	; 0xee0 <Stop_PWM2>
}
     df2:	cf 91       	pop	r28
     df4:	df 91       	pop	r29
     df6:	08 95       	ret

00000df8 <PWM_INIT>:
 *      Author: wario
 */

#include"PWM.h"

void PWM_INIT(void){
     df8:	df 93       	push	r29
     dfa:	cf 93       	push	r28
     dfc:	cd b7       	in	r28, 0x3d	; 61
     dfe:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir((uint8_t)DIO_PORTB ,(uint8_t)Pin3, (uint8_t)OUTPUT);
     e00:	81 e0       	ldi	r24, 0x01	; 1
     e02:	63 e0       	ldi	r22, 0x03	; 3
     e04:	43 e0       	ldi	r20, 0x03	; 3
     e06:	0e 94 ed 03 	call	0x7da	; 0x7da <DIO_SetPinDir>
	DIO_SetPinDir((uint8_t)DIO_PORTD ,(uint8_t)Pin7,(uint8_t) OUTPUT);
     e0a:	83 e0       	ldi	r24, 0x03	; 3
     e0c:	67 e0       	ldi	r22, 0x07	; 7
     e0e:	43 e0       	ldi	r20, 0x03	; 3
     e10:	0e 94 ed 03 	call	0x7da	; 0x7da <DIO_SetPinDir>
}
     e14:	cf 91       	pop	r28
     e16:	df 91       	pop	r29
     e18:	08 95       	ret

00000e1a <Start_PWM1>:
void Start_PWM1(void){
     e1a:	df 93       	push	r29
     e1c:	cf 93       	push	r28
     e1e:	cd b7       	in	r28, 0x3d	; 61
     e20:	de b7       	in	r29, 0x3e	; 62
	TCCR0 |=  (unsigned char)(1u<<WGM00);
     e22:	a3 e5       	ldi	r26, 0x53	; 83
     e24:	b0 e0       	ldi	r27, 0x00	; 0
     e26:	e3 e5       	ldi	r30, 0x53	; 83
     e28:	f0 e0       	ldi	r31, 0x00	; 0
     e2a:	80 81       	ld	r24, Z
     e2c:	80 64       	ori	r24, 0x40	; 64
     e2e:	8c 93       	st	X, r24
	TCCR0 |= (unsigned char) (1u<<WGM01);
     e30:	a3 e5       	ldi	r26, 0x53	; 83
     e32:	b0 e0       	ldi	r27, 0x00	; 0
     e34:	e3 e5       	ldi	r30, 0x53	; 83
     e36:	f0 e0       	ldi	r31, 0x00	; 0
     e38:	80 81       	ld	r24, Z
     e3a:	88 60       	ori	r24, 0x08	; 8
     e3c:	8c 93       	st	X, r24
	TCCR0 |= (unsigned char) (1u<<COM01);
     e3e:	a3 e5       	ldi	r26, 0x53	; 83
     e40:	b0 e0       	ldi	r27, 0x00	; 0
     e42:	e3 e5       	ldi	r30, 0x53	; 83
     e44:	f0 e0       	ldi	r31, 0x00	; 0
     e46:	80 81       	ld	r24, Z
     e48:	80 62       	ori	r24, 0x20	; 32
     e4a:	8c 93       	st	X, r24
	TCCR0 |= (unsigned char) (1u<<CS00);
     e4c:	a3 e5       	ldi	r26, 0x53	; 83
     e4e:	b0 e0       	ldi	r27, 0x00	; 0
     e50:	e3 e5       	ldi	r30, 0x53	; 83
     e52:	f0 e0       	ldi	r31, 0x00	; 0
     e54:	80 81       	ld	r24, Z
     e56:	81 60       	ori	r24, 0x01	; 1
     e58:	8c 93       	st	X, r24

	OCR0 = (unsigned char)204;
     e5a:	ec e5       	ldi	r30, 0x5C	; 92
     e5c:	f0 e0       	ldi	r31, 0x00	; 0
     e5e:	8c ec       	ldi	r24, 0xCC	; 204
     e60:	80 83       	st	Z, r24
}
     e62:	cf 91       	pop	r28
     e64:	df 91       	pop	r29
     e66:	08 95       	ret

00000e68 <Start_PWM2>:
void Start_PWM2(void){
     e68:	df 93       	push	r29
     e6a:	cf 93       	push	r28
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62
    TCCR2 |= (unsigned char)(1u<<WGM20);
     e70:	a5 e4       	ldi	r26, 0x45	; 69
     e72:	b0 e0       	ldi	r27, 0x00	; 0
     e74:	e5 e4       	ldi	r30, 0x45	; 69
     e76:	f0 e0       	ldi	r31, 0x00	; 0
     e78:	80 81       	ld	r24, Z
     e7a:	80 64       	ori	r24, 0x40	; 64
     e7c:	8c 93       	st	X, r24
    TCCR2 |= (unsigned char) (1u<<WGM21);
     e7e:	a5 e4       	ldi	r26, 0x45	; 69
     e80:	b0 e0       	ldi	r27, 0x00	; 0
     e82:	e5 e4       	ldi	r30, 0x45	; 69
     e84:	f0 e0       	ldi	r31, 0x00	; 0
     e86:	80 81       	ld	r24, Z
     e88:	88 60       	ori	r24, 0x08	; 8
     e8a:	8c 93       	st	X, r24
    TCCR2 |= (unsigned char)(1u<<COM21);
     e8c:	a5 e4       	ldi	r26, 0x45	; 69
     e8e:	b0 e0       	ldi	r27, 0x00	; 0
     e90:	e5 e4       	ldi	r30, 0x45	; 69
     e92:	f0 e0       	ldi	r31, 0x00	; 0
     e94:	80 81       	ld	r24, Z
     e96:	80 62       	ori	r24, 0x20	; 32
     e98:	8c 93       	st	X, r24
    TCCR2 |= (unsigned char) (1u<<CS20);
     e9a:	a5 e4       	ldi	r26, 0x45	; 69
     e9c:	b0 e0       	ldi	r27, 0x00	; 0
     e9e:	e5 e4       	ldi	r30, 0x45	; 69
     ea0:	f0 e0       	ldi	r31, 0x00	; 0
     ea2:	80 81       	ld	r24, Z
     ea4:	81 60       	ori	r24, 0x01	; 1
     ea6:	8c 93       	st	X, r24

	OCR2 = (unsigned char)204;
     ea8:	e3 e4       	ldi	r30, 0x43	; 67
     eaa:	f0 e0       	ldi	r31, 0x00	; 0
     eac:	8c ec       	ldi	r24, 0xCC	; 204
     eae:	80 83       	st	Z, r24
}
     eb0:	cf 91       	pop	r28
     eb2:	df 91       	pop	r29
     eb4:	08 95       	ret

00000eb6 <Stop_PWM1>:
void Stop_PWM1(void){
     eb6:	df 93       	push	r29
     eb8:	cf 93       	push	r28
     eba:	cd b7       	in	r28, 0x3d	; 61
     ebc:	de b7       	in	r29, 0x3e	; 62
	TCCR0 &=(unsigned char)(~(unsigned char) (1u<<COM01));
     ebe:	a3 e5       	ldi	r26, 0x53	; 83
     ec0:	b0 e0       	ldi	r27, 0x00	; 0
     ec2:	e3 e5       	ldi	r30, 0x53	; 83
     ec4:	f0 e0       	ldi	r31, 0x00	; 0
     ec6:	80 81       	ld	r24, Z
     ec8:	8f 7d       	andi	r24, 0xDF	; 223
     eca:	8c 93       	st	X, r24
	TCCR0 &=(unsigned char)(~(unsigned char) (1u<<CS00));
     ecc:	a3 e5       	ldi	r26, 0x53	; 83
     ece:	b0 e0       	ldi	r27, 0x00	; 0
     ed0:	e3 e5       	ldi	r30, 0x53	; 83
     ed2:	f0 e0       	ldi	r31, 0x00	; 0
     ed4:	80 81       	ld	r24, Z
     ed6:	8e 7f       	andi	r24, 0xFE	; 254
     ed8:	8c 93       	st	X, r24
}
     eda:	cf 91       	pop	r28
     edc:	df 91       	pop	r29
     ede:	08 95       	ret

00000ee0 <Stop_PWM2>:
void Stop_PWM2(void){
     ee0:	df 93       	push	r29
     ee2:	cf 93       	push	r28
     ee4:	cd b7       	in	r28, 0x3d	; 61
     ee6:	de b7       	in	r29, 0x3e	; 62
	TCCR2 &=(unsigned char)(~(unsigned char) (1u<<COM21));
     ee8:	a5 e4       	ldi	r26, 0x45	; 69
     eea:	b0 e0       	ldi	r27, 0x00	; 0
     eec:	e5 e4       	ldi	r30, 0x45	; 69
     eee:	f0 e0       	ldi	r31, 0x00	; 0
     ef0:	80 81       	ld	r24, Z
     ef2:	8f 7d       	andi	r24, 0xDF	; 223
     ef4:	8c 93       	st	X, r24
	TCCR2 &=(unsigned char)(~(unsigned char)(1u<<CS20));
     ef6:	a5 e4       	ldi	r26, 0x45	; 69
     ef8:	b0 e0       	ldi	r27, 0x00	; 0
     efa:	e5 e4       	ldi	r30, 0x45	; 69
     efc:	f0 e0       	ldi	r31, 0x00	; 0
     efe:	80 81       	ld	r24, Z
     f00:	8e 7f       	andi	r24, 0xFE	; 254
     f02:	8c 93       	st	X, r24
}
     f04:	cf 91       	pop	r28
     f06:	df 91       	pop	r29
     f08:	08 95       	ret

00000f0a <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
     f0a:	df 93       	push	r29
     f0c:	cf 93       	push	r28
     f0e:	cd b7       	in	r28, 0x3d	; 61
     f10:	de b7       	in	r29, 0x3e	; 62
     f12:	27 97       	sbiw	r28, 0x07	; 7
     f14:	0f b6       	in	r0, 0x3f	; 63
     f16:	f8 94       	cli
     f18:	de bf       	out	0x3e, r29	; 62
     f1a:	0f be       	out	0x3f, r0	; 63
     f1c:	cd bf       	out	0x3d, r28	; 61
     f1e:	9d 83       	std	Y+5, r25	; 0x05
     f20:	8c 83       	std	Y+4, r24	; 0x04
     f22:	6e 83       	std	Y+6, r22	; 0x06
     f24:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     f26:	8a e1       	ldi	r24, 0x1A	; 26
     f28:	90 e0       	ldi	r25, 0x00	; 0
     f2a:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     f2e:	9a 83       	std	Y+2, r25	; 0x02
     f30:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
     f32:	89 81       	ldd	r24, Y+1	; 0x01
     f34:	9a 81       	ldd	r25, Y+2	; 0x02
     f36:	00 97       	sbiw	r24, 0x00	; 0
     f38:	09 f4       	brne	.+2      	; 0xf3c <xCoRoutineCreate+0x32>
     f3a:	6f c0       	rjmp	.+222    	; 0x101a <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
     f3c:	80 91 70 06 	lds	r24, 0x0670
     f40:	90 91 71 06 	lds	r25, 0x0671
     f44:	00 97       	sbiw	r24, 0x00	; 0
     f46:	41 f4       	brne	.+16     	; 0xf58 <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
     f48:	89 81       	ldd	r24, Y+1	; 0x01
     f4a:	9a 81       	ldd	r25, Y+2	; 0x02
     f4c:	90 93 71 06 	sts	0x0671, r25
     f50:	80 93 70 06 	sts	0x0670, r24
                prvInitialiseCoRoutineLists();
     f54:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     f58:	8e 81       	ldd	r24, Y+6	; 0x06
     f5a:	82 30       	cpi	r24, 0x02	; 2
     f5c:	10 f0       	brcs	.+4      	; 0xf62 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     f5e:	81 e0       	ldi	r24, 0x01	; 1
     f60:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
     f62:	e9 81       	ldd	r30, Y+1	; 0x01
     f64:	fa 81       	ldd	r31, Y+2	; 0x02
     f66:	11 8e       	std	Z+25, r1	; 0x19
     f68:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
     f6a:	e9 81       	ldd	r30, Y+1	; 0x01
     f6c:	fa 81       	ldd	r31, Y+2	; 0x02
     f6e:	8e 81       	ldd	r24, Y+6	; 0x06
     f70:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
     f72:	e9 81       	ldd	r30, Y+1	; 0x01
     f74:	fa 81       	ldd	r31, Y+2	; 0x02
     f76:	8f 81       	ldd	r24, Y+7	; 0x07
     f78:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     f7a:	e9 81       	ldd	r30, Y+1	; 0x01
     f7c:	fa 81       	ldd	r31, Y+2	; 0x02
     f7e:	8c 81       	ldd	r24, Y+4	; 0x04
     f80:	9d 81       	ldd	r25, Y+5	; 0x05
     f82:	91 83       	std	Z+1, r25	; 0x01
     f84:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     f86:	89 81       	ldd	r24, Y+1	; 0x01
     f88:	9a 81       	ldd	r25, Y+2	; 0x02
     f8a:	02 96       	adiw	r24, 0x02	; 2
     f8c:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     f90:	89 81       	ldd	r24, Y+1	; 0x01
     f92:	9a 81       	ldd	r25, Y+2	; 0x02
     f94:	0c 96       	adiw	r24, 0x0c	; 12
     f96:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     f9a:	e9 81       	ldd	r30, Y+1	; 0x01
     f9c:	fa 81       	ldd	r31, Y+2	; 0x02
     f9e:	89 81       	ldd	r24, Y+1	; 0x01
     fa0:	9a 81       	ldd	r25, Y+2	; 0x02
     fa2:	91 87       	std	Z+9, r25	; 0x09
     fa4:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     fa6:	e9 81       	ldd	r30, Y+1	; 0x01
     fa8:	fa 81       	ldd	r31, Y+2	; 0x02
     faa:	89 81       	ldd	r24, Y+1	; 0x01
     fac:	9a 81       	ldd	r25, Y+2	; 0x02
     fae:	93 8b       	std	Z+19, r25	; 0x13
     fb0:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     fb2:	8e 81       	ldd	r24, Y+6	; 0x06
     fb4:	28 2f       	mov	r18, r24
     fb6:	30 e0       	ldi	r19, 0x00	; 0
     fb8:	82 e0       	ldi	r24, 0x02	; 2
     fba:	90 e0       	ldi	r25, 0x00	; 0
     fbc:	82 1b       	sub	r24, r18
     fbe:	93 0b       	sbc	r25, r19
     fc0:	e9 81       	ldd	r30, Y+1	; 0x01
     fc2:	fa 81       	ldd	r31, Y+2	; 0x02
     fc4:	95 87       	std	Z+13, r25	; 0x0d
     fc6:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
     fc8:	e9 81       	ldd	r30, Y+1	; 0x01
     fca:	fa 81       	ldd	r31, Y+2	; 0x02
     fcc:	96 89       	ldd	r25, Z+22	; 0x16
     fce:	80 91 72 06 	lds	r24, 0x0672
     fd2:	89 17       	cp	r24, r25
     fd4:	28 f4       	brcc	.+10     	; 0xfe0 <xCoRoutineCreate+0xd6>
     fd6:	e9 81       	ldd	r30, Y+1	; 0x01
     fd8:	fa 81       	ldd	r31, Y+2	; 0x02
     fda:	86 89       	ldd	r24, Z+22	; 0x16
     fdc:	80 93 72 06 	sts	0x0672, r24
     fe0:	e9 81       	ldd	r30, Y+1	; 0x01
     fe2:	fa 81       	ldd	r31, Y+2	; 0x02
     fe4:	86 89       	ldd	r24, Z+22	; 0x16
     fe6:	28 2f       	mov	r18, r24
     fe8:	30 e0       	ldi	r19, 0x00	; 0
     fea:	c9 01       	movw	r24, r18
     fec:	88 0f       	add	r24, r24
     fee:	99 1f       	adc	r25, r25
     ff0:	88 0f       	add	r24, r24
     ff2:	99 1f       	adc	r25, r25
     ff4:	88 0f       	add	r24, r24
     ff6:	99 1f       	adc	r25, r25
     ff8:	82 0f       	add	r24, r18
     ffa:	93 1f       	adc	r25, r19
     ffc:	ac 01       	movw	r20, r24
     ffe:	47 58       	subi	r20, 0x87	; 135
    1000:	59 4f       	sbci	r21, 0xF9	; 249
    1002:	89 81       	ldd	r24, Y+1	; 0x01
    1004:	9a 81       	ldd	r25, Y+2	; 0x02
    1006:	9c 01       	movw	r18, r24
    1008:	2e 5f       	subi	r18, 0xFE	; 254
    100a:	3f 4f       	sbci	r19, 0xFF	; 255
    100c:	ca 01       	movw	r24, r20
    100e:	b9 01       	movw	r22, r18
    1010:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <vListInsertEnd>

            xReturn = pdPASS;
    1014:	81 e0       	ldi	r24, 0x01	; 1
    1016:	8b 83       	std	Y+3, r24	; 0x03
    1018:	02 c0       	rjmp	.+4      	; 0x101e <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    101a:	8f ef       	ldi	r24, 0xFF	; 255
    101c:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    101e:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    1020:	27 96       	adiw	r28, 0x07	; 7
    1022:	0f b6       	in	r0, 0x3f	; 63
    1024:	f8 94       	cli
    1026:	de bf       	out	0x3e, r29	; 62
    1028:	0f be       	out	0x3f, r0	; 63
    102a:	cd bf       	out	0x3d, r28	; 61
    102c:	cf 91       	pop	r28
    102e:	df 91       	pop	r29
    1030:	08 95       	ret

00001032 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    1032:	df 93       	push	r29
    1034:	cf 93       	push	r28
    1036:	00 d0       	rcall	.+0      	; 0x1038 <vCoRoutineAddToDelayedList+0x6>
    1038:	00 d0       	rcall	.+0      	; 0x103a <vCoRoutineAddToDelayedList+0x8>
    103a:	00 d0       	rcall	.+0      	; 0x103c <vCoRoutineAddToDelayedList+0xa>
    103c:	cd b7       	in	r28, 0x3d	; 61
    103e:	de b7       	in	r29, 0x3e	; 62
    1040:	9c 83       	std	Y+4, r25	; 0x04
    1042:	8b 83       	std	Y+3, r24	; 0x03
    1044:	7e 83       	std	Y+6, r23	; 0x06
    1046:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1048:	20 91 73 06 	lds	r18, 0x0673
    104c:	30 91 74 06 	lds	r19, 0x0674
    1050:	8b 81       	ldd	r24, Y+3	; 0x03
    1052:	9c 81       	ldd	r25, Y+4	; 0x04
    1054:	82 0f       	add	r24, r18
    1056:	93 1f       	adc	r25, r19
    1058:	9a 83       	std	Y+2, r25	; 0x02
    105a:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    105c:	80 91 70 06 	lds	r24, 0x0670
    1060:	90 91 71 06 	lds	r25, 0x0671
    1064:	02 96       	adiw	r24, 0x02	; 2
    1066:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    106a:	e0 91 70 06 	lds	r30, 0x0670
    106e:	f0 91 71 06 	lds	r31, 0x0671
    1072:	89 81       	ldd	r24, Y+1	; 0x01
    1074:	9a 81       	ldd	r25, Y+2	; 0x02
    1076:	93 83       	std	Z+3, r25	; 0x03
    1078:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    107a:	20 91 73 06 	lds	r18, 0x0673
    107e:	30 91 74 06 	lds	r19, 0x0674
    1082:	89 81       	ldd	r24, Y+1	; 0x01
    1084:	9a 81       	ldd	r25, Y+2	; 0x02
    1086:	82 17       	cp	r24, r18
    1088:	93 07       	cpc	r25, r19
    108a:	70 f4       	brcc	.+28     	; 0x10a8 <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    108c:	80 91 6e 06 	lds	r24, 0x066E
    1090:	90 91 6f 06 	lds	r25, 0x066F
    1094:	20 91 70 06 	lds	r18, 0x0670
    1098:	30 91 71 06 	lds	r19, 0x0671
    109c:	2e 5f       	subi	r18, 0xFE	; 254
    109e:	3f 4f       	sbci	r19, 0xFF	; 255
    10a0:	b9 01       	movw	r22, r18
    10a2:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <vListInsert>
    10a6:	0d c0       	rjmp	.+26     	; 0x10c2 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    10a8:	80 91 6c 06 	lds	r24, 0x066C
    10ac:	90 91 6d 06 	lds	r25, 0x066D
    10b0:	20 91 70 06 	lds	r18, 0x0670
    10b4:	30 91 71 06 	lds	r19, 0x0671
    10b8:	2e 5f       	subi	r18, 0xFE	; 254
    10ba:	3f 4f       	sbci	r19, 0xFF	; 255
    10bc:	b9 01       	movw	r22, r18
    10be:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <vListInsert>
        }

        if( pxEventList )
    10c2:	8d 81       	ldd	r24, Y+5	; 0x05
    10c4:	9e 81       	ldd	r25, Y+6	; 0x06
    10c6:	00 97       	sbiw	r24, 0x00	; 0
    10c8:	61 f0       	breq	.+24     	; 0x10e2 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    10ca:	80 91 70 06 	lds	r24, 0x0670
    10ce:	90 91 71 06 	lds	r25, 0x0671
    10d2:	9c 01       	movw	r18, r24
    10d4:	24 5f       	subi	r18, 0xF4	; 244
    10d6:	3f 4f       	sbci	r19, 0xFF	; 255
    10d8:	8d 81       	ldd	r24, Y+5	; 0x05
    10da:	9e 81       	ldd	r25, Y+6	; 0x06
    10dc:	b9 01       	movw	r22, r18
    10de:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <vListInsert>
        }
    }
    10e2:	26 96       	adiw	r28, 0x06	; 6
    10e4:	0f b6       	in	r0, 0x3f	; 63
    10e6:	f8 94       	cli
    10e8:	de bf       	out	0x3e, r29	; 62
    10ea:	0f be       	out	0x3f, r0	; 63
    10ec:	cd bf       	out	0x3d, r28	; 61
    10ee:	cf 91       	pop	r28
    10f0:	df 91       	pop	r29
    10f2:	08 95       	ret

000010f4 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    10f4:	df 93       	push	r29
    10f6:	cf 93       	push	r28
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <prvCheckPendingReadyList+0x6>
    10fa:	cd b7       	in	r28, 0x3d	; 61
    10fc:	de b7       	in	r29, 0x3e	; 62
    10fe:	3a c0       	rjmp	.+116    	; 0x1174 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    1100:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    1102:	e0 91 a2 06 	lds	r30, 0x06A2
    1106:	f0 91 a3 06 	lds	r31, 0x06A3
    110a:	86 81       	ldd	r24, Z+6	; 0x06
    110c:	97 81       	ldd	r25, Z+7	; 0x07
    110e:	9a 83       	std	Y+2, r25	; 0x02
    1110:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1112:	89 81       	ldd	r24, Y+1	; 0x01
    1114:	9a 81       	ldd	r25, Y+2	; 0x02
    1116:	0c 96       	adiw	r24, 0x0c	; 12
    1118:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    111c:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    111e:	89 81       	ldd	r24, Y+1	; 0x01
    1120:	9a 81       	ldd	r25, Y+2	; 0x02
    1122:	02 96       	adiw	r24, 0x02	; 2
    1124:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1128:	e9 81       	ldd	r30, Y+1	; 0x01
    112a:	fa 81       	ldd	r31, Y+2	; 0x02
    112c:	96 89       	ldd	r25, Z+22	; 0x16
    112e:	80 91 72 06 	lds	r24, 0x0672
    1132:	89 17       	cp	r24, r25
    1134:	28 f4       	brcc	.+10     	; 0x1140 <prvCheckPendingReadyList+0x4c>
    1136:	e9 81       	ldd	r30, Y+1	; 0x01
    1138:	fa 81       	ldd	r31, Y+2	; 0x02
    113a:	86 89       	ldd	r24, Z+22	; 0x16
    113c:	80 93 72 06 	sts	0x0672, r24
    1140:	e9 81       	ldd	r30, Y+1	; 0x01
    1142:	fa 81       	ldd	r31, Y+2	; 0x02
    1144:	86 89       	ldd	r24, Z+22	; 0x16
    1146:	28 2f       	mov	r18, r24
    1148:	30 e0       	ldi	r19, 0x00	; 0
    114a:	c9 01       	movw	r24, r18
    114c:	88 0f       	add	r24, r24
    114e:	99 1f       	adc	r25, r25
    1150:	88 0f       	add	r24, r24
    1152:	99 1f       	adc	r25, r25
    1154:	88 0f       	add	r24, r24
    1156:	99 1f       	adc	r25, r25
    1158:	82 0f       	add	r24, r18
    115a:	93 1f       	adc	r25, r19
    115c:	ac 01       	movw	r20, r24
    115e:	47 58       	subi	r20, 0x87	; 135
    1160:	59 4f       	sbci	r21, 0xF9	; 249
    1162:	89 81       	ldd	r24, Y+1	; 0x01
    1164:	9a 81       	ldd	r25, Y+2	; 0x02
    1166:	9c 01       	movw	r18, r24
    1168:	2e 5f       	subi	r18, 0xFE	; 254
    116a:	3f 4f       	sbci	r19, 0xFF	; 255
    116c:	ca 01       	movw	r24, r20
    116e:	b9 01       	movw	r22, r18
    1170:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1174:	80 91 9d 06 	lds	r24, 0x069D
    1178:	88 23       	and	r24, r24
    117a:	09 f0       	breq	.+2      	; 0x117e <prvCheckPendingReadyList+0x8a>
    117c:	c1 cf       	rjmp	.-126    	; 0x1100 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    117e:	0f 90       	pop	r0
    1180:	0f 90       	pop	r0
    1182:	cf 91       	pop	r28
    1184:	df 91       	pop	r29
    1186:	08 95       	ret

00001188 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    1188:	df 93       	push	r29
    118a:	cf 93       	push	r28
    118c:	00 d0       	rcall	.+0      	; 0x118e <prvCheckDelayedList+0x6>
    118e:	00 d0       	rcall	.+0      	; 0x1190 <prvCheckDelayedList+0x8>
    1190:	cd b7       	in	r28, 0x3d	; 61
    1192:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1194:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <xTaskGetTickCount>
    1198:	20 91 75 06 	lds	r18, 0x0675
    119c:	30 91 76 06 	lds	r19, 0x0676
    11a0:	82 1b       	sub	r24, r18
    11a2:	93 0b       	sbc	r25, r19
    11a4:	90 93 78 06 	sts	0x0678, r25
    11a8:	80 93 77 06 	sts	0x0677, r24
    11ac:	85 c0       	rjmp	.+266    	; 0x12b8 <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    11ae:	80 91 73 06 	lds	r24, 0x0673
    11b2:	90 91 74 06 	lds	r25, 0x0674
    11b6:	01 96       	adiw	r24, 0x01	; 1
    11b8:	90 93 74 06 	sts	0x0674, r25
    11bc:	80 93 73 06 	sts	0x0673, r24
            xPassedTicks--;
    11c0:	80 91 77 06 	lds	r24, 0x0677
    11c4:	90 91 78 06 	lds	r25, 0x0678
    11c8:	01 97       	sbiw	r24, 0x01	; 1
    11ca:	90 93 78 06 	sts	0x0678, r25
    11ce:	80 93 77 06 	sts	0x0677, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    11d2:	80 91 73 06 	lds	r24, 0x0673
    11d6:	90 91 74 06 	lds	r25, 0x0674
    11da:	00 97       	sbiw	r24, 0x00	; 0
    11dc:	09 f0       	breq	.+2      	; 0x11e0 <prvCheckDelayedList+0x58>
    11de:	64 c0       	rjmp	.+200    	; 0x12a8 <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    11e0:	80 91 6c 06 	lds	r24, 0x066C
    11e4:	90 91 6d 06 	lds	r25, 0x066D
    11e8:	9a 83       	std	Y+2, r25	; 0x02
    11ea:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    11ec:	80 91 6e 06 	lds	r24, 0x066E
    11f0:	90 91 6f 06 	lds	r25, 0x066F
    11f4:	90 93 6d 06 	sts	0x066D, r25
    11f8:	80 93 6c 06 	sts	0x066C, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    11fc:	89 81       	ldd	r24, Y+1	; 0x01
    11fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1200:	90 93 6f 06 	sts	0x066F, r25
    1204:	80 93 6e 06 	sts	0x066E, r24
    1208:	4f c0       	rjmp	.+158    	; 0x12a8 <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    120a:	e0 91 6c 06 	lds	r30, 0x066C
    120e:	f0 91 6d 06 	lds	r31, 0x066D
    1212:	05 80       	ldd	r0, Z+5	; 0x05
    1214:	f6 81       	ldd	r31, Z+6	; 0x06
    1216:	e0 2d       	mov	r30, r0
    1218:	86 81       	ldd	r24, Z+6	; 0x06
    121a:	97 81       	ldd	r25, Z+7	; 0x07
    121c:	9c 83       	std	Y+4, r25	; 0x04
    121e:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1220:	eb 81       	ldd	r30, Y+3	; 0x03
    1222:	fc 81       	ldd	r31, Y+4	; 0x04
    1224:	22 81       	ldd	r18, Z+2	; 0x02
    1226:	33 81       	ldd	r19, Z+3	; 0x03
    1228:	80 91 73 06 	lds	r24, 0x0673
    122c:	90 91 74 06 	lds	r25, 0x0674
    1230:	82 17       	cp	r24, r18
    1232:	93 07       	cpc	r25, r19
    1234:	08 f4       	brcc	.+2      	; 0x1238 <prvCheckDelayedList+0xb0>
    1236:	40 c0       	rjmp	.+128    	; 0x12b8 <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    1238:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    123a:	8b 81       	ldd	r24, Y+3	; 0x03
    123c:	9c 81       	ldd	r25, Y+4	; 0x04
    123e:	02 96       	adiw	r24, 0x02	; 2
    1240:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    1244:	eb 81       	ldd	r30, Y+3	; 0x03
    1246:	fc 81       	ldd	r31, Y+4	; 0x04
    1248:	84 89       	ldd	r24, Z+20	; 0x14
    124a:	95 89       	ldd	r25, Z+21	; 0x15
    124c:	00 97       	sbiw	r24, 0x00	; 0
    124e:	29 f0       	breq	.+10     	; 0x125a <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1250:	8b 81       	ldd	r24, Y+3	; 0x03
    1252:	9c 81       	ldd	r25, Y+4	; 0x04
    1254:	0c 96       	adiw	r24, 0x0c	; 12
    1256:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    125a:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    125c:	eb 81       	ldd	r30, Y+3	; 0x03
    125e:	fc 81       	ldd	r31, Y+4	; 0x04
    1260:	96 89       	ldd	r25, Z+22	; 0x16
    1262:	80 91 72 06 	lds	r24, 0x0672
    1266:	89 17       	cp	r24, r25
    1268:	28 f4       	brcc	.+10     	; 0x1274 <prvCheckDelayedList+0xec>
    126a:	eb 81       	ldd	r30, Y+3	; 0x03
    126c:	fc 81       	ldd	r31, Y+4	; 0x04
    126e:	86 89       	ldd	r24, Z+22	; 0x16
    1270:	80 93 72 06 	sts	0x0672, r24
    1274:	eb 81       	ldd	r30, Y+3	; 0x03
    1276:	fc 81       	ldd	r31, Y+4	; 0x04
    1278:	86 89       	ldd	r24, Z+22	; 0x16
    127a:	28 2f       	mov	r18, r24
    127c:	30 e0       	ldi	r19, 0x00	; 0
    127e:	c9 01       	movw	r24, r18
    1280:	88 0f       	add	r24, r24
    1282:	99 1f       	adc	r25, r25
    1284:	88 0f       	add	r24, r24
    1286:	99 1f       	adc	r25, r25
    1288:	88 0f       	add	r24, r24
    128a:	99 1f       	adc	r25, r25
    128c:	82 0f       	add	r24, r18
    128e:	93 1f       	adc	r25, r19
    1290:	ac 01       	movw	r20, r24
    1292:	47 58       	subi	r20, 0x87	; 135
    1294:	59 4f       	sbci	r21, 0xF9	; 249
    1296:	8b 81       	ldd	r24, Y+3	; 0x03
    1298:	9c 81       	ldd	r25, Y+4	; 0x04
    129a:	9c 01       	movw	r18, r24
    129c:	2e 5f       	subi	r18, 0xFE	; 254
    129e:	3f 4f       	sbci	r19, 0xFF	; 255
    12a0:	ca 01       	movw	r24, r20
    12a2:	b9 01       	movw	r22, r18
    12a4:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    12a8:	e0 91 6c 06 	lds	r30, 0x066C
    12ac:	f0 91 6d 06 	lds	r31, 0x066D
    12b0:	80 81       	ld	r24, Z
    12b2:	88 23       	and	r24, r24
    12b4:	09 f0       	breq	.+2      	; 0x12b8 <prvCheckDelayedList+0x130>
    12b6:	a9 cf       	rjmp	.-174    	; 0x120a <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    12b8:	80 91 77 06 	lds	r24, 0x0677
    12bc:	90 91 78 06 	lds	r25, 0x0678
    12c0:	00 97       	sbiw	r24, 0x00	; 0
    12c2:	09 f0       	breq	.+2      	; 0x12c6 <prvCheckDelayedList+0x13e>
    12c4:	74 cf       	rjmp	.-280    	; 0x11ae <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    12c6:	80 91 73 06 	lds	r24, 0x0673
    12ca:	90 91 74 06 	lds	r25, 0x0674
    12ce:	90 93 76 06 	sts	0x0676, r25
    12d2:	80 93 75 06 	sts	0x0675, r24
    }
    12d6:	0f 90       	pop	r0
    12d8:	0f 90       	pop	r0
    12da:	0f 90       	pop	r0
    12dc:	0f 90       	pop	r0
    12de:	cf 91       	pop	r28
    12e0:	df 91       	pop	r29
    12e2:	08 95       	ret

000012e4 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    12e4:	df 93       	push	r29
    12e6:	cf 93       	push	r28
    12e8:	00 d0       	rcall	.+0      	; 0x12ea <vCoRoutineSchedule+0x6>
    12ea:	cd b7       	in	r28, 0x3d	; 61
    12ec:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    12ee:	80 91 6c 06 	lds	r24, 0x066C
    12f2:	90 91 6d 06 	lds	r25, 0x066D
    12f6:	00 97       	sbiw	r24, 0x00	; 0
    12f8:	09 f4       	brne	.+2      	; 0x12fc <vCoRoutineSchedule+0x18>
    12fa:	70 c0       	rjmp	.+224    	; 0x13dc <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    12fc:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    1300:	0e 94 c4 08 	call	0x1188	; 0x1188 <prvCheckDelayedList>
    1304:	0a c0       	rjmp	.+20     	; 0x131a <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    1306:	80 91 72 06 	lds	r24, 0x0672
    130a:	88 23       	and	r24, r24
    130c:	09 f4       	brne	.+2      	; 0x1310 <vCoRoutineSchedule+0x2c>
    130e:	66 c0       	rjmp	.+204    	; 0x13dc <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    1310:	80 91 72 06 	lds	r24, 0x0672
    1314:	81 50       	subi	r24, 0x01	; 1
    1316:	80 93 72 06 	sts	0x0672, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    131a:	80 91 72 06 	lds	r24, 0x0672
    131e:	28 2f       	mov	r18, r24
    1320:	30 e0       	ldi	r19, 0x00	; 0
    1322:	c9 01       	movw	r24, r18
    1324:	88 0f       	add	r24, r24
    1326:	99 1f       	adc	r25, r25
    1328:	88 0f       	add	r24, r24
    132a:	99 1f       	adc	r25, r25
    132c:	88 0f       	add	r24, r24
    132e:	99 1f       	adc	r25, r25
    1330:	82 0f       	add	r24, r18
    1332:	93 1f       	adc	r25, r19
    1334:	fc 01       	movw	r30, r24
    1336:	e7 58       	subi	r30, 0x87	; 135
    1338:	f9 4f       	sbci	r31, 0xF9	; 249
    133a:	80 81       	ld	r24, Z
    133c:	88 23       	and	r24, r24
    133e:	19 f3       	breq	.-58     	; 0x1306 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1340:	80 91 72 06 	lds	r24, 0x0672
    1344:	28 2f       	mov	r18, r24
    1346:	30 e0       	ldi	r19, 0x00	; 0
    1348:	c9 01       	movw	r24, r18
    134a:	88 0f       	add	r24, r24
    134c:	99 1f       	adc	r25, r25
    134e:	88 0f       	add	r24, r24
    1350:	99 1f       	adc	r25, r25
    1352:	88 0f       	add	r24, r24
    1354:	99 1f       	adc	r25, r25
    1356:	82 0f       	add	r24, r18
    1358:	93 1f       	adc	r25, r19
    135a:	87 58       	subi	r24, 0x87	; 135
    135c:	99 4f       	sbci	r25, 0xF9	; 249
    135e:	9a 83       	std	Y+2, r25	; 0x02
    1360:	89 83       	std	Y+1, r24	; 0x01
    1362:	e9 81       	ldd	r30, Y+1	; 0x01
    1364:	fa 81       	ldd	r31, Y+2	; 0x02
    1366:	01 80       	ldd	r0, Z+1	; 0x01
    1368:	f2 81       	ldd	r31, Z+2	; 0x02
    136a:	e0 2d       	mov	r30, r0
    136c:	82 81       	ldd	r24, Z+2	; 0x02
    136e:	93 81       	ldd	r25, Z+3	; 0x03
    1370:	e9 81       	ldd	r30, Y+1	; 0x01
    1372:	fa 81       	ldd	r31, Y+2	; 0x02
    1374:	92 83       	std	Z+2, r25	; 0x02
    1376:	81 83       	std	Z+1, r24	; 0x01
    1378:	e9 81       	ldd	r30, Y+1	; 0x01
    137a:	fa 81       	ldd	r31, Y+2	; 0x02
    137c:	21 81       	ldd	r18, Z+1	; 0x01
    137e:	32 81       	ldd	r19, Z+2	; 0x02
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	9a 81       	ldd	r25, Y+2	; 0x02
    1384:	03 96       	adiw	r24, 0x03	; 3
    1386:	28 17       	cp	r18, r24
    1388:	39 07       	cpc	r19, r25
    138a:	59 f4       	brne	.+22     	; 0x13a2 <vCoRoutineSchedule+0xbe>
    138c:	e9 81       	ldd	r30, Y+1	; 0x01
    138e:	fa 81       	ldd	r31, Y+2	; 0x02
    1390:	01 80       	ldd	r0, Z+1	; 0x01
    1392:	f2 81       	ldd	r31, Z+2	; 0x02
    1394:	e0 2d       	mov	r30, r0
    1396:	82 81       	ldd	r24, Z+2	; 0x02
    1398:	93 81       	ldd	r25, Z+3	; 0x03
    139a:	e9 81       	ldd	r30, Y+1	; 0x01
    139c:	fa 81       	ldd	r31, Y+2	; 0x02
    139e:	92 83       	std	Z+2, r25	; 0x02
    13a0:	81 83       	std	Z+1, r24	; 0x01
    13a2:	e9 81       	ldd	r30, Y+1	; 0x01
    13a4:	fa 81       	ldd	r31, Y+2	; 0x02
    13a6:	01 80       	ldd	r0, Z+1	; 0x01
    13a8:	f2 81       	ldd	r31, Z+2	; 0x02
    13aa:	e0 2d       	mov	r30, r0
    13ac:	86 81       	ldd	r24, Z+6	; 0x06
    13ae:	97 81       	ldd	r25, Z+7	; 0x07
    13b0:	90 93 71 06 	sts	0x0671, r25
    13b4:	80 93 70 06 	sts	0x0670, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    13b8:	e0 91 70 06 	lds	r30, 0x0670
    13bc:	f0 91 71 06 	lds	r31, 0x0671
    13c0:	40 81       	ld	r20, Z
    13c2:	51 81       	ldd	r21, Z+1	; 0x01
    13c4:	80 91 70 06 	lds	r24, 0x0670
    13c8:	90 91 71 06 	lds	r25, 0x0671
    13cc:	e0 91 70 06 	lds	r30, 0x0670
    13d0:	f0 91 71 06 	lds	r31, 0x0671
    13d4:	27 89       	ldd	r18, Z+23	; 0x17
    13d6:	62 2f       	mov	r22, r18
    13d8:	fa 01       	movw	r30, r20
    13da:	09 95       	icall
        }
    }
    13dc:	0f 90       	pop	r0
    13de:	0f 90       	pop	r0
    13e0:	cf 91       	pop	r28
    13e2:	df 91       	pop	r29
    13e4:	08 95       	ret

000013e6 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    13e6:	df 93       	push	r29
    13e8:	cf 93       	push	r28
    13ea:	0f 92       	push	r0
    13ec:	cd b7       	in	r28, 0x3d	; 61
    13ee:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    13f0:	19 82       	std	Y+1, r1	; 0x01
    13f2:	13 c0       	rjmp	.+38     	; 0x141a <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    13f4:	89 81       	ldd	r24, Y+1	; 0x01
    13f6:	28 2f       	mov	r18, r24
    13f8:	30 e0       	ldi	r19, 0x00	; 0
    13fa:	c9 01       	movw	r24, r18
    13fc:	88 0f       	add	r24, r24
    13fe:	99 1f       	adc	r25, r25
    1400:	88 0f       	add	r24, r24
    1402:	99 1f       	adc	r25, r25
    1404:	88 0f       	add	r24, r24
    1406:	99 1f       	adc	r25, r25
    1408:	82 0f       	add	r24, r18
    140a:	93 1f       	adc	r25, r19
    140c:	87 58       	subi	r24, 0x87	; 135
    140e:	99 4f       	sbci	r25, 0xF9	; 249
    1410:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1414:	89 81       	ldd	r24, Y+1	; 0x01
    1416:	8f 5f       	subi	r24, 0xFF	; 255
    1418:	89 83       	std	Y+1, r24	; 0x01
    141a:	89 81       	ldd	r24, Y+1	; 0x01
    141c:	82 30       	cpi	r24, 0x02	; 2
    141e:	50 f3       	brcs	.-44     	; 0x13f4 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1420:	8b e8       	ldi	r24, 0x8B	; 139
    1422:	96 e0       	ldi	r25, 0x06	; 6
    1424:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1428:	84 e9       	ldi	r24, 0x94	; 148
    142a:	96 e0       	ldi	r25, 0x06	; 6
    142c:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1430:	8d e9       	ldi	r24, 0x9D	; 157
    1432:	96 e0       	ldi	r25, 0x06	; 6
    1434:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1438:	8b e8       	ldi	r24, 0x8B	; 139
    143a:	96 e0       	ldi	r25, 0x06	; 6
    143c:	90 93 6d 06 	sts	0x066D, r25
    1440:	80 93 6c 06 	sts	0x066C, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1444:	84 e9       	ldi	r24, 0x94	; 148
    1446:	96 e0       	ldi	r25, 0x06	; 6
    1448:	90 93 6f 06 	sts	0x066F, r25
    144c:	80 93 6e 06 	sts	0x066E, r24
    }
    1450:	0f 90       	pop	r0
    1452:	cf 91       	pop	r28
    1454:	df 91       	pop	r29
    1456:	08 95       	ret

00001458 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    1458:	df 93       	push	r29
    145a:	cf 93       	push	r28
    145c:	00 d0       	rcall	.+0      	; 0x145e <xCoRoutineRemoveFromEventList+0x6>
    145e:	00 d0       	rcall	.+0      	; 0x1460 <xCoRoutineRemoveFromEventList+0x8>
    1460:	0f 92       	push	r0
    1462:	cd b7       	in	r28, 0x3d	; 61
    1464:	de b7       	in	r29, 0x3e	; 62
    1466:	9d 83       	std	Y+5, r25	; 0x05
    1468:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    146a:	ec 81       	ldd	r30, Y+4	; 0x04
    146c:	fd 81       	ldd	r31, Y+5	; 0x05
    146e:	05 80       	ldd	r0, Z+5	; 0x05
    1470:	f6 81       	ldd	r31, Z+6	; 0x06
    1472:	e0 2d       	mov	r30, r0
    1474:	86 81       	ldd	r24, Z+6	; 0x06
    1476:	97 81       	ldd	r25, Z+7	; 0x07
    1478:	9b 83       	std	Y+3, r25	; 0x03
    147a:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    147c:	8a 81       	ldd	r24, Y+2	; 0x02
    147e:	9b 81       	ldd	r25, Y+3	; 0x03
    1480:	0c 96       	adiw	r24, 0x0c	; 12
    1482:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1486:	8a 81       	ldd	r24, Y+2	; 0x02
    1488:	9b 81       	ldd	r25, Y+3	; 0x03
    148a:	9c 01       	movw	r18, r24
    148c:	24 5f       	subi	r18, 0xF4	; 244
    148e:	3f 4f       	sbci	r19, 0xFF	; 255
    1490:	8d e9       	ldi	r24, 0x9D	; 157
    1492:	96 e0       	ldi	r25, 0x06	; 6
    1494:	b9 01       	movw	r22, r18
    1496:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    149a:	ea 81       	ldd	r30, Y+2	; 0x02
    149c:	fb 81       	ldd	r31, Y+3	; 0x03
    149e:	96 89       	ldd	r25, Z+22	; 0x16
    14a0:	e0 91 70 06 	lds	r30, 0x0670
    14a4:	f0 91 71 06 	lds	r31, 0x0671
    14a8:	86 89       	ldd	r24, Z+22	; 0x16
    14aa:	98 17       	cp	r25, r24
    14ac:	18 f0       	brcs	.+6      	; 0x14b4 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	89 83       	std	Y+1, r24	; 0x01
    14b2:	01 c0       	rjmp	.+2      	; 0x14b6 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    14b4:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    14b6:	89 81       	ldd	r24, Y+1	; 0x01
    }
    14b8:	0f 90       	pop	r0
    14ba:	0f 90       	pop	r0
    14bc:	0f 90       	pop	r0
    14be:	0f 90       	pop	r0
    14c0:	0f 90       	pop	r0
    14c2:	cf 91       	pop	r28
    14c4:	df 91       	pop	r29
    14c6:	08 95       	ret

000014c8 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    14c8:	df 93       	push	r29
    14ca:	cf 93       	push	r28
    14cc:	00 d0       	rcall	.+0      	; 0x14ce <xEventGroupCreate+0x6>
    14ce:	cd b7       	in	r28, 0x3d	; 61
    14d0:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    14d2:	8b e0       	ldi	r24, 0x0B	; 11
    14d4:	90 e0       	ldi	r25, 0x00	; 0
    14d6:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    14da:	9a 83       	std	Y+2, r25	; 0x02
    14dc:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    14de:	89 81       	ldd	r24, Y+1	; 0x01
    14e0:	9a 81       	ldd	r25, Y+2	; 0x02
    14e2:	00 97       	sbiw	r24, 0x00	; 0
    14e4:	49 f0       	breq	.+18     	; 0x14f8 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    14e6:	e9 81       	ldd	r30, Y+1	; 0x01
    14e8:	fa 81       	ldd	r31, Y+2	; 0x02
    14ea:	11 82       	std	Z+1, r1	; 0x01
    14ec:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    14ee:	89 81       	ldd	r24, Y+1	; 0x01
    14f0:	9a 81       	ldd	r25, Y+2	; 0x02
    14f2:	02 96       	adiw	r24, 0x02	; 2
    14f4:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    14f8:	89 81       	ldd	r24, Y+1	; 0x01
    14fa:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    14fc:	0f 90       	pop	r0
    14fe:	0f 90       	pop	r0
    1500:	cf 91       	pop	r28
    1502:	df 91       	pop	r29
    1504:	08 95       	ret

00001506 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1506:	df 93       	push	r29
    1508:	cf 93       	push	r28
    150a:	cd b7       	in	r28, 0x3d	; 61
    150c:	de b7       	in	r29, 0x3e	; 62
    150e:	60 97       	sbiw	r28, 0x10	; 16
    1510:	0f b6       	in	r0, 0x3f	; 63
    1512:	f8 94       	cli
    1514:	de bf       	out	0x3e, r29	; 62
    1516:	0f be       	out	0x3f, r0	; 63
    1518:	cd bf       	out	0x3d, r28	; 61
    151a:	9a 87       	std	Y+10, r25	; 0x0a
    151c:	89 87       	std	Y+9, r24	; 0x09
    151e:	7c 87       	std	Y+12, r23	; 0x0c
    1520:	6b 87       	std	Y+11, r22	; 0x0b
    1522:	5e 87       	std	Y+14, r21	; 0x0e
    1524:	4d 87       	std	Y+13, r20	; 0x0d
    1526:	38 8b       	std	Y+16, r19	; 0x10
    1528:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    152a:	89 85       	ldd	r24, Y+9	; 0x09
    152c:	9a 85       	ldd	r25, Y+10	; 0x0a
    152e:	9c 83       	std	Y+4, r25	; 0x04
    1530:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1532:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1534:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1538:	eb 81       	ldd	r30, Y+3	; 0x03
    153a:	fc 81       	ldd	r31, Y+4	; 0x04
    153c:	80 81       	ld	r24, Z
    153e:	91 81       	ldd	r25, Z+1	; 0x01
    1540:	98 87       	std	Y+8, r25	; 0x08
    1542:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1544:	89 85       	ldd	r24, Y+9	; 0x09
    1546:	9a 85       	ldd	r25, Y+10	; 0x0a
    1548:	2b 85       	ldd	r18, Y+11	; 0x0b
    154a:	3c 85       	ldd	r19, Y+12	; 0x0c
    154c:	b9 01       	movw	r22, r18
    154e:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1552:	2f 81       	ldd	r18, Y+7	; 0x07
    1554:	38 85       	ldd	r19, Y+8	; 0x08
    1556:	8b 85       	ldd	r24, Y+11	; 0x0b
    1558:	9c 85       	ldd	r25, Y+12	; 0x0c
    155a:	28 2b       	or	r18, r24
    155c:	39 2b       	or	r19, r25
    155e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1560:	9e 85       	ldd	r25, Y+14	; 0x0e
    1562:	28 23       	and	r18, r24
    1564:	39 23       	and	r19, r25
    1566:	8d 85       	ldd	r24, Y+13	; 0x0d
    1568:	9e 85       	ldd	r25, Y+14	; 0x0e
    156a:	28 17       	cp	r18, r24
    156c:	39 07       	cpc	r19, r25
    156e:	c9 f4       	brne	.+50     	; 0x15a2 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1570:	2f 81       	ldd	r18, Y+7	; 0x07
    1572:	38 85       	ldd	r19, Y+8	; 0x08
    1574:	8b 85       	ldd	r24, Y+11	; 0x0b
    1576:	9c 85       	ldd	r25, Y+12	; 0x0c
    1578:	82 2b       	or	r24, r18
    157a:	93 2b       	or	r25, r19
    157c:	9e 83       	std	Y+6, r25	; 0x06
    157e:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1580:	eb 81       	ldd	r30, Y+3	; 0x03
    1582:	fc 81       	ldd	r31, Y+4	; 0x04
    1584:	20 81       	ld	r18, Z
    1586:	31 81       	ldd	r19, Z+1	; 0x01
    1588:	8d 85       	ldd	r24, Y+13	; 0x0d
    158a:	9e 85       	ldd	r25, Y+14	; 0x0e
    158c:	80 95       	com	r24
    158e:	90 95       	com	r25
    1590:	82 23       	and	r24, r18
    1592:	93 23       	and	r25, r19
    1594:	eb 81       	ldd	r30, Y+3	; 0x03
    1596:	fc 81       	ldd	r31, Y+4	; 0x04
    1598:	91 83       	std	Z+1, r25	; 0x01
    159a:	80 83       	st	Z, r24

            xTicksToWait = 0;
    159c:	18 8a       	std	Y+16, r1	; 0x10
    159e:	1f 86       	std	Y+15, r1	; 0x0f
    15a0:	1e c0       	rjmp	.+60     	; 0x15de <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    15a2:	8f 85       	ldd	r24, Y+15	; 0x0f
    15a4:	98 89       	ldd	r25, Y+16	; 0x10
    15a6:	00 97       	sbiw	r24, 0x00	; 0
    15a8:	91 f0       	breq	.+36     	; 0x15ce <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    15aa:	8b 81       	ldd	r24, Y+3	; 0x03
    15ac:	9c 81       	ldd	r25, Y+4	; 0x04
    15ae:	bc 01       	movw	r22, r24
    15b0:	6e 5f       	subi	r22, 0xFE	; 254
    15b2:	7f 4f       	sbci	r23, 0xFF	; 255
    15b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    15b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    15b8:	9c 01       	movw	r18, r24
    15ba:	35 60       	ori	r19, 0x05	; 5
    15bc:	4f 85       	ldd	r20, Y+15	; 0x0f
    15be:	58 89       	ldd	r21, Y+16	; 0x10
    15c0:	cb 01       	movw	r24, r22
    15c2:	b9 01       	movw	r22, r18
    15c4:	0e 94 85 1f 	call	0x3f0a	; 0x3f0a <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    15c8:	1e 82       	std	Y+6, r1	; 0x06
    15ca:	1d 82       	std	Y+5, r1	; 0x05
    15cc:	08 c0       	rjmp	.+16     	; 0x15de <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    15ce:	eb 81       	ldd	r30, Y+3	; 0x03
    15d0:	fc 81       	ldd	r31, Y+4	; 0x04
    15d2:	80 81       	ld	r24, Z
    15d4:	91 81       	ldd	r25, Z+1	; 0x01
    15d6:	9e 83       	std	Y+6, r25	; 0x06
    15d8:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    15da:	81 e0       	ldi	r24, 0x01	; 1
    15dc:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    15de:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    15e2:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    15e4:	8f 85       	ldd	r24, Y+15	; 0x0f
    15e6:	98 89       	ldd	r25, Y+16	; 0x10
    15e8:	00 97       	sbiw	r24, 0x00	; 0
    15ea:	09 f4       	brne	.+2      	; 0x15ee <xEventGroupSync+0xe8>
    15ec:	3a c0       	rjmp	.+116    	; 0x1662 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    15ee:	8a 81       	ldd	r24, Y+2	; 0x02
    15f0:	88 23       	and	r24, r24
    15f2:	11 f4       	brne	.+4      	; 0x15f8 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    15f4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    15f8:	0e 94 13 24 	call	0x4826	; 0x4826 <uxTaskResetEventItemValue>
    15fc:	9e 83       	std	Y+6, r25	; 0x06
    15fe:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1600:	8d 81       	ldd	r24, Y+5	; 0x05
    1602:	9e 81       	ldd	r25, Y+6	; 0x06
    1604:	80 70       	andi	r24, 0x00	; 0
    1606:	92 70       	andi	r25, 0x02	; 2
    1608:	00 97       	sbiw	r24, 0x00	; 0
    160a:	31 f5       	brne	.+76     	; 0x1658 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    160c:	0f b6       	in	r0, 0x3f	; 63
    160e:	f8 94       	cli
    1610:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    1612:	eb 81       	ldd	r30, Y+3	; 0x03
    1614:	fc 81       	ldd	r31, Y+4	; 0x04
    1616:	80 81       	ld	r24, Z
    1618:	91 81       	ldd	r25, Z+1	; 0x01
    161a:	9e 83       	std	Y+6, r25	; 0x06
    161c:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    161e:	2d 81       	ldd	r18, Y+5	; 0x05
    1620:	3e 81       	ldd	r19, Y+6	; 0x06
    1622:	8d 85       	ldd	r24, Y+13	; 0x0d
    1624:	9e 85       	ldd	r25, Y+14	; 0x0e
    1626:	28 23       	and	r18, r24
    1628:	39 23       	and	r19, r25
    162a:	8d 85       	ldd	r24, Y+13	; 0x0d
    162c:	9e 85       	ldd	r25, Y+14	; 0x0e
    162e:	28 17       	cp	r18, r24
    1630:	39 07       	cpc	r19, r25
    1632:	71 f4       	brne	.+28     	; 0x1650 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1634:	eb 81       	ldd	r30, Y+3	; 0x03
    1636:	fc 81       	ldd	r31, Y+4	; 0x04
    1638:	20 81       	ld	r18, Z
    163a:	31 81       	ldd	r19, Z+1	; 0x01
    163c:	8d 85       	ldd	r24, Y+13	; 0x0d
    163e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1640:	80 95       	com	r24
    1642:	90 95       	com	r25
    1644:	82 23       	and	r24, r18
    1646:	93 23       	and	r25, r19
    1648:	eb 81       	ldd	r30, Y+3	; 0x03
    164a:	fc 81       	ldd	r31, Y+4	; 0x04
    164c:	91 83       	std	Z+1, r25	; 0x01
    164e:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    1650:	0f 90       	pop	r0
    1652:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    1654:	81 e0       	ldi	r24, 0x01	; 1
    1656:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1658:	8d 81       	ldd	r24, Y+5	; 0x05
    165a:	9e 81       	ldd	r25, Y+6	; 0x06
    165c:	90 70       	andi	r25, 0x00	; 0
    165e:	9e 83       	std	Y+6, r25	; 0x06
    1660:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1662:	8d 81       	ldd	r24, Y+5	; 0x05
    1664:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1666:	60 96       	adiw	r28, 0x10	; 16
    1668:	0f b6       	in	r0, 0x3f	; 63
    166a:	f8 94       	cli
    166c:	de bf       	out	0x3e, r29	; 62
    166e:	0f be       	out	0x3f, r0	; 63
    1670:	cd bf       	out	0x3d, r28	; 61
    1672:	cf 91       	pop	r28
    1674:	df 91       	pop	r29
    1676:	08 95       	ret

00001678 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1678:	0f 93       	push	r16
    167a:	1f 93       	push	r17
    167c:	df 93       	push	r29
    167e:	cf 93       	push	r28
    1680:	cd b7       	in	r28, 0x3d	; 61
    1682:	de b7       	in	r29, 0x3e	; 62
    1684:	63 97       	sbiw	r28, 0x13	; 19
    1686:	0f b6       	in	r0, 0x3f	; 63
    1688:	f8 94       	cli
    168a:	de bf       	out	0x3e, r29	; 62
    168c:	0f be       	out	0x3f, r0	; 63
    168e:	cd bf       	out	0x3d, r28	; 61
    1690:	9d 87       	std	Y+13, r25	; 0x0d
    1692:	8c 87       	std	Y+12, r24	; 0x0c
    1694:	7f 87       	std	Y+15, r23	; 0x0f
    1696:	6e 87       	std	Y+14, r22	; 0x0e
    1698:	48 8b       	std	Y+16, r20	; 0x10
    169a:	29 8b       	std	Y+17, r18	; 0x11
    169c:	1b 8b       	std	Y+19, r17	; 0x13
    169e:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    16a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    16a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    16a4:	9b 87       	std	Y+11, r25	; 0x0b
    16a6:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    16a8:	1f 82       	std	Y+7, r1	; 0x07
    16aa:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    16ac:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    16ae:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    16b2:	ea 85       	ldd	r30, Y+10	; 0x0a
    16b4:	fb 85       	ldd	r31, Y+11	; 0x0b
    16b6:	80 81       	ld	r24, Z
    16b8:	91 81       	ldd	r25, Z+1	; 0x01
    16ba:	9a 83       	std	Y+2, r25	; 0x02
    16bc:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    16be:	89 81       	ldd	r24, Y+1	; 0x01
    16c0:	9a 81       	ldd	r25, Y+2	; 0x02
    16c2:	2e 85       	ldd	r18, Y+14	; 0x0e
    16c4:	3f 85       	ldd	r19, Y+15	; 0x0f
    16c6:	b9 01       	movw	r22, r18
    16c8:	49 89       	ldd	r20, Y+17	; 0x11
    16ca:	0e 94 77 0d 	call	0x1aee	; 0x1aee <prvTestWaitCondition>
    16ce:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    16d0:	8d 81       	ldd	r24, Y+5	; 0x05
    16d2:	88 23       	and	r24, r24
    16d4:	c1 f0       	breq	.+48     	; 0x1706 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    16d6:	89 81       	ldd	r24, Y+1	; 0x01
    16d8:	9a 81       	ldd	r25, Y+2	; 0x02
    16da:	99 87       	std	Y+9, r25	; 0x09
    16dc:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    16de:	1b 8a       	std	Y+19, r1	; 0x13
    16e0:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    16e2:	88 89       	ldd	r24, Y+16	; 0x10
    16e4:	88 23       	and	r24, r24
    16e6:	e9 f1       	breq	.+122    	; 0x1762 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    16e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    16ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    16ec:	20 81       	ld	r18, Z
    16ee:	31 81       	ldd	r19, Z+1	; 0x01
    16f0:	8e 85       	ldd	r24, Y+14	; 0x0e
    16f2:	9f 85       	ldd	r25, Y+15	; 0x0f
    16f4:	80 95       	com	r24
    16f6:	90 95       	com	r25
    16f8:	82 23       	and	r24, r18
    16fa:	93 23       	and	r25, r19
    16fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    16fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    1700:	91 83       	std	Z+1, r25	; 0x01
    1702:	80 83       	st	Z, r24
    1704:	2e c0       	rjmp	.+92     	; 0x1762 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1706:	8a 89       	ldd	r24, Y+18	; 0x12
    1708:	9b 89       	ldd	r25, Y+19	; 0x13
    170a:	00 97       	sbiw	r24, 0x00	; 0
    170c:	39 f4       	brne	.+14     	; 0x171c <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    170e:	89 81       	ldd	r24, Y+1	; 0x01
    1710:	9a 81       	ldd	r25, Y+2	; 0x02
    1712:	99 87       	std	Y+9, r25	; 0x09
    1714:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    1716:	81 e0       	ldi	r24, 0x01	; 1
    1718:	8b 83       	std	Y+3, r24	; 0x03
    171a:	23 c0       	rjmp	.+70     	; 0x1762 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    171c:	88 89       	ldd	r24, Y+16	; 0x10
    171e:	88 23       	and	r24, r24
    1720:	29 f0       	breq	.+10     	; 0x172c <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1722:	8e 81       	ldd	r24, Y+6	; 0x06
    1724:	9f 81       	ldd	r25, Y+7	; 0x07
    1726:	91 60       	ori	r25, 0x01	; 1
    1728:	9f 83       	std	Y+7, r25	; 0x07
    172a:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    172c:	89 89       	ldd	r24, Y+17	; 0x11
    172e:	88 23       	and	r24, r24
    1730:	29 f0       	breq	.+10     	; 0x173c <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1732:	8e 81       	ldd	r24, Y+6	; 0x06
    1734:	9f 81       	ldd	r25, Y+7	; 0x07
    1736:	94 60       	ori	r25, 0x04	; 4
    1738:	9f 83       	std	Y+7, r25	; 0x07
    173a:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    173c:	8a 85       	ldd	r24, Y+10	; 0x0a
    173e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1740:	bc 01       	movw	r22, r24
    1742:	6e 5f       	subi	r22, 0xFE	; 254
    1744:	7f 4f       	sbci	r23, 0xFF	; 255
    1746:	2e 85       	ldd	r18, Y+14	; 0x0e
    1748:	3f 85       	ldd	r19, Y+15	; 0x0f
    174a:	8e 81       	ldd	r24, Y+6	; 0x06
    174c:	9f 81       	ldd	r25, Y+7	; 0x07
    174e:	28 2b       	or	r18, r24
    1750:	39 2b       	or	r19, r25
    1752:	4a 89       	ldd	r20, Y+18	; 0x12
    1754:	5b 89       	ldd	r21, Y+19	; 0x13
    1756:	cb 01       	movw	r24, r22
    1758:	b9 01       	movw	r22, r18
    175a:	0e 94 85 1f 	call	0x3f0a	; 0x3f0a <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    175e:	19 86       	std	Y+9, r1	; 0x09
    1760:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1762:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    1766:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1768:	8a 89       	ldd	r24, Y+18	; 0x12
    176a:	9b 89       	ldd	r25, Y+19	; 0x13
    176c:	00 97       	sbiw	r24, 0x00	; 0
    176e:	09 f4       	brne	.+2      	; 0x1772 <xEventGroupWaitBits+0xfa>
    1770:	3c c0       	rjmp	.+120    	; 0x17ea <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    1772:	8c 81       	ldd	r24, Y+4	; 0x04
    1774:	88 23       	and	r24, r24
    1776:	11 f4       	brne	.+4      	; 0x177c <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1778:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    177c:	0e 94 13 24 	call	0x4826	; 0x4826 <uxTaskResetEventItemValue>
    1780:	99 87       	std	Y+9, r25	; 0x09
    1782:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1784:	88 85       	ldd	r24, Y+8	; 0x08
    1786:	99 85       	ldd	r25, Y+9	; 0x09
    1788:	80 70       	andi	r24, 0x00	; 0
    178a:	92 70       	andi	r25, 0x02	; 2
    178c:	00 97       	sbiw	r24, 0x00	; 0
    178e:	41 f5       	brne	.+80     	; 0x17e0 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    1790:	0f b6       	in	r0, 0x3f	; 63
    1792:	f8 94       	cli
    1794:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1796:	ea 85       	ldd	r30, Y+10	; 0x0a
    1798:	fb 85       	ldd	r31, Y+11	; 0x0b
    179a:	80 81       	ld	r24, Z
    179c:	91 81       	ldd	r25, Z+1	; 0x01
    179e:	99 87       	std	Y+9, r25	; 0x09
    17a0:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    17a2:	88 85       	ldd	r24, Y+8	; 0x08
    17a4:	99 85       	ldd	r25, Y+9	; 0x09
    17a6:	2e 85       	ldd	r18, Y+14	; 0x0e
    17a8:	3f 85       	ldd	r19, Y+15	; 0x0f
    17aa:	b9 01       	movw	r22, r18
    17ac:	49 89       	ldd	r20, Y+17	; 0x11
    17ae:	0e 94 77 0d 	call	0x1aee	; 0x1aee <prvTestWaitCondition>
    17b2:	88 23       	and	r24, r24
    17b4:	89 f0       	breq	.+34     	; 0x17d8 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    17b6:	88 89       	ldd	r24, Y+16	; 0x10
    17b8:	88 23       	and	r24, r24
    17ba:	71 f0       	breq	.+28     	; 0x17d8 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    17bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    17be:	fb 85       	ldd	r31, Y+11	; 0x0b
    17c0:	20 81       	ld	r18, Z
    17c2:	31 81       	ldd	r19, Z+1	; 0x01
    17c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    17c6:	9f 85       	ldd	r25, Y+15	; 0x0f
    17c8:	80 95       	com	r24
    17ca:	90 95       	com	r25
    17cc:	82 23       	and	r24, r18
    17ce:	93 23       	and	r25, r19
    17d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    17d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    17d4:	91 83       	std	Z+1, r25	; 0x01
    17d6:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    17d8:	81 e0       	ldi	r24, 0x01	; 1
    17da:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    17dc:	0f 90       	pop	r0
    17de:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    17e0:	88 85       	ldd	r24, Y+8	; 0x08
    17e2:	99 85       	ldd	r25, Y+9	; 0x09
    17e4:	90 70       	andi	r25, 0x00	; 0
    17e6:	99 87       	std	Y+9, r25	; 0x09
    17e8:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    17ea:	88 85       	ldd	r24, Y+8	; 0x08
    17ec:	99 85       	ldd	r25, Y+9	; 0x09
}
    17ee:	63 96       	adiw	r28, 0x13	; 19
    17f0:	0f b6       	in	r0, 0x3f	; 63
    17f2:	f8 94       	cli
    17f4:	de bf       	out	0x3e, r29	; 62
    17f6:	0f be       	out	0x3f, r0	; 63
    17f8:	cd bf       	out	0x3d, r28	; 61
    17fa:	cf 91       	pop	r28
    17fc:	df 91       	pop	r29
    17fe:	1f 91       	pop	r17
    1800:	0f 91       	pop	r16
    1802:	08 95       	ret

00001804 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1804:	df 93       	push	r29
    1806:	cf 93       	push	r28
    1808:	cd b7       	in	r28, 0x3d	; 61
    180a:	de b7       	in	r29, 0x3e	; 62
    180c:	28 97       	sbiw	r28, 0x08	; 8
    180e:	0f b6       	in	r0, 0x3f	; 63
    1810:	f8 94       	cli
    1812:	de bf       	out	0x3e, r29	; 62
    1814:	0f be       	out	0x3f, r0	; 63
    1816:	cd bf       	out	0x3d, r28	; 61
    1818:	9e 83       	std	Y+6, r25	; 0x06
    181a:	8d 83       	std	Y+5, r24	; 0x05
    181c:	78 87       	std	Y+8, r23	; 0x08
    181e:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    1820:	8d 81       	ldd	r24, Y+5	; 0x05
    1822:	9e 81       	ldd	r25, Y+6	; 0x06
    1824:	9c 83       	std	Y+4, r25	; 0x04
    1826:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1828:	0f b6       	in	r0, 0x3f	; 63
    182a:	f8 94       	cli
    182c:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    182e:	eb 81       	ldd	r30, Y+3	; 0x03
    1830:	fc 81       	ldd	r31, Y+4	; 0x04
    1832:	80 81       	ld	r24, Z
    1834:	91 81       	ldd	r25, Z+1	; 0x01
    1836:	9a 83       	std	Y+2, r25	; 0x02
    1838:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    183a:	eb 81       	ldd	r30, Y+3	; 0x03
    183c:	fc 81       	ldd	r31, Y+4	; 0x04
    183e:	20 81       	ld	r18, Z
    1840:	31 81       	ldd	r19, Z+1	; 0x01
    1842:	8f 81       	ldd	r24, Y+7	; 0x07
    1844:	98 85       	ldd	r25, Y+8	; 0x08
    1846:	80 95       	com	r24
    1848:	90 95       	com	r25
    184a:	82 23       	and	r24, r18
    184c:	93 23       	and	r25, r19
    184e:	eb 81       	ldd	r30, Y+3	; 0x03
    1850:	fc 81       	ldd	r31, Y+4	; 0x04
    1852:	91 83       	std	Z+1, r25	; 0x01
    1854:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    1856:	0f 90       	pop	r0
    1858:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    185a:	89 81       	ldd	r24, Y+1	; 0x01
    185c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    185e:	28 96       	adiw	r28, 0x08	; 8
    1860:	0f b6       	in	r0, 0x3f	; 63
    1862:	f8 94       	cli
    1864:	de bf       	out	0x3e, r29	; 62
    1866:	0f be       	out	0x3f, r0	; 63
    1868:	cd bf       	out	0x3d, r28	; 61
    186a:	cf 91       	pop	r28
    186c:	df 91       	pop	r29
    186e:	08 95       	ret

00001870 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1870:	df 93       	push	r29
    1872:	cf 93       	push	r28
    1874:	cd b7       	in	r28, 0x3d	; 61
    1876:	de b7       	in	r29, 0x3e	; 62
    1878:	27 97       	sbiw	r28, 0x07	; 7
    187a:	0f b6       	in	r0, 0x3f	; 63
    187c:	f8 94       	cli
    187e:	de bf       	out	0x3e, r29	; 62
    1880:	0f be       	out	0x3f, r0	; 63
    1882:	cd bf       	out	0x3d, r28	; 61
    1884:	9f 83       	std	Y+7, r25	; 0x07
    1886:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1888:	8e 81       	ldd	r24, Y+6	; 0x06
    188a:	9f 81       	ldd	r25, Y+7	; 0x07
    188c:	9c 83       	std	Y+4, r25	; 0x04
    188e:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1890:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1892:	eb 81       	ldd	r30, Y+3	; 0x03
    1894:	fc 81       	ldd	r31, Y+4	; 0x04
    1896:	80 81       	ld	r24, Z
    1898:	91 81       	ldd	r25, Z+1	; 0x01
    189a:	9a 83       	std	Y+2, r25	; 0x02
    189c:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    189e:	89 81       	ldd	r24, Y+1	; 0x01
    18a0:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    18a2:	27 96       	adiw	r28, 0x07	; 7
    18a4:	0f b6       	in	r0, 0x3f	; 63
    18a6:	f8 94       	cli
    18a8:	de bf       	out	0x3e, r29	; 62
    18aa:	0f be       	out	0x3f, r0	; 63
    18ac:	cd bf       	out	0x3d, r28	; 61
    18ae:	cf 91       	pop	r28
    18b0:	df 91       	pop	r29
    18b2:	08 95       	ret

000018b4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    18b4:	df 93       	push	r29
    18b6:	cf 93       	push	r28
    18b8:	cd b7       	in	r28, 0x3d	; 61
    18ba:	de b7       	in	r29, 0x3e	; 62
    18bc:	65 97       	sbiw	r28, 0x15	; 21
    18be:	0f b6       	in	r0, 0x3f	; 63
    18c0:	f8 94       	cli
    18c2:	de bf       	out	0x3e, r29	; 62
    18c4:	0f be       	out	0x3f, r0	; 63
    18c6:	cd bf       	out	0x3d, r28	; 61
    18c8:	9b 8b       	std	Y+19, r25	; 0x13
    18ca:	8a 8b       	std	Y+18, r24	; 0x12
    18cc:	7d 8b       	std	Y+21, r23	; 0x15
    18ce:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    18d0:	19 86       	std	Y+9, r1	; 0x09
    18d2:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    18d4:	8a 89       	ldd	r24, Y+18	; 0x12
    18d6:	9b 89       	ldd	r25, Y+19	; 0x13
    18d8:	9b 83       	std	Y+3, r25	; 0x03
    18da:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    18dc:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    18de:	8a 81       	ldd	r24, Y+2	; 0x02
    18e0:	9b 81       	ldd	r25, Y+3	; 0x03
    18e2:	02 96       	adiw	r24, 0x02	; 2
    18e4:	9b 87       	std	Y+11, r25	; 0x0b
    18e6:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    18ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    18ec:	03 96       	adiw	r24, 0x03	; 3
    18ee:	9d 87       	std	Y+13, r25	; 0x0d
    18f0:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    18f2:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    18f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    18f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    18fa:	85 81       	ldd	r24, Z+5	; 0x05
    18fc:	96 81       	ldd	r25, Z+6	; 0x06
    18fe:	99 8b       	std	Y+17, r25	; 0x11
    1900:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1902:	ea 81       	ldd	r30, Y+2	; 0x02
    1904:	fb 81       	ldd	r31, Y+3	; 0x03
    1906:	20 81       	ld	r18, Z
    1908:	31 81       	ldd	r19, Z+1	; 0x01
    190a:	8c 89       	ldd	r24, Y+20	; 0x14
    190c:	9d 89       	ldd	r25, Y+21	; 0x15
    190e:	82 2b       	or	r24, r18
    1910:	93 2b       	or	r25, r19
    1912:	ea 81       	ldd	r30, Y+2	; 0x02
    1914:	fb 81       	ldd	r31, Y+3	; 0x03
    1916:	91 83       	std	Z+1, r25	; 0x01
    1918:	80 83       	st	Z, r24
    191a:	59 c0       	rjmp	.+178    	; 0x19ce <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    191c:	e8 89       	ldd	r30, Y+16	; 0x10
    191e:	f9 89       	ldd	r31, Y+17	; 0x11
    1920:	82 81       	ldd	r24, Z+2	; 0x02
    1922:	93 81       	ldd	r25, Z+3	; 0x03
    1924:	9f 87       	std	Y+15, r25	; 0x0f
    1926:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1928:	e8 89       	ldd	r30, Y+16	; 0x10
    192a:	f9 89       	ldd	r31, Y+17	; 0x11
    192c:	80 81       	ld	r24, Z
    192e:	91 81       	ldd	r25, Z+1	; 0x01
    1930:	9f 83       	std	Y+7, r25	; 0x07
    1932:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    1934:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1936:	8e 81       	ldd	r24, Y+6	; 0x06
    1938:	9f 81       	ldd	r25, Y+7	; 0x07
    193a:	80 70       	andi	r24, 0x00	; 0
    193c:	9d 83       	std	Y+5, r25	; 0x05
    193e:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1940:	8e 81       	ldd	r24, Y+6	; 0x06
    1942:	9f 81       	ldd	r25, Y+7	; 0x07
    1944:	90 70       	andi	r25, 0x00	; 0
    1946:	9f 83       	std	Y+7, r25	; 0x07
    1948:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    194a:	8c 81       	ldd	r24, Y+4	; 0x04
    194c:	9d 81       	ldd	r25, Y+5	; 0x05
    194e:	80 70       	andi	r24, 0x00	; 0
    1950:	94 70       	andi	r25, 0x04	; 4
    1952:	00 97       	sbiw	r24, 0x00	; 0
    1954:	69 f4       	brne	.+26     	; 0x1970 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1956:	ea 81       	ldd	r30, Y+2	; 0x02
    1958:	fb 81       	ldd	r31, Y+3	; 0x03
    195a:	20 81       	ld	r18, Z
    195c:	31 81       	ldd	r19, Z+1	; 0x01
    195e:	8e 81       	ldd	r24, Y+6	; 0x06
    1960:	9f 81       	ldd	r25, Y+7	; 0x07
    1962:	82 23       	and	r24, r18
    1964:	93 23       	and	r25, r19
    1966:	00 97       	sbiw	r24, 0x00	; 0
    1968:	91 f0       	breq	.+36     	; 0x198e <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    196a:	81 e0       	ldi	r24, 0x01	; 1
    196c:	89 83       	std	Y+1, r24	; 0x01
    196e:	0f c0       	rjmp	.+30     	; 0x198e <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1970:	ea 81       	ldd	r30, Y+2	; 0x02
    1972:	fb 81       	ldd	r31, Y+3	; 0x03
    1974:	20 81       	ld	r18, Z
    1976:	31 81       	ldd	r19, Z+1	; 0x01
    1978:	8e 81       	ldd	r24, Y+6	; 0x06
    197a:	9f 81       	ldd	r25, Y+7	; 0x07
    197c:	28 23       	and	r18, r24
    197e:	39 23       	and	r19, r25
    1980:	8e 81       	ldd	r24, Y+6	; 0x06
    1982:	9f 81       	ldd	r25, Y+7	; 0x07
    1984:	28 17       	cp	r18, r24
    1986:	39 07       	cpc	r19, r25
    1988:	11 f4       	brne	.+4      	; 0x198e <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    198a:	81 e0       	ldi	r24, 0x01	; 1
    198c:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    198e:	89 81       	ldd	r24, Y+1	; 0x01
    1990:	88 23       	and	r24, r24
    1992:	c9 f0       	breq	.+50     	; 0x19c6 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1994:	8c 81       	ldd	r24, Y+4	; 0x04
    1996:	9d 81       	ldd	r25, Y+5	; 0x05
    1998:	80 70       	andi	r24, 0x00	; 0
    199a:	91 70       	andi	r25, 0x01	; 1
    199c:	00 97       	sbiw	r24, 0x00	; 0
    199e:	41 f0       	breq	.+16     	; 0x19b0 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    19a0:	88 85       	ldd	r24, Y+8	; 0x08
    19a2:	99 85       	ldd	r25, Y+9	; 0x09
    19a4:	2e 81       	ldd	r18, Y+6	; 0x06
    19a6:	3f 81       	ldd	r19, Y+7	; 0x07
    19a8:	82 2b       	or	r24, r18
    19aa:	93 2b       	or	r25, r19
    19ac:	99 87       	std	Y+9, r25	; 0x09
    19ae:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    19b0:	ea 81       	ldd	r30, Y+2	; 0x02
    19b2:	fb 81       	ldd	r31, Y+3	; 0x03
    19b4:	80 81       	ld	r24, Z
    19b6:	91 81       	ldd	r25, Z+1	; 0x01
    19b8:	9c 01       	movw	r18, r24
    19ba:	32 60       	ori	r19, 0x02	; 2
    19bc:	88 89       	ldd	r24, Y+16	; 0x10
    19be:	99 89       	ldd	r25, Y+17	; 0x11
    19c0:	b9 01       	movw	r22, r18
    19c2:	0e 94 90 21 	call	0x4320	; 0x4320 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    19c6:	8e 85       	ldd	r24, Y+14	; 0x0e
    19c8:	9f 85       	ldd	r25, Y+15	; 0x0f
    19ca:	99 8b       	std	Y+17, r25	; 0x11
    19cc:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    19ce:	28 89       	ldd	r18, Y+16	; 0x10
    19d0:	39 89       	ldd	r19, Y+17	; 0x11
    19d2:	8c 85       	ldd	r24, Y+12	; 0x0c
    19d4:	9d 85       	ldd	r25, Y+13	; 0x0d
    19d6:	28 17       	cp	r18, r24
    19d8:	39 07       	cpc	r19, r25
    19da:	09 f0       	breq	.+2      	; 0x19de <xEventGroupSetBits+0x12a>
    19dc:	9f cf       	rjmp	.-194    	; 0x191c <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    19de:	ea 81       	ldd	r30, Y+2	; 0x02
    19e0:	fb 81       	ldd	r31, Y+3	; 0x03
    19e2:	20 81       	ld	r18, Z
    19e4:	31 81       	ldd	r19, Z+1	; 0x01
    19e6:	88 85       	ldd	r24, Y+8	; 0x08
    19e8:	99 85       	ldd	r25, Y+9	; 0x09
    19ea:	80 95       	com	r24
    19ec:	90 95       	com	r25
    19ee:	82 23       	and	r24, r18
    19f0:	93 23       	and	r25, r19
    19f2:	ea 81       	ldd	r30, Y+2	; 0x02
    19f4:	fb 81       	ldd	r31, Y+3	; 0x03
    19f6:	91 83       	std	Z+1, r25	; 0x01
    19f8:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    19fa:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    19fe:	ea 81       	ldd	r30, Y+2	; 0x02
    1a00:	fb 81       	ldd	r31, Y+3	; 0x03
    1a02:	80 81       	ld	r24, Z
    1a04:	91 81       	ldd	r25, Z+1	; 0x01
}
    1a06:	65 96       	adiw	r28, 0x15	; 21
    1a08:	0f b6       	in	r0, 0x3f	; 63
    1a0a:	f8 94       	cli
    1a0c:	de bf       	out	0x3e, r29	; 62
    1a0e:	0f be       	out	0x3f, r0	; 63
    1a10:	cd bf       	out	0x3d, r28	; 61
    1a12:	cf 91       	pop	r28
    1a14:	df 91       	pop	r29
    1a16:	08 95       	ret

00001a18 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1a18:	df 93       	push	r29
    1a1a:	cf 93       	push	r28
    1a1c:	00 d0       	rcall	.+0      	; 0x1a1e <vEventGroupDelete+0x6>
    1a1e:	00 d0       	rcall	.+0      	; 0x1a20 <vEventGroupDelete+0x8>
    1a20:	00 d0       	rcall	.+0      	; 0x1a22 <vEventGroupDelete+0xa>
    1a22:	cd b7       	in	r28, 0x3d	; 61
    1a24:	de b7       	in	r29, 0x3e	; 62
    1a26:	9e 83       	std	Y+6, r25	; 0x06
    1a28:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    1a2a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a2c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a2e:	9c 83       	std	Y+4, r25	; 0x04
    1a30:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1a32:	8b 81       	ldd	r24, Y+3	; 0x03
    1a34:	9c 81       	ldd	r25, Y+4	; 0x04
    1a36:	02 96       	adiw	r24, 0x02	; 2
    1a38:	9a 83       	std	Y+2, r25	; 0x02
    1a3a:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    1a3c:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
    1a40:	08 c0       	rjmp	.+16     	; 0x1a52 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1a42:	e9 81       	ldd	r30, Y+1	; 0x01
    1a44:	fa 81       	ldd	r31, Y+2	; 0x02
    1a46:	85 81       	ldd	r24, Z+5	; 0x05
    1a48:	96 81       	ldd	r25, Z+6	; 0x06
    1a4a:	60 e0       	ldi	r22, 0x00	; 0
    1a4c:	72 e0       	ldi	r23, 0x02	; 2
    1a4e:	0e 94 90 21 	call	0x4320	; 0x4320 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1a52:	e9 81       	ldd	r30, Y+1	; 0x01
    1a54:	fa 81       	ldd	r31, Y+2	; 0x02
    1a56:	80 81       	ld	r24, Z
    1a58:	88 23       	and	r24, r24
    1a5a:	99 f7       	brne	.-26     	; 0x1a42 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    1a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a60:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    1a64:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
}
    1a68:	26 96       	adiw	r28, 0x06	; 6
    1a6a:	0f b6       	in	r0, 0x3f	; 63
    1a6c:	f8 94       	cli
    1a6e:	de bf       	out	0x3e, r29	; 62
    1a70:	0f be       	out	0x3f, r0	; 63
    1a72:	cd bf       	out	0x3d, r28	; 61
    1a74:	cf 91       	pop	r28
    1a76:	df 91       	pop	r29
    1a78:	08 95       	ret

00001a7a <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    1a7a:	df 93       	push	r29
    1a7c:	cf 93       	push	r28
    1a7e:	00 d0       	rcall	.+0      	; 0x1a80 <vEventGroupSetBitsCallback+0x6>
    1a80:	00 d0       	rcall	.+0      	; 0x1a82 <vEventGroupSetBitsCallback+0x8>
    1a82:	00 d0       	rcall	.+0      	; 0x1a84 <vEventGroupSetBitsCallback+0xa>
    1a84:	cd b7       	in	r28, 0x3d	; 61
    1a86:	de b7       	in	r29, 0x3e	; 62
    1a88:	9a 83       	std	Y+2, r25	; 0x02
    1a8a:	89 83       	std	Y+1, r24	; 0x01
    1a8c:	4b 83       	std	Y+3, r20	; 0x03
    1a8e:	5c 83       	std	Y+4, r21	; 0x04
    1a90:	6d 83       	std	Y+5, r22	; 0x05
    1a92:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1a94:	89 81       	ldd	r24, Y+1	; 0x01
    1a96:	9a 81       	ldd	r25, Y+2	; 0x02
    1a98:	2b 81       	ldd	r18, Y+3	; 0x03
    1a9a:	3c 81       	ldd	r19, Y+4	; 0x04
    1a9c:	b9 01       	movw	r22, r18
    1a9e:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <xEventGroupSetBits>
}
    1aa2:	26 96       	adiw	r28, 0x06	; 6
    1aa4:	0f b6       	in	r0, 0x3f	; 63
    1aa6:	f8 94       	cli
    1aa8:	de bf       	out	0x3e, r29	; 62
    1aaa:	0f be       	out	0x3f, r0	; 63
    1aac:	cd bf       	out	0x3d, r28	; 61
    1aae:	cf 91       	pop	r28
    1ab0:	df 91       	pop	r29
    1ab2:	08 95       	ret

00001ab4 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1ab4:	df 93       	push	r29
    1ab6:	cf 93       	push	r28
    1ab8:	00 d0       	rcall	.+0      	; 0x1aba <vEventGroupClearBitsCallback+0x6>
    1aba:	00 d0       	rcall	.+0      	; 0x1abc <vEventGroupClearBitsCallback+0x8>
    1abc:	00 d0       	rcall	.+0      	; 0x1abe <vEventGroupClearBitsCallback+0xa>
    1abe:	cd b7       	in	r28, 0x3d	; 61
    1ac0:	de b7       	in	r29, 0x3e	; 62
    1ac2:	9a 83       	std	Y+2, r25	; 0x02
    1ac4:	89 83       	std	Y+1, r24	; 0x01
    1ac6:	4b 83       	std	Y+3, r20	; 0x03
    1ac8:	5c 83       	std	Y+4, r21	; 0x04
    1aca:	6d 83       	std	Y+5, r22	; 0x05
    1acc:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1ace:	89 81       	ldd	r24, Y+1	; 0x01
    1ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad2:	2b 81       	ldd	r18, Y+3	; 0x03
    1ad4:	3c 81       	ldd	r19, Y+4	; 0x04
    1ad6:	b9 01       	movw	r22, r18
    1ad8:	0e 94 02 0c 	call	0x1804	; 0x1804 <xEventGroupClearBits>
}
    1adc:	26 96       	adiw	r28, 0x06	; 6
    1ade:	0f b6       	in	r0, 0x3f	; 63
    1ae0:	f8 94       	cli
    1ae2:	de bf       	out	0x3e, r29	; 62
    1ae4:	0f be       	out	0x3f, r0	; 63
    1ae6:	cd bf       	out	0x3d, r28	; 61
    1ae8:	cf 91       	pop	r28
    1aea:	df 91       	pop	r29
    1aec:	08 95       	ret

00001aee <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    1aee:	df 93       	push	r29
    1af0:	cf 93       	push	r28
    1af2:	00 d0       	rcall	.+0      	; 0x1af4 <prvTestWaitCondition+0x6>
    1af4:	00 d0       	rcall	.+0      	; 0x1af6 <prvTestWaitCondition+0x8>
    1af6:	00 d0       	rcall	.+0      	; 0x1af8 <prvTestWaitCondition+0xa>
    1af8:	cd b7       	in	r28, 0x3d	; 61
    1afa:	de b7       	in	r29, 0x3e	; 62
    1afc:	9b 83       	std	Y+3, r25	; 0x03
    1afe:	8a 83       	std	Y+2, r24	; 0x02
    1b00:	7d 83       	std	Y+5, r23	; 0x05
    1b02:	6c 83       	std	Y+4, r22	; 0x04
    1b04:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    1b06:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1b08:	8e 81       	ldd	r24, Y+6	; 0x06
    1b0a:	88 23       	and	r24, r24
    1b0c:	59 f4       	brne	.+22     	; 0x1b24 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1b0e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b10:	9b 81       	ldd	r25, Y+3	; 0x03
    1b12:	2c 81       	ldd	r18, Y+4	; 0x04
    1b14:	3d 81       	ldd	r19, Y+5	; 0x05
    1b16:	82 23       	and	r24, r18
    1b18:	93 23       	and	r25, r19
    1b1a:	00 97       	sbiw	r24, 0x00	; 0
    1b1c:	81 f0       	breq	.+32     	; 0x1b3e <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1b1e:	81 e0       	ldi	r24, 0x01	; 1
    1b20:	89 83       	std	Y+1, r24	; 0x01
    1b22:	0d c0       	rjmp	.+26     	; 0x1b3e <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1b24:	2a 81       	ldd	r18, Y+2	; 0x02
    1b26:	3b 81       	ldd	r19, Y+3	; 0x03
    1b28:	8c 81       	ldd	r24, Y+4	; 0x04
    1b2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1b2c:	28 23       	and	r18, r24
    1b2e:	39 23       	and	r19, r25
    1b30:	8c 81       	ldd	r24, Y+4	; 0x04
    1b32:	9d 81       	ldd	r25, Y+5	; 0x05
    1b34:	28 17       	cp	r18, r24
    1b36:	39 07       	cpc	r19, r25
    1b38:	11 f4       	brne	.+4      	; 0x1b3e <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1b3a:	81 e0       	ldi	r24, 0x01	; 1
    1b3c:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    1b3e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1b40:	26 96       	adiw	r28, 0x06	; 6
    1b42:	0f b6       	in	r0, 0x3f	; 63
    1b44:	f8 94       	cli
    1b46:	de bf       	out	0x3e, r29	; 62
    1b48:	0f be       	out	0x3f, r0	; 63
    1b4a:	cd bf       	out	0x3d, r28	; 61
    1b4c:	cf 91       	pop	r28
    1b4e:	df 91       	pop	r29
    1b50:	08 95       	ret

00001b52 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b52:	df 93       	push	r29
    1b54:	cf 93       	push	r28
    1b56:	00 d0       	rcall	.+0      	; 0x1b58 <vListInitialise+0x6>
    1b58:	cd b7       	in	r28, 0x3d	; 61
    1b5a:	de b7       	in	r29, 0x3e	; 62
    1b5c:	9a 83       	std	Y+2, r25	; 0x02
    1b5e:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b60:	89 81       	ldd	r24, Y+1	; 0x01
    1b62:	9a 81       	ldd	r25, Y+2	; 0x02
    1b64:	03 96       	adiw	r24, 0x03	; 3
    1b66:	e9 81       	ldd	r30, Y+1	; 0x01
    1b68:	fa 81       	ldd	r31, Y+2	; 0x02
    1b6a:	92 83       	std	Z+2, r25	; 0x02
    1b6c:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b70:	fa 81       	ldd	r31, Y+2	; 0x02
    1b72:	8f ef       	ldi	r24, 0xFF	; 255
    1b74:	9f ef       	ldi	r25, 0xFF	; 255
    1b76:	94 83       	std	Z+4, r25	; 0x04
    1b78:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b7a:	89 81       	ldd	r24, Y+1	; 0x01
    1b7c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b7e:	03 96       	adiw	r24, 0x03	; 3
    1b80:	e9 81       	ldd	r30, Y+1	; 0x01
    1b82:	fa 81       	ldd	r31, Y+2	; 0x02
    1b84:	96 83       	std	Z+6, r25	; 0x06
    1b86:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b88:	89 81       	ldd	r24, Y+1	; 0x01
    1b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b8c:	03 96       	adiw	r24, 0x03	; 3
    1b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b90:	fa 81       	ldd	r31, Y+2	; 0x02
    1b92:	90 87       	std	Z+8, r25	; 0x08
    1b94:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b96:	e9 81       	ldd	r30, Y+1	; 0x01
    1b98:	fa 81       	ldd	r31, Y+2	; 0x02
    1b9a:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1b9c:	0f 90       	pop	r0
    1b9e:	0f 90       	pop	r0
    1ba0:	cf 91       	pop	r28
    1ba2:	df 91       	pop	r29
    1ba4:	08 95       	ret

00001ba6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1ba6:	df 93       	push	r29
    1ba8:	cf 93       	push	r28
    1baa:	00 d0       	rcall	.+0      	; 0x1bac <vListInitialiseItem+0x6>
    1bac:	cd b7       	in	r28, 0x3d	; 61
    1bae:	de b7       	in	r29, 0x3e	; 62
    1bb0:	9a 83       	std	Y+2, r25	; 0x02
    1bb2:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1bb6:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb8:	11 86       	std	Z+9, r1	; 0x09
    1bba:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1bbc:	0f 90       	pop	r0
    1bbe:	0f 90       	pop	r0
    1bc0:	cf 91       	pop	r28
    1bc2:	df 91       	pop	r29
    1bc4:	08 95       	ret

00001bc6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1bc6:	df 93       	push	r29
    1bc8:	cf 93       	push	r28
    1bca:	00 d0       	rcall	.+0      	; 0x1bcc <vListInsertEnd+0x6>
    1bcc:	00 d0       	rcall	.+0      	; 0x1bce <vListInsertEnd+0x8>
    1bce:	00 d0       	rcall	.+0      	; 0x1bd0 <vListInsertEnd+0xa>
    1bd0:	cd b7       	in	r28, 0x3d	; 61
    1bd2:	de b7       	in	r29, 0x3e	; 62
    1bd4:	9c 83       	std	Y+4, r25	; 0x04
    1bd6:	8b 83       	std	Y+3, r24	; 0x03
    1bd8:	7e 83       	std	Y+6, r23	; 0x06
    1bda:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    1bdc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bde:	fc 81       	ldd	r31, Y+4	; 0x04
    1be0:	81 81       	ldd	r24, Z+1	; 0x01
    1be2:	92 81       	ldd	r25, Z+2	; 0x02
    1be4:	9a 83       	std	Y+2, r25	; 0x02
    1be6:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1be8:	ed 81       	ldd	r30, Y+5	; 0x05
    1bea:	fe 81       	ldd	r31, Y+6	; 0x06
    1bec:	89 81       	ldd	r24, Y+1	; 0x01
    1bee:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf0:	93 83       	std	Z+3, r25	; 0x03
    1bf2:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1bf4:	e9 81       	ldd	r30, Y+1	; 0x01
    1bf6:	fa 81       	ldd	r31, Y+2	; 0x02
    1bf8:	84 81       	ldd	r24, Z+4	; 0x04
    1bfa:	95 81       	ldd	r25, Z+5	; 0x05
    1bfc:	ed 81       	ldd	r30, Y+5	; 0x05
    1bfe:	fe 81       	ldd	r31, Y+6	; 0x06
    1c00:	95 83       	std	Z+5, r25	; 0x05
    1c02:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c04:	e9 81       	ldd	r30, Y+1	; 0x01
    1c06:	fa 81       	ldd	r31, Y+2	; 0x02
    1c08:	04 80       	ldd	r0, Z+4	; 0x04
    1c0a:	f5 81       	ldd	r31, Z+5	; 0x05
    1c0c:	e0 2d       	mov	r30, r0
    1c0e:	8d 81       	ldd	r24, Y+5	; 0x05
    1c10:	9e 81       	ldd	r25, Y+6	; 0x06
    1c12:	93 83       	std	Z+3, r25	; 0x03
    1c14:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1c16:	e9 81       	ldd	r30, Y+1	; 0x01
    1c18:	fa 81       	ldd	r31, Y+2	; 0x02
    1c1a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c1c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c1e:	95 83       	std	Z+5, r25	; 0x05
    1c20:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1c22:	ed 81       	ldd	r30, Y+5	; 0x05
    1c24:	fe 81       	ldd	r31, Y+6	; 0x06
    1c26:	8b 81       	ldd	r24, Y+3	; 0x03
    1c28:	9c 81       	ldd	r25, Y+4	; 0x04
    1c2a:	91 87       	std	Z+9, r25	; 0x09
    1c2c:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1c2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c30:	fc 81       	ldd	r31, Y+4	; 0x04
    1c32:	80 81       	ld	r24, Z
    1c34:	8f 5f       	subi	r24, 0xFF	; 255
    1c36:	eb 81       	ldd	r30, Y+3	; 0x03
    1c38:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3a:	80 83       	st	Z, r24
}
    1c3c:	26 96       	adiw	r28, 0x06	; 6
    1c3e:	0f b6       	in	r0, 0x3f	; 63
    1c40:	f8 94       	cli
    1c42:	de bf       	out	0x3e, r29	; 62
    1c44:	0f be       	out	0x3f, r0	; 63
    1c46:	cd bf       	out	0x3d, r28	; 61
    1c48:	cf 91       	pop	r28
    1c4a:	df 91       	pop	r29
    1c4c:	08 95       	ret

00001c4e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1c4e:	df 93       	push	r29
    1c50:	cf 93       	push	r28
    1c52:	cd b7       	in	r28, 0x3d	; 61
    1c54:	de b7       	in	r29, 0x3e	; 62
    1c56:	28 97       	sbiw	r28, 0x08	; 8
    1c58:	0f b6       	in	r0, 0x3f	; 63
    1c5a:	f8 94       	cli
    1c5c:	de bf       	out	0x3e, r29	; 62
    1c5e:	0f be       	out	0x3f, r0	; 63
    1c60:	cd bf       	out	0x3d, r28	; 61
    1c62:	9e 83       	std	Y+6, r25	; 0x06
    1c64:	8d 83       	std	Y+5, r24	; 0x05
    1c66:	78 87       	std	Y+8, r23	; 0x08
    1c68:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c6a:	ef 81       	ldd	r30, Y+7	; 0x07
    1c6c:	f8 85       	ldd	r31, Y+8	; 0x08
    1c6e:	80 81       	ld	r24, Z
    1c70:	91 81       	ldd	r25, Z+1	; 0x01
    1c72:	9a 83       	std	Y+2, r25	; 0x02
    1c74:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1c76:	89 81       	ldd	r24, Y+1	; 0x01
    1c78:	9a 81       	ldd	r25, Y+2	; 0x02
    1c7a:	2f ef       	ldi	r18, 0xFF	; 255
    1c7c:	8f 3f       	cpi	r24, 0xFF	; 255
    1c7e:	92 07       	cpc	r25, r18
    1c80:	39 f4       	brne	.+14     	; 0x1c90 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1c82:	ed 81       	ldd	r30, Y+5	; 0x05
    1c84:	fe 81       	ldd	r31, Y+6	; 0x06
    1c86:	87 81       	ldd	r24, Z+7	; 0x07
    1c88:	90 85       	ldd	r25, Z+8	; 0x08
    1c8a:	9c 83       	std	Y+4, r25	; 0x04
    1c8c:	8b 83       	std	Y+3, r24	; 0x03
    1c8e:	18 c0       	rjmp	.+48     	; 0x1cc0 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c90:	8d 81       	ldd	r24, Y+5	; 0x05
    1c92:	9e 81       	ldd	r25, Y+6	; 0x06
    1c94:	03 96       	adiw	r24, 0x03	; 3
    1c96:	9c 83       	std	Y+4, r25	; 0x04
    1c98:	8b 83       	std	Y+3, r24	; 0x03
    1c9a:	06 c0       	rjmp	.+12     	; 0x1ca8 <vListInsert+0x5a>
    1c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca0:	82 81       	ldd	r24, Z+2	; 0x02
    1ca2:	93 81       	ldd	r25, Z+3	; 0x03
    1ca4:	9c 83       	std	Y+4, r25	; 0x04
    1ca6:	8b 83       	std	Y+3, r24	; 0x03
    1ca8:	eb 81       	ldd	r30, Y+3	; 0x03
    1caa:	fc 81       	ldd	r31, Y+4	; 0x04
    1cac:	02 80       	ldd	r0, Z+2	; 0x02
    1cae:	f3 81       	ldd	r31, Z+3	; 0x03
    1cb0:	e0 2d       	mov	r30, r0
    1cb2:	20 81       	ld	r18, Z
    1cb4:	31 81       	ldd	r19, Z+1	; 0x01
    1cb6:	89 81       	ldd	r24, Y+1	; 0x01
    1cb8:	9a 81       	ldd	r25, Y+2	; 0x02
    1cba:	82 17       	cp	r24, r18
    1cbc:	93 07       	cpc	r25, r19
    1cbe:	70 f7       	brcc	.-36     	; 0x1c9c <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1cc0:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc2:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc4:	82 81       	ldd	r24, Z+2	; 0x02
    1cc6:	93 81       	ldd	r25, Z+3	; 0x03
    1cc8:	ef 81       	ldd	r30, Y+7	; 0x07
    1cca:	f8 85       	ldd	r31, Y+8	; 0x08
    1ccc:	93 83       	std	Z+3, r25	; 0x03
    1cce:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1cd0:	ef 81       	ldd	r30, Y+7	; 0x07
    1cd2:	f8 85       	ldd	r31, Y+8	; 0x08
    1cd4:	02 80       	ldd	r0, Z+2	; 0x02
    1cd6:	f3 81       	ldd	r31, Z+3	; 0x03
    1cd8:	e0 2d       	mov	r30, r0
    1cda:	8f 81       	ldd	r24, Y+7	; 0x07
    1cdc:	98 85       	ldd	r25, Y+8	; 0x08
    1cde:	95 83       	std	Z+5, r25	; 0x05
    1ce0:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1ce2:	ef 81       	ldd	r30, Y+7	; 0x07
    1ce4:	f8 85       	ldd	r31, Y+8	; 0x08
    1ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cea:	95 83       	std	Z+5, r25	; 0x05
    1cec:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1cee:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf2:	8f 81       	ldd	r24, Y+7	; 0x07
    1cf4:	98 85       	ldd	r25, Y+8	; 0x08
    1cf6:	93 83       	std	Z+3, r25	; 0x03
    1cf8:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1cfa:	ef 81       	ldd	r30, Y+7	; 0x07
    1cfc:	f8 85       	ldd	r31, Y+8	; 0x08
    1cfe:	8d 81       	ldd	r24, Y+5	; 0x05
    1d00:	9e 81       	ldd	r25, Y+6	; 0x06
    1d02:	91 87       	std	Z+9, r25	; 0x09
    1d04:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1d06:	ed 81       	ldd	r30, Y+5	; 0x05
    1d08:	fe 81       	ldd	r31, Y+6	; 0x06
    1d0a:	80 81       	ld	r24, Z
    1d0c:	8f 5f       	subi	r24, 0xFF	; 255
    1d0e:	ed 81       	ldd	r30, Y+5	; 0x05
    1d10:	fe 81       	ldd	r31, Y+6	; 0x06
    1d12:	80 83       	st	Z, r24
}
    1d14:	28 96       	adiw	r28, 0x08	; 8
    1d16:	0f b6       	in	r0, 0x3f	; 63
    1d18:	f8 94       	cli
    1d1a:	de bf       	out	0x3e, r29	; 62
    1d1c:	0f be       	out	0x3f, r0	; 63
    1d1e:	cd bf       	out	0x3d, r28	; 61
    1d20:	cf 91       	pop	r28
    1d22:	df 91       	pop	r29
    1d24:	08 95       	ret

00001d26 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d26:	df 93       	push	r29
    1d28:	cf 93       	push	r28
    1d2a:	00 d0       	rcall	.+0      	; 0x1d2c <uxListRemove+0x6>
    1d2c:	00 d0       	rcall	.+0      	; 0x1d2e <uxListRemove+0x8>
    1d2e:	cd b7       	in	r28, 0x3d	; 61
    1d30:	de b7       	in	r29, 0x3e	; 62
    1d32:	9c 83       	std	Y+4, r25	; 0x04
    1d34:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1d36:	eb 81       	ldd	r30, Y+3	; 0x03
    1d38:	fc 81       	ldd	r31, Y+4	; 0x04
    1d3a:	80 85       	ldd	r24, Z+8	; 0x08
    1d3c:	91 85       	ldd	r25, Z+9	; 0x09
    1d3e:	9a 83       	std	Y+2, r25	; 0x02
    1d40:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d42:	eb 81       	ldd	r30, Y+3	; 0x03
    1d44:	fc 81       	ldd	r31, Y+4	; 0x04
    1d46:	a2 81       	ldd	r26, Z+2	; 0x02
    1d48:	b3 81       	ldd	r27, Z+3	; 0x03
    1d4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d4e:	84 81       	ldd	r24, Z+4	; 0x04
    1d50:	95 81       	ldd	r25, Z+5	; 0x05
    1d52:	15 96       	adiw	r26, 0x05	; 5
    1d54:	9c 93       	st	X, r25
    1d56:	8e 93       	st	-X, r24
    1d58:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d5a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d5c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d5e:	a4 81       	ldd	r26, Z+4	; 0x04
    1d60:	b5 81       	ldd	r27, Z+5	; 0x05
    1d62:	eb 81       	ldd	r30, Y+3	; 0x03
    1d64:	fc 81       	ldd	r31, Y+4	; 0x04
    1d66:	82 81       	ldd	r24, Z+2	; 0x02
    1d68:	93 81       	ldd	r25, Z+3	; 0x03
    1d6a:	13 96       	adiw	r26, 0x03	; 3
    1d6c:	9c 93       	st	X, r25
    1d6e:	8e 93       	st	-X, r24
    1d70:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1d72:	e9 81       	ldd	r30, Y+1	; 0x01
    1d74:	fa 81       	ldd	r31, Y+2	; 0x02
    1d76:	21 81       	ldd	r18, Z+1	; 0x01
    1d78:	32 81       	ldd	r19, Z+2	; 0x02
    1d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7e:	28 17       	cp	r18, r24
    1d80:	39 07       	cpc	r19, r25
    1d82:	41 f4       	brne	.+16     	; 0x1d94 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d84:	eb 81       	ldd	r30, Y+3	; 0x03
    1d86:	fc 81       	ldd	r31, Y+4	; 0x04
    1d88:	84 81       	ldd	r24, Z+4	; 0x04
    1d8a:	95 81       	ldd	r25, Z+5	; 0x05
    1d8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d90:	92 83       	std	Z+2, r25	; 0x02
    1d92:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1d94:	eb 81       	ldd	r30, Y+3	; 0x03
    1d96:	fc 81       	ldd	r31, Y+4	; 0x04
    1d98:	11 86       	std	Z+9, r1	; 0x09
    1d9a:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1d9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1da0:	80 81       	ld	r24, Z
    1da2:	81 50       	subi	r24, 0x01	; 1
    1da4:	e9 81       	ldd	r30, Y+1	; 0x01
    1da6:	fa 81       	ldd	r31, Y+2	; 0x02
    1da8:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    1daa:	e9 81       	ldd	r30, Y+1	; 0x01
    1dac:	fa 81       	ldd	r31, Y+2	; 0x02
    1dae:	80 81       	ld	r24, Z
}
    1db0:	0f 90       	pop	r0
    1db2:	0f 90       	pop	r0
    1db4:	0f 90       	pop	r0
    1db6:	0f 90       	pop	r0
    1db8:	cf 91       	pop	r28
    1dba:	df 91       	pop	r29
    1dbc:	08 95       	ret

00001dbe <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1dbe:	df 93       	push	r29
    1dc0:	cf 93       	push	r28
    1dc2:	00 d0       	rcall	.+0      	; 0x1dc4 <xQueueGenericReset+0x6>
    1dc4:	00 d0       	rcall	.+0      	; 0x1dc6 <xQueueGenericReset+0x8>
    1dc6:	00 d0       	rcall	.+0      	; 0x1dc8 <xQueueGenericReset+0xa>
    1dc8:	cd b7       	in	r28, 0x3d	; 61
    1dca:	de b7       	in	r29, 0x3e	; 62
    1dcc:	9d 83       	std	Y+5, r25	; 0x05
    1dce:	8c 83       	std	Y+4, r24	; 0x04
    1dd0:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    1dd2:	81 e0       	ldi	r24, 0x01	; 1
    1dd4:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1dd6:	8c 81       	ldd	r24, Y+4	; 0x04
    1dd8:	9d 81       	ldd	r25, Y+5	; 0x05
    1dda:	9a 83       	std	Y+2, r25	; 0x02
    1ddc:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1dde:	89 81       	ldd	r24, Y+1	; 0x01
    1de0:	9a 81       	ldd	r25, Y+2	; 0x02
    1de2:	00 97       	sbiw	r24, 0x00	; 0
    1de4:	09 f4       	brne	.+2      	; 0x1de8 <xQueueGenericReset+0x2a>
    1de6:	8b c0       	rjmp	.+278    	; 0x1efe <xQueueGenericReset+0x140>
    1de8:	e9 81       	ldd	r30, Y+1	; 0x01
    1dea:	fa 81       	ldd	r31, Y+2	; 0x02
    1dec:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dee:	88 23       	and	r24, r24
    1df0:	09 f4       	brne	.+2      	; 0x1df4 <xQueueGenericReset+0x36>
    1df2:	85 c0       	rjmp	.+266    	; 0x1efe <xQueueGenericReset+0x140>
    1df4:	e9 81       	ldd	r30, Y+1	; 0x01
    1df6:	fa 81       	ldd	r31, Y+2	; 0x02
    1df8:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dfa:	28 2f       	mov	r18, r24
    1dfc:	30 e0       	ldi	r19, 0x00	; 0
    1dfe:	8f ef       	ldi	r24, 0xFF	; 255
    1e00:	9f e7       	ldi	r25, 0x7F	; 127
    1e02:	b9 01       	movw	r22, r18
    1e04:	0e 94 a9 32 	call	0x6552	; 0x6552 <__udivmodhi4>
    1e08:	cb 01       	movw	r24, r22
    1e0a:	9c 01       	movw	r18, r24
    1e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e10:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e12:	88 2f       	mov	r24, r24
    1e14:	90 e0       	ldi	r25, 0x00	; 0
    1e16:	28 17       	cp	r18, r24
    1e18:	39 07       	cpc	r19, r25
    1e1a:	08 f4       	brcc	.+2      	; 0x1e1e <xQueueGenericReset+0x60>
    1e1c:	70 c0       	rjmp	.+224    	; 0x1efe <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1e1e:	0f b6       	in	r0, 0x3f	; 63
    1e20:	f8 94       	cli
    1e22:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e24:	e9 81       	ldd	r30, Y+1	; 0x01
    1e26:	fa 81       	ldd	r31, Y+2	; 0x02
    1e28:	40 81       	ld	r20, Z
    1e2a:	51 81       	ldd	r21, Z+1	; 0x01
    1e2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e30:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e32:	28 2f       	mov	r18, r24
    1e34:	30 e0       	ldi	r19, 0x00	; 0
    1e36:	e9 81       	ldd	r30, Y+1	; 0x01
    1e38:	fa 81       	ldd	r31, Y+2	; 0x02
    1e3a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e3c:	88 2f       	mov	r24, r24
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	bc 01       	movw	r22, r24
    1e42:	26 9f       	mul	r18, r22
    1e44:	c0 01       	movw	r24, r0
    1e46:	27 9f       	mul	r18, r23
    1e48:	90 0d       	add	r25, r0
    1e4a:	36 9f       	mul	r19, r22
    1e4c:	90 0d       	add	r25, r0
    1e4e:	11 24       	eor	r1, r1
    1e50:	84 0f       	add	r24, r20
    1e52:	95 1f       	adc	r25, r21
    1e54:	e9 81       	ldd	r30, Y+1	; 0x01
    1e56:	fa 81       	ldd	r31, Y+2	; 0x02
    1e58:	95 83       	std	Z+5, r25	; 0x05
    1e5a:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1e5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e60:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1e62:	e9 81       	ldd	r30, Y+1	; 0x01
    1e64:	fa 81       	ldd	r31, Y+2	; 0x02
    1e66:	80 81       	ld	r24, Z
    1e68:	91 81       	ldd	r25, Z+1	; 0x01
    1e6a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e6e:	93 83       	std	Z+3, r25	; 0x03
    1e70:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e72:	e9 81       	ldd	r30, Y+1	; 0x01
    1e74:	fa 81       	ldd	r31, Y+2	; 0x02
    1e76:	40 81       	ld	r20, Z
    1e78:	51 81       	ldd	r21, Z+1	; 0x01
    1e7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e7e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e80:	88 2f       	mov	r24, r24
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	9c 01       	movw	r18, r24
    1e86:	21 50       	subi	r18, 0x01	; 1
    1e88:	30 40       	sbci	r19, 0x00	; 0
    1e8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e90:	88 2f       	mov	r24, r24
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	bc 01       	movw	r22, r24
    1e96:	26 9f       	mul	r18, r22
    1e98:	c0 01       	movw	r24, r0
    1e9a:	27 9f       	mul	r18, r23
    1e9c:	90 0d       	add	r25, r0
    1e9e:	36 9f       	mul	r19, r22
    1ea0:	90 0d       	add	r25, r0
    1ea2:	11 24       	eor	r1, r1
    1ea4:	84 0f       	add	r24, r20
    1ea6:	95 1f       	adc	r25, r21
    1ea8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eaa:	fa 81       	ldd	r31, Y+2	; 0x02
    1eac:	97 83       	std	Z+7, r25	; 0x07
    1eae:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1eb0:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb2:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb4:	8f ef       	ldi	r24, 0xFF	; 255
    1eb6:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1eb8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eba:	fa 81       	ldd	r31, Y+2	; 0x02
    1ebc:	8f ef       	ldi	r24, 0xFF	; 255
    1ebe:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1ec0:	8e 81       	ldd	r24, Y+6	; 0x06
    1ec2:	88 23       	and	r24, r24
    1ec4:	79 f4       	brne	.+30     	; 0x1ee4 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ec6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eca:	80 85       	ldd	r24, Z+8	; 0x08
    1ecc:	88 23       	and	r24, r24
    1ece:	a1 f0       	breq	.+40     	; 0x1ef8 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ed0:	89 81       	ldd	r24, Y+1	; 0x01
    1ed2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ed4:	08 96       	adiw	r24, 0x08	; 8
    1ed6:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    1eda:	88 23       	and	r24, r24
    1edc:	69 f0       	breq	.+26     	; 0x1ef8 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1ede:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1ee2:	0a c0       	rjmp	.+20     	; 0x1ef8 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1ee4:	89 81       	ldd	r24, Y+1	; 0x01
    1ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee8:	08 96       	adiw	r24, 0x08	; 8
    1eea:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1eee:	89 81       	ldd	r24, Y+1	; 0x01
    1ef0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ef2:	41 96       	adiw	r24, 0x11	; 17
    1ef4:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1ef8:	0f 90       	pop	r0
    1efa:	0f be       	out	0x3f, r0	; 63
    1efc:	01 c0       	rjmp	.+2      	; 0x1f00 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    1efe:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    1f00:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1f02:	26 96       	adiw	r28, 0x06	; 6
    1f04:	0f b6       	in	r0, 0x3f	; 63
    1f06:	f8 94       	cli
    1f08:	de bf       	out	0x3e, r29	; 62
    1f0a:	0f be       	out	0x3f, r0	; 63
    1f0c:	cd bf       	out	0x3d, r28	; 61
    1f0e:	cf 91       	pop	r28
    1f10:	df 91       	pop	r29
    1f12:	08 95       	ret

00001f14 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1f14:	0f 93       	push	r16
    1f16:	1f 93       	push	r17
    1f18:	df 93       	push	r29
    1f1a:	cf 93       	push	r28
    1f1c:	cd b7       	in	r28, 0x3d	; 61
    1f1e:	de b7       	in	r29, 0x3e	; 62
    1f20:	29 97       	sbiw	r28, 0x09	; 9
    1f22:	0f b6       	in	r0, 0x3f	; 63
    1f24:	f8 94       	cli
    1f26:	de bf       	out	0x3e, r29	; 62
    1f28:	0f be       	out	0x3f, r0	; 63
    1f2a:	cd bf       	out	0x3d, r28	; 61
    1f2c:	8f 83       	std	Y+7, r24	; 0x07
    1f2e:	68 87       	std	Y+8, r22	; 0x08
    1f30:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    1f32:	1e 82       	std	Y+6, r1	; 0x06
    1f34:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1f36:	8f 81       	ldd	r24, Y+7	; 0x07
    1f38:	88 23       	and	r24, r24
    1f3a:	09 f4       	brne	.+2      	; 0x1f3e <xQueueGenericCreate+0x2a>
    1f3c:	52 c0       	rjmp	.+164    	; 0x1fe2 <xQueueGenericCreate+0xce>
    1f3e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f40:	28 2f       	mov	r18, r24
    1f42:	30 e0       	ldi	r19, 0x00	; 0
    1f44:	8f ef       	ldi	r24, 0xFF	; 255
    1f46:	9f e7       	ldi	r25, 0x7F	; 127
    1f48:	b9 01       	movw	r22, r18
    1f4a:	0e 94 a9 32 	call	0x6552	; 0x6552 <__udivmodhi4>
    1f4e:	cb 01       	movw	r24, r22
    1f50:	9c 01       	movw	r18, r24
    1f52:	88 85       	ldd	r24, Y+8	; 0x08
    1f54:	88 2f       	mov	r24, r24
    1f56:	90 e0       	ldi	r25, 0x00	; 0
    1f58:	28 17       	cp	r18, r24
    1f5a:	39 07       	cpc	r19, r25
    1f5c:	08 f4       	brcc	.+2      	; 0x1f60 <xQueueGenericCreate+0x4c>
    1f5e:	41 c0       	rjmp	.+130    	; 0x1fe2 <xQueueGenericCreate+0xce>
    1f60:	8f 81       	ldd	r24, Y+7	; 0x07
    1f62:	28 2f       	mov	r18, r24
    1f64:	30 e0       	ldi	r19, 0x00	; 0
    1f66:	88 85       	ldd	r24, Y+8	; 0x08
    1f68:	88 2f       	mov	r24, r24
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	ac 01       	movw	r20, r24
    1f6e:	24 9f       	mul	r18, r20
    1f70:	c0 01       	movw	r24, r0
    1f72:	25 9f       	mul	r18, r21
    1f74:	90 0d       	add	r25, r0
    1f76:	34 9f       	mul	r19, r20
    1f78:	90 0d       	add	r25, r0
    1f7a:	11 24       	eor	r1, r1
    1f7c:	5f e7       	ldi	r21, 0x7F	; 127
    1f7e:	81 3e       	cpi	r24, 0xE1	; 225
    1f80:	95 07       	cpc	r25, r21
    1f82:	78 f5       	brcc	.+94     	; 0x1fe2 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f84:	8f 81       	ldd	r24, Y+7	; 0x07
    1f86:	28 2f       	mov	r18, r24
    1f88:	30 e0       	ldi	r19, 0x00	; 0
    1f8a:	88 85       	ldd	r24, Y+8	; 0x08
    1f8c:	88 2f       	mov	r24, r24
    1f8e:	90 e0       	ldi	r25, 0x00	; 0
    1f90:	ac 01       	movw	r20, r24
    1f92:	24 9f       	mul	r18, r20
    1f94:	c0 01       	movw	r24, r0
    1f96:	25 9f       	mul	r18, r21
    1f98:	90 0d       	add	r25, r0
    1f9a:	34 9f       	mul	r19, r20
    1f9c:	90 0d       	add	r25, r0
    1f9e:	11 24       	eor	r1, r1
    1fa0:	9c 83       	std	Y+4, r25	; 0x04
    1fa2:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fa8:	4f 96       	adiw	r24, 0x1f	; 31
    1faa:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1fae:	9e 83       	std	Y+6, r25	; 0x06
    1fb0:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    1fb2:	8d 81       	ldd	r24, Y+5	; 0x05
    1fb4:	9e 81       	ldd	r25, Y+6	; 0x06
    1fb6:	00 97       	sbiw	r24, 0x00	; 0
    1fb8:	a1 f0       	breq	.+40     	; 0x1fe2 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1fba:	8d 81       	ldd	r24, Y+5	; 0x05
    1fbc:	9e 81       	ldd	r25, Y+6	; 0x06
    1fbe:	9a 83       	std	Y+2, r25	; 0x02
    1fc0:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1fc2:	89 81       	ldd	r24, Y+1	; 0x01
    1fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fc6:	4f 96       	adiw	r24, 0x1f	; 31
    1fc8:	9a 83       	std	Y+2, r25	; 0x02
    1fca:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1fcc:	29 81       	ldd	r18, Y+1	; 0x01
    1fce:	3a 81       	ldd	r19, Y+2	; 0x02
    1fd0:	ed 81       	ldd	r30, Y+5	; 0x05
    1fd2:	fe 81       	ldd	r31, Y+6	; 0x06
    1fd4:	8f 81       	ldd	r24, Y+7	; 0x07
    1fd6:	68 85       	ldd	r22, Y+8	; 0x08
    1fd8:	a9 01       	movw	r20, r18
    1fda:	29 85       	ldd	r18, Y+9	; 0x09
    1fdc:	8f 01       	movw	r16, r30
    1fde:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    1fe2:	8d 81       	ldd	r24, Y+5	; 0x05
    1fe4:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1fe6:	29 96       	adiw	r28, 0x09	; 9
    1fe8:	0f b6       	in	r0, 0x3f	; 63
    1fea:	f8 94       	cli
    1fec:	de bf       	out	0x3e, r29	; 62
    1fee:	0f be       	out	0x3f, r0	; 63
    1ff0:	cd bf       	out	0x3d, r28	; 61
    1ff2:	cf 91       	pop	r28
    1ff4:	df 91       	pop	r29
    1ff6:	1f 91       	pop	r17
    1ff8:	0f 91       	pop	r16
    1ffa:	08 95       	ret

00001ffc <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    1ffc:	0f 93       	push	r16
    1ffe:	1f 93       	push	r17
    2000:	df 93       	push	r29
    2002:	cf 93       	push	r28
    2004:	cd b7       	in	r28, 0x3d	; 61
    2006:	de b7       	in	r29, 0x3e	; 62
    2008:	27 97       	sbiw	r28, 0x07	; 7
    200a:	0f b6       	in	r0, 0x3f	; 63
    200c:	f8 94       	cli
    200e:	de bf       	out	0x3e, r29	; 62
    2010:	0f be       	out	0x3f, r0	; 63
    2012:	cd bf       	out	0x3d, r28	; 61
    2014:	89 83       	std	Y+1, r24	; 0x01
    2016:	6a 83       	std	Y+2, r22	; 0x02
    2018:	5c 83       	std	Y+4, r21	; 0x04
    201a:	4b 83       	std	Y+3, r20	; 0x03
    201c:	2d 83       	std	Y+5, r18	; 0x05
    201e:	1f 83       	std	Y+7, r17	; 0x07
    2020:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    2022:	8a 81       	ldd	r24, Y+2	; 0x02
    2024:	88 23       	and	r24, r24
    2026:	39 f4       	brne	.+14     	; 0x2036 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2028:	8e 81       	ldd	r24, Y+6	; 0x06
    202a:	9f 81       	ldd	r25, Y+7	; 0x07
    202c:	ee 81       	ldd	r30, Y+6	; 0x06
    202e:	ff 81       	ldd	r31, Y+7	; 0x07
    2030:	91 83       	std	Z+1, r25	; 0x01
    2032:	80 83       	st	Z, r24
    2034:	06 c0       	rjmp	.+12     	; 0x2042 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2036:	8b 81       	ldd	r24, Y+3	; 0x03
    2038:	9c 81       	ldd	r25, Y+4	; 0x04
    203a:	ee 81       	ldd	r30, Y+6	; 0x06
    203c:	ff 81       	ldd	r31, Y+7	; 0x07
    203e:	91 83       	std	Z+1, r25	; 0x01
    2040:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2042:	ee 81       	ldd	r30, Y+6	; 0x06
    2044:	ff 81       	ldd	r31, Y+7	; 0x07
    2046:	89 81       	ldd	r24, Y+1	; 0x01
    2048:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    204a:	ee 81       	ldd	r30, Y+6	; 0x06
    204c:	ff 81       	ldd	r31, Y+7	; 0x07
    204e:	8a 81       	ldd	r24, Y+2	; 0x02
    2050:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2052:	8e 81       	ldd	r24, Y+6	; 0x06
    2054:	9f 81       	ldd	r25, Y+7	; 0x07
    2056:	61 e0       	ldi	r22, 0x01	; 1
    2058:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    205c:	27 96       	adiw	r28, 0x07	; 7
    205e:	0f b6       	in	r0, 0x3f	; 63
    2060:	f8 94       	cli
    2062:	de bf       	out	0x3e, r29	; 62
    2064:	0f be       	out	0x3f, r0	; 63
    2066:	cd bf       	out	0x3d, r28	; 61
    2068:	cf 91       	pop	r28
    206a:	df 91       	pop	r29
    206c:	1f 91       	pop	r17
    206e:	0f 91       	pop	r16
    2070:	08 95       	ret

00002072 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    2072:	df 93       	push	r29
    2074:	cf 93       	push	r28
    2076:	cd b7       	in	r28, 0x3d	; 61
    2078:	de b7       	in	r29, 0x3e	; 62
    207a:	2f 97       	sbiw	r28, 0x0f	; 15
    207c:	0f b6       	in	r0, 0x3f	; 63
    207e:	f8 94       	cli
    2080:	de bf       	out	0x3e, r29	; 62
    2082:	0f be       	out	0x3f, r0	; 63
    2084:	cd bf       	out	0x3d, r28	; 61
    2086:	99 87       	std	Y+9, r25	; 0x09
    2088:	88 87       	std	Y+8, r24	; 0x08
    208a:	7b 87       	std	Y+11, r23	; 0x0b
    208c:	6a 87       	std	Y+10, r22	; 0x0a
    208e:	5d 87       	std	Y+13, r21	; 0x0d
    2090:	4c 87       	std	Y+12, r20	; 0x0c
    2092:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2094:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2096:	88 85       	ldd	r24, Y+8	; 0x08
    2098:	99 85       	ldd	r25, Y+9	; 0x09
    209a:	9a 83       	std	Y+2, r25	; 0x02
    209c:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    209e:	0f b6       	in	r0, 0x3f	; 63
    20a0:	f8 94       	cli
    20a2:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    20a4:	e9 81       	ldd	r30, Y+1	; 0x01
    20a6:	fa 81       	ldd	r31, Y+2	; 0x02
    20a8:	92 8d       	ldd	r25, Z+26	; 0x1a
    20aa:	e9 81       	ldd	r30, Y+1	; 0x01
    20ac:	fa 81       	ldd	r31, Y+2	; 0x02
    20ae:	83 8d       	ldd	r24, Z+27	; 0x1b
    20b0:	98 17       	cp	r25, r24
    20b2:	18 f0       	brcs	.+6      	; 0x20ba <xQueueGenericSend+0x48>
    20b4:	8e 85       	ldd	r24, Y+14	; 0x0e
    20b6:	82 30       	cpi	r24, 0x02	; 2
    20b8:	11 f5       	brne	.+68     	; 0x20fe <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20ba:	89 81       	ldd	r24, Y+1	; 0x01
    20bc:	9a 81       	ldd	r25, Y+2	; 0x02
    20be:	2a 85       	ldd	r18, Y+10	; 0x0a
    20c0:	3b 85       	ldd	r19, Y+11	; 0x0b
    20c2:	b9 01       	movw	r22, r18
    20c4:	4e 85       	ldd	r20, Y+14	; 0x0e
    20c6:	0e 94 8f 14 	call	0x291e	; 0x291e <prvCopyDataToQueue>
    20ca:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20cc:	e9 81       	ldd	r30, Y+1	; 0x01
    20ce:	fa 81       	ldd	r31, Y+2	; 0x02
    20d0:	81 89       	ldd	r24, Z+17	; 0x11
    20d2:	88 23       	and	r24, r24
    20d4:	51 f0       	breq	.+20     	; 0x20ea <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20d6:	89 81       	ldd	r24, Y+1	; 0x01
    20d8:	9a 81       	ldd	r25, Y+2	; 0x02
    20da:	41 96       	adiw	r24, 0x11	; 17
    20dc:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    20e0:	88 23       	and	r24, r24
    20e2:	41 f0       	breq	.+16     	; 0x20f4 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    20e4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    20e8:	05 c0       	rjmp	.+10     	; 0x20f4 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    20ea:	8b 81       	ldd	r24, Y+3	; 0x03
    20ec:	88 23       	and	r24, r24
    20ee:	11 f0       	breq	.+4      	; 0x20f4 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    20f0:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    20f4:	0f 90       	pop	r0
    20f6:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    20f8:	81 e0       	ldi	r24, 0x01	; 1
    20fa:	8f 87       	std	Y+15, r24	; 0x0f
    20fc:	5c c0       	rjmp	.+184    	; 0x21b6 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    20fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    2100:	9d 85       	ldd	r25, Y+13	; 0x0d
    2102:	00 97       	sbiw	r24, 0x00	; 0
    2104:	21 f4       	brne	.+8      	; 0x210e <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2106:	0f 90       	pop	r0
    2108:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    210a:	1f 86       	std	Y+15, r1	; 0x0f
    210c:	54 c0       	rjmp	.+168    	; 0x21b6 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    210e:	8c 81       	ldd	r24, Y+4	; 0x04
    2110:	88 23       	and	r24, r24
    2112:	31 f4       	brne	.+12     	; 0x2120 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2114:	ce 01       	movw	r24, r28
    2116:	05 96       	adiw	r24, 0x05	; 5
    2118:	0e 94 bc 22 	call	0x4578	; 0x4578 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    211c:	81 e0       	ldi	r24, 0x01	; 1
    211e:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2120:	0f 90       	pop	r0
    2122:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2124:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2128:	0f b6       	in	r0, 0x3f	; 63
    212a:	f8 94       	cli
    212c:	0f 92       	push	r0
    212e:	e9 81       	ldd	r30, Y+1	; 0x01
    2130:	fa 81       	ldd	r31, Y+2	; 0x02
    2132:	85 8d       	ldd	r24, Z+29	; 0x1d
    2134:	8f 3f       	cpi	r24, 0xFF	; 255
    2136:	19 f4       	brne	.+6      	; 0x213e <xQueueGenericSend+0xcc>
    2138:	e9 81       	ldd	r30, Y+1	; 0x01
    213a:	fa 81       	ldd	r31, Y+2	; 0x02
    213c:	15 8e       	std	Z+29, r1	; 0x1d
    213e:	e9 81       	ldd	r30, Y+1	; 0x01
    2140:	fa 81       	ldd	r31, Y+2	; 0x02
    2142:	86 8d       	ldd	r24, Z+30	; 0x1e
    2144:	8f 3f       	cpi	r24, 0xFF	; 255
    2146:	19 f4       	brne	.+6      	; 0x214e <xQueueGenericSend+0xdc>
    2148:	e9 81       	ldd	r30, Y+1	; 0x01
    214a:	fa 81       	ldd	r31, Y+2	; 0x02
    214c:	16 8e       	std	Z+30, r1	; 0x1e
    214e:	0f 90       	pop	r0
    2150:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2152:	ce 01       	movw	r24, r28
    2154:	05 96       	adiw	r24, 0x05	; 5
    2156:	9e 01       	movw	r18, r28
    2158:	24 5f       	subi	r18, 0xF4	; 244
    215a:	3f 4f       	sbci	r19, 0xFF	; 255
    215c:	b9 01       	movw	r22, r18
    215e:	0e 94 d5 22 	call	0x45aa	; 0x45aa <xTaskCheckForTimeOut>
    2162:	88 23       	and	r24, r24
    2164:	09 f5       	brne	.+66     	; 0x21a8 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2166:	89 81       	ldd	r24, Y+1	; 0x01
    2168:	9a 81       	ldd	r25, Y+2	; 0x02
    216a:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <prvIsQueueFull>
    216e:	88 23       	and	r24, r24
    2170:	a1 f0       	breq	.+40     	; 0x219a <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2172:	89 81       	ldd	r24, Y+1	; 0x01
    2174:	9a 81       	ldd	r25, Y+2	; 0x02
    2176:	08 96       	adiw	r24, 0x08	; 8
    2178:	2c 85       	ldd	r18, Y+12	; 0x0c
    217a:	3d 85       	ldd	r19, Y+13	; 0x0d
    217c:	b9 01       	movw	r22, r18
    217e:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    2182:	89 81       	ldd	r24, Y+1	; 0x01
    2184:	9a 81       	ldd	r25, Y+2	; 0x02
    2186:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    218a:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    218e:	88 23       	and	r24, r24
    2190:	09 f0       	breq	.+2      	; 0x2194 <xQueueGenericSend+0x122>
    2192:	85 cf       	rjmp	.-246    	; 0x209e <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2194:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    2198:	82 cf       	rjmp	.-252    	; 0x209e <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    219a:	89 81       	ldd	r24, Y+1	; 0x01
    219c:	9a 81       	ldd	r25, Y+2	; 0x02
    219e:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    21a2:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    21a6:	7b cf       	rjmp	.-266    	; 0x209e <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    21a8:	89 81       	ldd	r24, Y+1	; 0x01
    21aa:	9a 81       	ldd	r25, Y+2	; 0x02
    21ac:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    21b0:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    21b4:	1f 86       	std	Y+15, r1	; 0x0f
    21b6:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    21b8:	2f 96       	adiw	r28, 0x0f	; 15
    21ba:	0f b6       	in	r0, 0x3f	; 63
    21bc:	f8 94       	cli
    21be:	de bf       	out	0x3e, r29	; 62
    21c0:	0f be       	out	0x3f, r0	; 63
    21c2:	cd bf       	out	0x3d, r28	; 61
    21c4:	cf 91       	pop	r28
    21c6:	df 91       	pop	r29
    21c8:	08 95       	ret

000021ca <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    21ca:	df 93       	push	r29
    21cc:	cf 93       	push	r28
    21ce:	cd b7       	in	r28, 0x3d	; 61
    21d0:	de b7       	in	r29, 0x3e	; 62
    21d2:	2d 97       	sbiw	r28, 0x0d	; 13
    21d4:	0f b6       	in	r0, 0x3f	; 63
    21d6:	f8 94       	cli
    21d8:	de bf       	out	0x3e, r29	; 62
    21da:	0f be       	out	0x3f, r0	; 63
    21dc:	cd bf       	out	0x3d, r28	; 61
    21de:	98 87       	std	Y+8, r25	; 0x08
    21e0:	8f 83       	std	Y+7, r24	; 0x07
    21e2:	7a 87       	std	Y+10, r23	; 0x0a
    21e4:	69 87       	std	Y+9, r22	; 0x09
    21e6:	5c 87       	std	Y+12, r21	; 0x0c
    21e8:	4b 87       	std	Y+11, r20	; 0x0b
    21ea:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    21ec:	8f 81       	ldd	r24, Y+7	; 0x07
    21ee:	98 85       	ldd	r25, Y+8	; 0x08
    21f0:	9c 83       	std	Y+4, r25	; 0x04
    21f2:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21f4:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    21f6:	eb 81       	ldd	r30, Y+3	; 0x03
    21f8:	fc 81       	ldd	r31, Y+4	; 0x04
    21fa:	92 8d       	ldd	r25, Z+26	; 0x1a
    21fc:	eb 81       	ldd	r30, Y+3	; 0x03
    21fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2200:	83 8d       	ldd	r24, Z+27	; 0x1b
    2202:	98 17       	cp	r25, r24
    2204:	18 f0       	brcs	.+6      	; 0x220c <xQueueGenericSendFromISR+0x42>
    2206:	8d 85       	ldd	r24, Y+13	; 0x0d
    2208:	82 30       	cpi	r24, 0x02	; 2
    220a:	81 f5       	brne	.+96     	; 0x226c <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    220c:	eb 81       	ldd	r30, Y+3	; 0x03
    220e:	fc 81       	ldd	r31, Y+4	; 0x04
    2210:	86 8d       	ldd	r24, Z+30	; 0x1e
    2212:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2214:	eb 81       	ldd	r30, Y+3	; 0x03
    2216:	fc 81       	ldd	r31, Y+4	; 0x04
    2218:	82 8d       	ldd	r24, Z+26	; 0x1a
    221a:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    221c:	8b 81       	ldd	r24, Y+3	; 0x03
    221e:	9c 81       	ldd	r25, Y+4	; 0x04
    2220:	29 85       	ldd	r18, Y+9	; 0x09
    2222:	3a 85       	ldd	r19, Y+10	; 0x0a
    2224:	b9 01       	movw	r22, r18
    2226:	4d 85       	ldd	r20, Y+13	; 0x0d
    2228:	0e 94 8f 14 	call	0x291e	; 0x291e <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    222c:	8a 81       	ldd	r24, Y+2	; 0x02
    222e:	8f 3f       	cpi	r24, 0xFF	; 255
    2230:	a9 f4       	brne	.+42     	; 0x225c <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2232:	eb 81       	ldd	r30, Y+3	; 0x03
    2234:	fc 81       	ldd	r31, Y+4	; 0x04
    2236:	81 89       	ldd	r24, Z+17	; 0x11
    2238:	88 23       	and	r24, r24
    223a:	a9 f0       	breq	.+42     	; 0x2266 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    223c:	8b 81       	ldd	r24, Y+3	; 0x03
    223e:	9c 81       	ldd	r25, Y+4	; 0x04
    2240:	41 96       	adiw	r24, 0x11	; 17
    2242:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    2246:	88 23       	and	r24, r24
    2248:	71 f0       	breq	.+28     	; 0x2266 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    224a:	8b 85       	ldd	r24, Y+11	; 0x0b
    224c:	9c 85       	ldd	r25, Y+12	; 0x0c
    224e:	00 97       	sbiw	r24, 0x00	; 0
    2250:	51 f0       	breq	.+20     	; 0x2266 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2252:	eb 85       	ldd	r30, Y+11	; 0x0b
    2254:	fc 85       	ldd	r31, Y+12	; 0x0c
    2256:	81 e0       	ldi	r24, 0x01	; 1
    2258:	80 83       	st	Z, r24
    225a:	05 c0       	rjmp	.+10     	; 0x2266 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    225c:	8a 81       	ldd	r24, Y+2	; 0x02
    225e:	8f 5f       	subi	r24, 0xFF	; 255
    2260:	eb 81       	ldd	r30, Y+3	; 0x03
    2262:	fc 81       	ldd	r31, Y+4	; 0x04
    2264:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2266:	81 e0       	ldi	r24, 0x01	; 1
    2268:	8e 83       	std	Y+6, r24	; 0x06
    226a:	01 c0       	rjmp	.+2      	; 0x226e <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    226c:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    226e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2270:	2d 96       	adiw	r28, 0x0d	; 13
    2272:	0f b6       	in	r0, 0x3f	; 63
    2274:	f8 94       	cli
    2276:	de bf       	out	0x3e, r29	; 62
    2278:	0f be       	out	0x3f, r0	; 63
    227a:	cd bf       	out	0x3d, r28	; 61
    227c:	cf 91       	pop	r28
    227e:	df 91       	pop	r29
    2280:	08 95       	ret

00002282 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    2282:	df 93       	push	r29
    2284:	cf 93       	push	r28
    2286:	cd b7       	in	r28, 0x3d	; 61
    2288:	de b7       	in	r29, 0x3e	; 62
    228a:	2a 97       	sbiw	r28, 0x0a	; 10
    228c:	0f b6       	in	r0, 0x3f	; 63
    228e:	f8 94       	cli
    2290:	de bf       	out	0x3e, r29	; 62
    2292:	0f be       	out	0x3f, r0	; 63
    2294:	cd bf       	out	0x3d, r28	; 61
    2296:	98 87       	std	Y+8, r25	; 0x08
    2298:	8f 83       	std	Y+7, r24	; 0x07
    229a:	7a 87       	std	Y+10, r23	; 0x0a
    229c:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    229e:	8f 81       	ldd	r24, Y+7	; 0x07
    22a0:	98 85       	ldd	r25, Y+8	; 0x08
    22a2:	9c 83       	std	Y+4, r25	; 0x04
    22a4:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    22a6:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    22a8:	eb 81       	ldd	r30, Y+3	; 0x03
    22aa:	fc 81       	ldd	r31, Y+4	; 0x04
    22ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    22ae:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    22b0:	eb 81       	ldd	r30, Y+3	; 0x03
    22b2:	fc 81       	ldd	r31, Y+4	; 0x04
    22b4:	93 8d       	ldd	r25, Z+27	; 0x1b
    22b6:	8a 81       	ldd	r24, Y+2	; 0x02
    22b8:	89 17       	cp	r24, r25
    22ba:	48 f5       	brcc	.+82     	; 0x230e <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    22bc:	eb 81       	ldd	r30, Y+3	; 0x03
    22be:	fc 81       	ldd	r31, Y+4	; 0x04
    22c0:	86 8d       	ldd	r24, Z+30	; 0x1e
    22c2:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    22c4:	8a 81       	ldd	r24, Y+2	; 0x02
    22c6:	8f 5f       	subi	r24, 0xFF	; 255
    22c8:	eb 81       	ldd	r30, Y+3	; 0x03
    22ca:	fc 81       	ldd	r31, Y+4	; 0x04
    22cc:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    22ce:	89 81       	ldd	r24, Y+1	; 0x01
    22d0:	8f 3f       	cpi	r24, 0xFF	; 255
    22d2:	a9 f4       	brne	.+42     	; 0x22fe <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22d4:	eb 81       	ldd	r30, Y+3	; 0x03
    22d6:	fc 81       	ldd	r31, Y+4	; 0x04
    22d8:	81 89       	ldd	r24, Z+17	; 0x11
    22da:	88 23       	and	r24, r24
    22dc:	a9 f0       	breq	.+42     	; 0x2308 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22de:	8b 81       	ldd	r24, Y+3	; 0x03
    22e0:	9c 81       	ldd	r25, Y+4	; 0x04
    22e2:	41 96       	adiw	r24, 0x11	; 17
    22e4:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    22e8:	88 23       	and	r24, r24
    22ea:	71 f0       	breq	.+28     	; 0x2308 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    22ec:	89 85       	ldd	r24, Y+9	; 0x09
    22ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    22f0:	00 97       	sbiw	r24, 0x00	; 0
    22f2:	51 f0       	breq	.+20     	; 0x2308 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    22f4:	e9 85       	ldd	r30, Y+9	; 0x09
    22f6:	fa 85       	ldd	r31, Y+10	; 0x0a
    22f8:	81 e0       	ldi	r24, 0x01	; 1
    22fa:	80 83       	st	Z, r24
    22fc:	05 c0       	rjmp	.+10     	; 0x2308 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    22fe:	89 81       	ldd	r24, Y+1	; 0x01
    2300:	8f 5f       	subi	r24, 0xFF	; 255
    2302:	eb 81       	ldd	r30, Y+3	; 0x03
    2304:	fc 81       	ldd	r31, Y+4	; 0x04
    2306:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2308:	81 e0       	ldi	r24, 0x01	; 1
    230a:	8e 83       	std	Y+6, r24	; 0x06
    230c:	01 c0       	rjmp	.+2      	; 0x2310 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    230e:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2310:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2312:	2a 96       	adiw	r28, 0x0a	; 10
    2314:	0f b6       	in	r0, 0x3f	; 63
    2316:	f8 94       	cli
    2318:	de bf       	out	0x3e, r29	; 62
    231a:	0f be       	out	0x3f, r0	; 63
    231c:	cd bf       	out	0x3d, r28	; 61
    231e:	cf 91       	pop	r28
    2320:	df 91       	pop	r29
    2322:	08 95       	ret

00002324 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    2324:	df 93       	push	r29
    2326:	cf 93       	push	r28
    2328:	cd b7       	in	r28, 0x3d	; 61
    232a:	de b7       	in	r29, 0x3e	; 62
    232c:	2e 97       	sbiw	r28, 0x0e	; 14
    232e:	0f b6       	in	r0, 0x3f	; 63
    2330:	f8 94       	cli
    2332:	de bf       	out	0x3e, r29	; 62
    2334:	0f be       	out	0x3f, r0	; 63
    2336:	cd bf       	out	0x3d, r28	; 61
    2338:	99 87       	std	Y+9, r25	; 0x09
    233a:	88 87       	std	Y+8, r24	; 0x08
    233c:	7b 87       	std	Y+11, r23	; 0x0b
    233e:	6a 87       	std	Y+10, r22	; 0x0a
    2340:	5d 87       	std	Y+13, r21	; 0x0d
    2342:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    2344:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2346:	88 85       	ldd	r24, Y+8	; 0x08
    2348:	99 85       	ldd	r25, Y+9	; 0x09
    234a:	9b 83       	std	Y+3, r25	; 0x03
    234c:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    234e:	0f b6       	in	r0, 0x3f	; 63
    2350:	f8 94       	cli
    2352:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2354:	ea 81       	ldd	r30, Y+2	; 0x02
    2356:	fb 81       	ldd	r31, Y+3	; 0x03
    2358:	82 8d       	ldd	r24, Z+26	; 0x1a
    235a:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    235c:	89 81       	ldd	r24, Y+1	; 0x01
    235e:	88 23       	and	r24, r24
    2360:	f9 f0       	breq	.+62     	; 0x23a0 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2362:	8a 81       	ldd	r24, Y+2	; 0x02
    2364:	9b 81       	ldd	r25, Y+3	; 0x03
    2366:	2a 85       	ldd	r18, Y+10	; 0x0a
    2368:	3b 85       	ldd	r19, Y+11	; 0x0b
    236a:	b9 01       	movw	r22, r18
    236c:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2370:	89 81       	ldd	r24, Y+1	; 0x01
    2372:	81 50       	subi	r24, 0x01	; 1
    2374:	ea 81       	ldd	r30, Y+2	; 0x02
    2376:	fb 81       	ldd	r31, Y+3	; 0x03
    2378:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    237a:	ea 81       	ldd	r30, Y+2	; 0x02
    237c:	fb 81       	ldd	r31, Y+3	; 0x03
    237e:	80 85       	ldd	r24, Z+8	; 0x08
    2380:	88 23       	and	r24, r24
    2382:	49 f0       	breq	.+18     	; 0x2396 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2384:	8a 81       	ldd	r24, Y+2	; 0x02
    2386:	9b 81       	ldd	r25, Y+3	; 0x03
    2388:	08 96       	adiw	r24, 0x08	; 8
    238a:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    238e:	88 23       	and	r24, r24
    2390:	11 f0       	breq	.+4      	; 0x2396 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2392:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2396:	0f 90       	pop	r0
    2398:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    239a:	81 e0       	ldi	r24, 0x01	; 1
    239c:	8e 87       	std	Y+14, r24	; 0x0e
    239e:	63 c0       	rjmp	.+198    	; 0x2466 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    23a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    23a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    23a4:	00 97       	sbiw	r24, 0x00	; 0
    23a6:	21 f4       	brne	.+8      	; 0x23b0 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    23a8:	0f 90       	pop	r0
    23aa:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    23ac:	1e 86       	std	Y+14, r1	; 0x0e
    23ae:	5b c0       	rjmp	.+182    	; 0x2466 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    23b0:	8c 81       	ldd	r24, Y+4	; 0x04
    23b2:	88 23       	and	r24, r24
    23b4:	31 f4       	brne	.+12     	; 0x23c2 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    23b6:	ce 01       	movw	r24, r28
    23b8:	05 96       	adiw	r24, 0x05	; 5
    23ba:	0e 94 bc 22 	call	0x4578	; 0x4578 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    23be:	81 e0       	ldi	r24, 0x01	; 1
    23c0:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    23c2:	0f 90       	pop	r0
    23c4:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    23c6:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    23ca:	0f b6       	in	r0, 0x3f	; 63
    23cc:	f8 94       	cli
    23ce:	0f 92       	push	r0
    23d0:	ea 81       	ldd	r30, Y+2	; 0x02
    23d2:	fb 81       	ldd	r31, Y+3	; 0x03
    23d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    23d6:	8f 3f       	cpi	r24, 0xFF	; 255
    23d8:	19 f4       	brne	.+6      	; 0x23e0 <xQueueReceive+0xbc>
    23da:	ea 81       	ldd	r30, Y+2	; 0x02
    23dc:	fb 81       	ldd	r31, Y+3	; 0x03
    23de:	15 8e       	std	Z+29, r1	; 0x1d
    23e0:	ea 81       	ldd	r30, Y+2	; 0x02
    23e2:	fb 81       	ldd	r31, Y+3	; 0x03
    23e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    23e6:	8f 3f       	cpi	r24, 0xFF	; 255
    23e8:	19 f4       	brne	.+6      	; 0x23f0 <xQueueReceive+0xcc>
    23ea:	ea 81       	ldd	r30, Y+2	; 0x02
    23ec:	fb 81       	ldd	r31, Y+3	; 0x03
    23ee:	16 8e       	std	Z+30, r1	; 0x1e
    23f0:	0f 90       	pop	r0
    23f2:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    23f4:	ce 01       	movw	r24, r28
    23f6:	05 96       	adiw	r24, 0x05	; 5
    23f8:	9e 01       	movw	r18, r28
    23fa:	24 5f       	subi	r18, 0xF4	; 244
    23fc:	3f 4f       	sbci	r19, 0xFF	; 255
    23fe:	b9 01       	movw	r22, r18
    2400:	0e 94 d5 22 	call	0x45aa	; 0x45aa <xTaskCheckForTimeOut>
    2404:	88 23       	and	r24, r24
    2406:	09 f5       	brne	.+66     	; 0x244a <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2408:	8a 81       	ldd	r24, Y+2	; 0x02
    240a:	9b 81       	ldd	r25, Y+3	; 0x03
    240c:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvIsQueueEmpty>
    2410:	88 23       	and	r24, r24
    2412:	a1 f0       	breq	.+40     	; 0x243c <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2414:	8a 81       	ldd	r24, Y+2	; 0x02
    2416:	9b 81       	ldd	r25, Y+3	; 0x03
    2418:	41 96       	adiw	r24, 0x11	; 17
    241a:	2c 85       	ldd	r18, Y+12	; 0x0c
    241c:	3d 85       	ldd	r19, Y+13	; 0x0d
    241e:	b9 01       	movw	r22, r18
    2420:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2424:	8a 81       	ldd	r24, Y+2	; 0x02
    2426:	9b 81       	ldd	r25, Y+3	; 0x03
    2428:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    242c:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    2430:	88 23       	and	r24, r24
    2432:	09 f0       	breq	.+2      	; 0x2436 <xQueueReceive+0x112>
    2434:	8c cf       	rjmp	.-232    	; 0x234e <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    2436:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    243a:	89 cf       	rjmp	.-238    	; 0x234e <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    243c:	8a 81       	ldd	r24, Y+2	; 0x02
    243e:	9b 81       	ldd	r25, Y+3	; 0x03
    2440:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2444:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    2448:	82 cf       	rjmp	.-252    	; 0x234e <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    244a:	8a 81       	ldd	r24, Y+2	; 0x02
    244c:	9b 81       	ldd	r25, Y+3	; 0x03
    244e:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2452:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2456:	8a 81       	ldd	r24, Y+2	; 0x02
    2458:	9b 81       	ldd	r25, Y+3	; 0x03
    245a:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvIsQueueEmpty>
    245e:	88 23       	and	r24, r24
    2460:	09 f4       	brne	.+2      	; 0x2464 <xQueueReceive+0x140>
    2462:	75 cf       	rjmp	.-278    	; 0x234e <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2464:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2466:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2468:	2e 96       	adiw	r28, 0x0e	; 14
    246a:	0f b6       	in	r0, 0x3f	; 63
    246c:	f8 94       	cli
    246e:	de bf       	out	0x3e, r29	; 62
    2470:	0f be       	out	0x3f, r0	; 63
    2472:	cd bf       	out	0x3d, r28	; 61
    2474:	cf 91       	pop	r28
    2476:	df 91       	pop	r29
    2478:	08 95       	ret

0000247a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    247a:	df 93       	push	r29
    247c:	cf 93       	push	r28
    247e:	cd b7       	in	r28, 0x3d	; 61
    2480:	de b7       	in	r29, 0x3e	; 62
    2482:	2c 97       	sbiw	r28, 0x0c	; 12
    2484:	0f b6       	in	r0, 0x3f	; 63
    2486:	f8 94       	cli
    2488:	de bf       	out	0x3e, r29	; 62
    248a:	0f be       	out	0x3f, r0	; 63
    248c:	cd bf       	out	0x3d, r28	; 61
    248e:	99 87       	std	Y+9, r25	; 0x09
    2490:	88 87       	std	Y+8, r24	; 0x08
    2492:	7b 87       	std	Y+11, r23	; 0x0b
    2494:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2496:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2498:	88 85       	ldd	r24, Y+8	; 0x08
    249a:	99 85       	ldd	r25, Y+9	; 0x09
    249c:	9b 83       	std	Y+3, r25	; 0x03
    249e:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    24a0:	0f b6       	in	r0, 0x3f	; 63
    24a2:	f8 94       	cli
    24a4:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    24a6:	ea 81       	ldd	r30, Y+2	; 0x02
    24a8:	fb 81       	ldd	r31, Y+3	; 0x03
    24aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    24ac:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    24ae:	89 81       	ldd	r24, Y+1	; 0x01
    24b0:	88 23       	and	r24, r24
    24b2:	c1 f0       	breq	.+48     	; 0x24e4 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    24b4:	89 81       	ldd	r24, Y+1	; 0x01
    24b6:	81 50       	subi	r24, 0x01	; 1
    24b8:	ea 81       	ldd	r30, Y+2	; 0x02
    24ba:	fb 81       	ldd	r31, Y+3	; 0x03
    24bc:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24be:	ea 81       	ldd	r30, Y+2	; 0x02
    24c0:	fb 81       	ldd	r31, Y+3	; 0x03
    24c2:	80 85       	ldd	r24, Z+8	; 0x08
    24c4:	88 23       	and	r24, r24
    24c6:	49 f0       	breq	.+18     	; 0x24da <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24c8:	8a 81       	ldd	r24, Y+2	; 0x02
    24ca:	9b 81       	ldd	r25, Y+3	; 0x03
    24cc:	08 96       	adiw	r24, 0x08	; 8
    24ce:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    24d2:	88 23       	and	r24, r24
    24d4:	11 f0       	breq	.+4      	; 0x24da <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    24d6:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    24da:	0f 90       	pop	r0
    24dc:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    24de:	81 e0       	ldi	r24, 0x01	; 1
    24e0:	8c 87       	std	Y+12, r24	; 0x0c
    24e2:	63 c0       	rjmp	.+198    	; 0x25aa <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    24e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    24e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    24e8:	00 97       	sbiw	r24, 0x00	; 0
    24ea:	21 f4       	brne	.+8      	; 0x24f4 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    24ec:	0f 90       	pop	r0
    24ee:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    24f0:	1c 86       	std	Y+12, r1	; 0x0c
    24f2:	5b c0       	rjmp	.+182    	; 0x25aa <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    24f4:	8c 81       	ldd	r24, Y+4	; 0x04
    24f6:	88 23       	and	r24, r24
    24f8:	31 f4       	brne	.+12     	; 0x2506 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    24fa:	ce 01       	movw	r24, r28
    24fc:	05 96       	adiw	r24, 0x05	; 5
    24fe:	0e 94 bc 22 	call	0x4578	; 0x4578 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2502:	81 e0       	ldi	r24, 0x01	; 1
    2504:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2506:	0f 90       	pop	r0
    2508:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    250a:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    250e:	0f b6       	in	r0, 0x3f	; 63
    2510:	f8 94       	cli
    2512:	0f 92       	push	r0
    2514:	ea 81       	ldd	r30, Y+2	; 0x02
    2516:	fb 81       	ldd	r31, Y+3	; 0x03
    2518:	85 8d       	ldd	r24, Z+29	; 0x1d
    251a:	8f 3f       	cpi	r24, 0xFF	; 255
    251c:	19 f4       	brne	.+6      	; 0x2524 <xQueueSemaphoreTake+0xaa>
    251e:	ea 81       	ldd	r30, Y+2	; 0x02
    2520:	fb 81       	ldd	r31, Y+3	; 0x03
    2522:	15 8e       	std	Z+29, r1	; 0x1d
    2524:	ea 81       	ldd	r30, Y+2	; 0x02
    2526:	fb 81       	ldd	r31, Y+3	; 0x03
    2528:	86 8d       	ldd	r24, Z+30	; 0x1e
    252a:	8f 3f       	cpi	r24, 0xFF	; 255
    252c:	19 f4       	brne	.+6      	; 0x2534 <xQueueSemaphoreTake+0xba>
    252e:	ea 81       	ldd	r30, Y+2	; 0x02
    2530:	fb 81       	ldd	r31, Y+3	; 0x03
    2532:	16 8e       	std	Z+30, r1	; 0x1e
    2534:	0f 90       	pop	r0
    2536:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2538:	ce 01       	movw	r24, r28
    253a:	05 96       	adiw	r24, 0x05	; 5
    253c:	9e 01       	movw	r18, r28
    253e:	26 5f       	subi	r18, 0xF6	; 246
    2540:	3f 4f       	sbci	r19, 0xFF	; 255
    2542:	b9 01       	movw	r22, r18
    2544:	0e 94 d5 22 	call	0x45aa	; 0x45aa <xTaskCheckForTimeOut>
    2548:	88 23       	and	r24, r24
    254a:	09 f5       	brne	.+66     	; 0x258e <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    254c:	8a 81       	ldd	r24, Y+2	; 0x02
    254e:	9b 81       	ldd	r25, Y+3	; 0x03
    2550:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvIsQueueEmpty>
    2554:	88 23       	and	r24, r24
    2556:	a1 f0       	breq	.+40     	; 0x2580 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2558:	8a 81       	ldd	r24, Y+2	; 0x02
    255a:	9b 81       	ldd	r25, Y+3	; 0x03
    255c:	41 96       	adiw	r24, 0x11	; 17
    255e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2560:	3b 85       	ldd	r19, Y+11	; 0x0b
    2562:	b9 01       	movw	r22, r18
    2564:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2568:	8a 81       	ldd	r24, Y+2	; 0x02
    256a:	9b 81       	ldd	r25, Y+3	; 0x03
    256c:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2570:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    2574:	88 23       	and	r24, r24
    2576:	09 f0       	breq	.+2      	; 0x257a <xQueueSemaphoreTake+0x100>
    2578:	93 cf       	rjmp	.-218    	; 0x24a0 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    257a:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    257e:	90 cf       	rjmp	.-224    	; 0x24a0 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2580:	8a 81       	ldd	r24, Y+2	; 0x02
    2582:	9b 81       	ldd	r25, Y+3	; 0x03
    2584:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2588:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    258c:	89 cf       	rjmp	.-238    	; 0x24a0 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    258e:	8a 81       	ldd	r24, Y+2	; 0x02
    2590:	9b 81       	ldd	r25, Y+3	; 0x03
    2592:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2596:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    259a:	8a 81       	ldd	r24, Y+2	; 0x02
    259c:	9b 81       	ldd	r25, Y+3	; 0x03
    259e:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvIsQueueEmpty>
    25a2:	88 23       	and	r24, r24
    25a4:	09 f4       	brne	.+2      	; 0x25a8 <xQueueSemaphoreTake+0x12e>
    25a6:	7c cf       	rjmp	.-264    	; 0x24a0 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    25a8:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    25aa:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    25ac:	2c 96       	adiw	r28, 0x0c	; 12
    25ae:	0f b6       	in	r0, 0x3f	; 63
    25b0:	f8 94       	cli
    25b2:	de bf       	out	0x3e, r29	; 62
    25b4:	0f be       	out	0x3f, r0	; 63
    25b6:	cd bf       	out	0x3d, r28	; 61
    25b8:	cf 91       	pop	r28
    25ba:	df 91       	pop	r29
    25bc:	08 95       	ret

000025be <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    25be:	df 93       	push	r29
    25c0:	cf 93       	push	r28
    25c2:	cd b7       	in	r28, 0x3d	; 61
    25c4:	de b7       	in	r29, 0x3e	; 62
    25c6:	60 97       	sbiw	r28, 0x10	; 16
    25c8:	0f b6       	in	r0, 0x3f	; 63
    25ca:	f8 94       	cli
    25cc:	de bf       	out	0x3e, r29	; 62
    25ce:	0f be       	out	0x3f, r0	; 63
    25d0:	cd bf       	out	0x3d, r28	; 61
    25d2:	9b 87       	std	Y+11, r25	; 0x0b
    25d4:	8a 87       	std	Y+10, r24	; 0x0a
    25d6:	7d 87       	std	Y+13, r23	; 0x0d
    25d8:	6c 87       	std	Y+12, r22	; 0x0c
    25da:	5f 87       	std	Y+15, r21	; 0x0f
    25dc:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    25de:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    25e0:	8a 85       	ldd	r24, Y+10	; 0x0a
    25e2:	9b 85       	ldd	r25, Y+11	; 0x0b
    25e4:	9b 83       	std	Y+3, r25	; 0x03
    25e6:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    25e8:	0f b6       	in	r0, 0x3f	; 63
    25ea:	f8 94       	cli
    25ec:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    25ee:	ea 81       	ldd	r30, Y+2	; 0x02
    25f0:	fb 81       	ldd	r31, Y+3	; 0x03
    25f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    25f4:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    25f6:	89 81       	ldd	r24, Y+1	; 0x01
    25f8:	88 23       	and	r24, r24
    25fa:	31 f1       	breq	.+76     	; 0x2648 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    25fc:	ea 81       	ldd	r30, Y+2	; 0x02
    25fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2600:	86 81       	ldd	r24, Z+6	; 0x06
    2602:	97 81       	ldd	r25, Z+7	; 0x07
    2604:	9d 83       	std	Y+5, r25	; 0x05
    2606:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2608:	8a 81       	ldd	r24, Y+2	; 0x02
    260a:	9b 81       	ldd	r25, Y+3	; 0x03
    260c:	2c 85       	ldd	r18, Y+12	; 0x0c
    260e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2610:	b9 01       	movw	r22, r18
    2612:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2616:	ea 81       	ldd	r30, Y+2	; 0x02
    2618:	fb 81       	ldd	r31, Y+3	; 0x03
    261a:	8c 81       	ldd	r24, Y+4	; 0x04
    261c:	9d 81       	ldd	r25, Y+5	; 0x05
    261e:	97 83       	std	Z+7, r25	; 0x07
    2620:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2622:	ea 81       	ldd	r30, Y+2	; 0x02
    2624:	fb 81       	ldd	r31, Y+3	; 0x03
    2626:	81 89       	ldd	r24, Z+17	; 0x11
    2628:	88 23       	and	r24, r24
    262a:	49 f0       	breq	.+18     	; 0x263e <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    262c:	8a 81       	ldd	r24, Y+2	; 0x02
    262e:	9b 81       	ldd	r25, Y+3	; 0x03
    2630:	41 96       	adiw	r24, 0x11	; 17
    2632:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    2636:	88 23       	and	r24, r24
    2638:	11 f0       	breq	.+4      	; 0x263e <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    263a:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    263e:	0f 90       	pop	r0
    2640:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2642:	81 e0       	ldi	r24, 0x01	; 1
    2644:	88 8b       	std	Y+16, r24	; 0x10
    2646:	63 c0       	rjmp	.+198    	; 0x270e <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2648:	8e 85       	ldd	r24, Y+14	; 0x0e
    264a:	9f 85       	ldd	r25, Y+15	; 0x0f
    264c:	00 97       	sbiw	r24, 0x00	; 0
    264e:	21 f4       	brne	.+8      	; 0x2658 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2650:	0f 90       	pop	r0
    2652:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2654:	18 8a       	std	Y+16, r1	; 0x10
    2656:	5b c0       	rjmp	.+182    	; 0x270e <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2658:	8e 81       	ldd	r24, Y+6	; 0x06
    265a:	88 23       	and	r24, r24
    265c:	31 f4       	brne	.+12     	; 0x266a <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    265e:	ce 01       	movw	r24, r28
    2660:	07 96       	adiw	r24, 0x07	; 7
    2662:	0e 94 bc 22 	call	0x4578	; 0x4578 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2666:	81 e0       	ldi	r24, 0x01	; 1
    2668:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    266a:	0f 90       	pop	r0
    266c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    266e:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2672:	0f b6       	in	r0, 0x3f	; 63
    2674:	f8 94       	cli
    2676:	0f 92       	push	r0
    2678:	ea 81       	ldd	r30, Y+2	; 0x02
    267a:	fb 81       	ldd	r31, Y+3	; 0x03
    267c:	85 8d       	ldd	r24, Z+29	; 0x1d
    267e:	8f 3f       	cpi	r24, 0xFF	; 255
    2680:	19 f4       	brne	.+6      	; 0x2688 <xQueuePeek+0xca>
    2682:	ea 81       	ldd	r30, Y+2	; 0x02
    2684:	fb 81       	ldd	r31, Y+3	; 0x03
    2686:	15 8e       	std	Z+29, r1	; 0x1d
    2688:	ea 81       	ldd	r30, Y+2	; 0x02
    268a:	fb 81       	ldd	r31, Y+3	; 0x03
    268c:	86 8d       	ldd	r24, Z+30	; 0x1e
    268e:	8f 3f       	cpi	r24, 0xFF	; 255
    2690:	19 f4       	brne	.+6      	; 0x2698 <xQueuePeek+0xda>
    2692:	ea 81       	ldd	r30, Y+2	; 0x02
    2694:	fb 81       	ldd	r31, Y+3	; 0x03
    2696:	16 8e       	std	Z+30, r1	; 0x1e
    2698:	0f 90       	pop	r0
    269a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    269c:	ce 01       	movw	r24, r28
    269e:	07 96       	adiw	r24, 0x07	; 7
    26a0:	9e 01       	movw	r18, r28
    26a2:	22 5f       	subi	r18, 0xF2	; 242
    26a4:	3f 4f       	sbci	r19, 0xFF	; 255
    26a6:	b9 01       	movw	r22, r18
    26a8:	0e 94 d5 22 	call	0x45aa	; 0x45aa <xTaskCheckForTimeOut>
    26ac:	88 23       	and	r24, r24
    26ae:	09 f5       	brne	.+66     	; 0x26f2 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    26b0:	8a 81       	ldd	r24, Y+2	; 0x02
    26b2:	9b 81       	ldd	r25, Y+3	; 0x03
    26b4:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvIsQueueEmpty>
    26b8:	88 23       	and	r24, r24
    26ba:	a1 f0       	breq	.+40     	; 0x26e4 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    26bc:	8a 81       	ldd	r24, Y+2	; 0x02
    26be:	9b 81       	ldd	r25, Y+3	; 0x03
    26c0:	41 96       	adiw	r24, 0x11	; 17
    26c2:	2e 85       	ldd	r18, Y+14	; 0x0e
    26c4:	3f 85       	ldd	r19, Y+15	; 0x0f
    26c6:	b9 01       	movw	r22, r18
    26c8:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    26cc:	8a 81       	ldd	r24, Y+2	; 0x02
    26ce:	9b 81       	ldd	r25, Y+3	; 0x03
    26d0:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    26d4:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    26d8:	88 23       	and	r24, r24
    26da:	09 f0       	breq	.+2      	; 0x26de <xQueuePeek+0x120>
    26dc:	85 cf       	rjmp	.-246    	; 0x25e8 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    26de:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    26e2:	82 cf       	rjmp	.-252    	; 0x25e8 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    26e4:	8a 81       	ldd	r24, Y+2	; 0x02
    26e6:	9b 81       	ldd	r25, Y+3	; 0x03
    26e8:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    26ec:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    26f0:	7b cf       	rjmp	.-266    	; 0x25e8 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    26f2:	8a 81       	ldd	r24, Y+2	; 0x02
    26f4:	9b 81       	ldd	r25, Y+3	; 0x03
    26f6:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    26fa:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    26fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2700:	9b 81       	ldd	r25, Y+3	; 0x03
    2702:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvIsQueueEmpty>
    2706:	88 23       	and	r24, r24
    2708:	09 f4       	brne	.+2      	; 0x270c <xQueuePeek+0x14e>
    270a:	6e cf       	rjmp	.-292    	; 0x25e8 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    270c:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    270e:	88 89       	ldd	r24, Y+16	; 0x10
}
    2710:	60 96       	adiw	r28, 0x10	; 16
    2712:	0f b6       	in	r0, 0x3f	; 63
    2714:	f8 94       	cli
    2716:	de bf       	out	0x3e, r29	; 62
    2718:	0f be       	out	0x3f, r0	; 63
    271a:	cd bf       	out	0x3d, r28	; 61
    271c:	cf 91       	pop	r28
    271e:	df 91       	pop	r29
    2720:	08 95       	ret

00002722 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2722:	df 93       	push	r29
    2724:	cf 93       	push	r28
    2726:	cd b7       	in	r28, 0x3d	; 61
    2728:	de b7       	in	r29, 0x3e	; 62
    272a:	2c 97       	sbiw	r28, 0x0c	; 12
    272c:	0f b6       	in	r0, 0x3f	; 63
    272e:	f8 94       	cli
    2730:	de bf       	out	0x3e, r29	; 62
    2732:	0f be       	out	0x3f, r0	; 63
    2734:	cd bf       	out	0x3d, r28	; 61
    2736:	98 87       	std	Y+8, r25	; 0x08
    2738:	8f 83       	std	Y+7, r24	; 0x07
    273a:	7a 87       	std	Y+10, r23	; 0x0a
    273c:	69 87       	std	Y+9, r22	; 0x09
    273e:	5c 87       	std	Y+12, r21	; 0x0c
    2740:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2742:	8f 81       	ldd	r24, Y+7	; 0x07
    2744:	98 85       	ldd	r25, Y+8	; 0x08
    2746:	9c 83       	std	Y+4, r25	; 0x04
    2748:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    274a:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    274c:	eb 81       	ldd	r30, Y+3	; 0x03
    274e:	fc 81       	ldd	r31, Y+4	; 0x04
    2750:	82 8d       	ldd	r24, Z+26	; 0x1a
    2752:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2754:	8a 81       	ldd	r24, Y+2	; 0x02
    2756:	88 23       	and	r24, r24
    2758:	81 f1       	breq	.+96     	; 0x27ba <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    275a:	eb 81       	ldd	r30, Y+3	; 0x03
    275c:	fc 81       	ldd	r31, Y+4	; 0x04
    275e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2760:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2762:	8b 81       	ldd	r24, Y+3	; 0x03
    2764:	9c 81       	ldd	r25, Y+4	; 0x04
    2766:	29 85       	ldd	r18, Y+9	; 0x09
    2768:	3a 85       	ldd	r19, Y+10	; 0x0a
    276a:	b9 01       	movw	r22, r18
    276c:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2770:	8a 81       	ldd	r24, Y+2	; 0x02
    2772:	81 50       	subi	r24, 0x01	; 1
    2774:	eb 81       	ldd	r30, Y+3	; 0x03
    2776:	fc 81       	ldd	r31, Y+4	; 0x04
    2778:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    277a:	89 81       	ldd	r24, Y+1	; 0x01
    277c:	8f 3f       	cpi	r24, 0xFF	; 255
    277e:	a9 f4       	brne	.+42     	; 0x27aa <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2780:	eb 81       	ldd	r30, Y+3	; 0x03
    2782:	fc 81       	ldd	r31, Y+4	; 0x04
    2784:	80 85       	ldd	r24, Z+8	; 0x08
    2786:	88 23       	and	r24, r24
    2788:	a9 f0       	breq	.+42     	; 0x27b4 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    278a:	8b 81       	ldd	r24, Y+3	; 0x03
    278c:	9c 81       	ldd	r25, Y+4	; 0x04
    278e:	08 96       	adiw	r24, 0x08	; 8
    2790:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    2794:	88 23       	and	r24, r24
    2796:	71 f0       	breq	.+28     	; 0x27b4 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2798:	8b 85       	ldd	r24, Y+11	; 0x0b
    279a:	9c 85       	ldd	r25, Y+12	; 0x0c
    279c:	00 97       	sbiw	r24, 0x00	; 0
    279e:	51 f0       	breq	.+20     	; 0x27b4 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    27a0:	eb 85       	ldd	r30, Y+11	; 0x0b
    27a2:	fc 85       	ldd	r31, Y+12	; 0x0c
    27a4:	81 e0       	ldi	r24, 0x01	; 1
    27a6:	80 83       	st	Z, r24
    27a8:	05 c0       	rjmp	.+10     	; 0x27b4 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    27aa:	89 81       	ldd	r24, Y+1	; 0x01
    27ac:	8f 5f       	subi	r24, 0xFF	; 255
    27ae:	eb 81       	ldd	r30, Y+3	; 0x03
    27b0:	fc 81       	ldd	r31, Y+4	; 0x04
    27b2:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    27b4:	81 e0       	ldi	r24, 0x01	; 1
    27b6:	8e 83       	std	Y+6, r24	; 0x06
    27b8:	01 c0       	rjmp	.+2      	; 0x27bc <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    27ba:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    27bc:	8e 81       	ldd	r24, Y+6	; 0x06
}
    27be:	2c 96       	adiw	r28, 0x0c	; 12
    27c0:	0f b6       	in	r0, 0x3f	; 63
    27c2:	f8 94       	cli
    27c4:	de bf       	out	0x3e, r29	; 62
    27c6:	0f be       	out	0x3f, r0	; 63
    27c8:	cd bf       	out	0x3d, r28	; 61
    27ca:	cf 91       	pop	r28
    27cc:	df 91       	pop	r29
    27ce:	08 95       	ret

000027d0 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    27d0:	df 93       	push	r29
    27d2:	cf 93       	push	r28
    27d4:	cd b7       	in	r28, 0x3d	; 61
    27d6:	de b7       	in	r29, 0x3e	; 62
    27d8:	2a 97       	sbiw	r28, 0x0a	; 10
    27da:	0f b6       	in	r0, 0x3f	; 63
    27dc:	f8 94       	cli
    27de:	de bf       	out	0x3e, r29	; 62
    27e0:	0f be       	out	0x3f, r0	; 63
    27e2:	cd bf       	out	0x3d, r28	; 61
    27e4:	98 87       	std	Y+8, r25	; 0x08
    27e6:	8f 83       	std	Y+7, r24	; 0x07
    27e8:	7a 87       	std	Y+10, r23	; 0x0a
    27ea:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    27ec:	8f 81       	ldd	r24, Y+7	; 0x07
    27ee:	98 85       	ldd	r25, Y+8	; 0x08
    27f0:	9a 83       	std	Y+2, r25	; 0x02
    27f2:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    27f4:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    27f6:	e9 81       	ldd	r30, Y+1	; 0x01
    27f8:	fa 81       	ldd	r31, Y+2	; 0x02
    27fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    27fc:	88 23       	and	r24, r24
    27fe:	b1 f0       	breq	.+44     	; 0x282c <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2800:	e9 81       	ldd	r30, Y+1	; 0x01
    2802:	fa 81       	ldd	r31, Y+2	; 0x02
    2804:	86 81       	ldd	r24, Z+6	; 0x06
    2806:	97 81       	ldd	r25, Z+7	; 0x07
    2808:	9c 83       	std	Y+4, r25	; 0x04
    280a:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    280c:	89 81       	ldd	r24, Y+1	; 0x01
    280e:	9a 81       	ldd	r25, Y+2	; 0x02
    2810:	29 85       	ldd	r18, Y+9	; 0x09
    2812:	3a 85       	ldd	r19, Y+10	; 0x0a
    2814:	b9 01       	movw	r22, r18
    2816:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    281a:	e9 81       	ldd	r30, Y+1	; 0x01
    281c:	fa 81       	ldd	r31, Y+2	; 0x02
    281e:	8b 81       	ldd	r24, Y+3	; 0x03
    2820:	9c 81       	ldd	r25, Y+4	; 0x04
    2822:	97 83       	std	Z+7, r25	; 0x07
    2824:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2826:	81 e0       	ldi	r24, 0x01	; 1
    2828:	8e 83       	std	Y+6, r24	; 0x06
    282a:	01 c0       	rjmp	.+2      	; 0x282e <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    282c:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    282e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2830:	2a 96       	adiw	r28, 0x0a	; 10
    2832:	0f b6       	in	r0, 0x3f	; 63
    2834:	f8 94       	cli
    2836:	de bf       	out	0x3e, r29	; 62
    2838:	0f be       	out	0x3f, r0	; 63
    283a:	cd bf       	out	0x3d, r28	; 61
    283c:	cf 91       	pop	r28
    283e:	df 91       	pop	r29
    2840:	08 95       	ret

00002842 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2842:	df 93       	push	r29
    2844:	cf 93       	push	r28
    2846:	00 d0       	rcall	.+0      	; 0x2848 <uxQueueMessagesWaiting+0x6>
    2848:	0f 92       	push	r0
    284a:	cd b7       	in	r28, 0x3d	; 61
    284c:	de b7       	in	r29, 0x3e	; 62
    284e:	9b 83       	std	Y+3, r25	; 0x03
    2850:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    2852:	0f b6       	in	r0, 0x3f	; 63
    2854:	f8 94       	cli
    2856:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2858:	ea 81       	ldd	r30, Y+2	; 0x02
    285a:	fb 81       	ldd	r31, Y+3	; 0x03
    285c:	82 8d       	ldd	r24, Z+26	; 0x1a
    285e:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2860:	0f 90       	pop	r0
    2862:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2864:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2866:	0f 90       	pop	r0
    2868:	0f 90       	pop	r0
    286a:	0f 90       	pop	r0
    286c:	cf 91       	pop	r28
    286e:	df 91       	pop	r29
    2870:	08 95       	ret

00002872 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2872:	df 93       	push	r29
    2874:	cf 93       	push	r28
    2876:	00 d0       	rcall	.+0      	; 0x2878 <uxQueueSpacesAvailable+0x6>
    2878:	00 d0       	rcall	.+0      	; 0x287a <uxQueueSpacesAvailable+0x8>
    287a:	0f 92       	push	r0
    287c:	cd b7       	in	r28, 0x3d	; 61
    287e:	de b7       	in	r29, 0x3e	; 62
    2880:	9d 83       	std	Y+5, r25	; 0x05
    2882:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2884:	8c 81       	ldd	r24, Y+4	; 0x04
    2886:	9d 81       	ldd	r25, Y+5	; 0x05
    2888:	9a 83       	std	Y+2, r25	; 0x02
    288a:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    288c:	0f b6       	in	r0, 0x3f	; 63
    288e:	f8 94       	cli
    2890:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2892:	e9 81       	ldd	r30, Y+1	; 0x01
    2894:	fa 81       	ldd	r31, Y+2	; 0x02
    2896:	93 8d       	ldd	r25, Z+27	; 0x1b
    2898:	e9 81       	ldd	r30, Y+1	; 0x01
    289a:	fa 81       	ldd	r31, Y+2	; 0x02
    289c:	82 8d       	ldd	r24, Z+26	; 0x1a
    289e:	29 2f       	mov	r18, r25
    28a0:	28 1b       	sub	r18, r24
    28a2:	82 2f       	mov	r24, r18
    28a4:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    28a6:	0f 90       	pop	r0
    28a8:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    28aa:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    28ac:	0f 90       	pop	r0
    28ae:	0f 90       	pop	r0
    28b0:	0f 90       	pop	r0
    28b2:	0f 90       	pop	r0
    28b4:	0f 90       	pop	r0
    28b6:	cf 91       	pop	r28
    28b8:	df 91       	pop	r29
    28ba:	08 95       	ret

000028bc <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    28bc:	df 93       	push	r29
    28be:	cf 93       	push	r28
    28c0:	00 d0       	rcall	.+0      	; 0x28c2 <uxQueueMessagesWaitingFromISR+0x6>
    28c2:	00 d0       	rcall	.+0      	; 0x28c4 <uxQueueMessagesWaitingFromISR+0x8>
    28c4:	0f 92       	push	r0
    28c6:	cd b7       	in	r28, 0x3d	; 61
    28c8:	de b7       	in	r29, 0x3e	; 62
    28ca:	9d 83       	std	Y+5, r25	; 0x05
    28cc:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    28ce:	8c 81       	ldd	r24, Y+4	; 0x04
    28d0:	9d 81       	ldd	r25, Y+5	; 0x05
    28d2:	9a 83       	std	Y+2, r25	; 0x02
    28d4:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    28d6:	e9 81       	ldd	r30, Y+1	; 0x01
    28d8:	fa 81       	ldd	r31, Y+2	; 0x02
    28da:	82 8d       	ldd	r24, Z+26	; 0x1a
    28dc:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    28de:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    28e0:	0f 90       	pop	r0
    28e2:	0f 90       	pop	r0
    28e4:	0f 90       	pop	r0
    28e6:	0f 90       	pop	r0
    28e8:	0f 90       	pop	r0
    28ea:	cf 91       	pop	r28
    28ec:	df 91       	pop	r29
    28ee:	08 95       	ret

000028f0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    28f0:	df 93       	push	r29
    28f2:	cf 93       	push	r28
    28f4:	00 d0       	rcall	.+0      	; 0x28f6 <vQueueDelete+0x6>
    28f6:	00 d0       	rcall	.+0      	; 0x28f8 <vQueueDelete+0x8>
    28f8:	cd b7       	in	r28, 0x3d	; 61
    28fa:	de b7       	in	r29, 0x3e	; 62
    28fc:	9c 83       	std	Y+4, r25	; 0x04
    28fe:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    2900:	8b 81       	ldd	r24, Y+3	; 0x03
    2902:	9c 81       	ldd	r25, Y+4	; 0x04
    2904:	9a 83       	std	Y+2, r25	; 0x02
    2906:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2908:	89 81       	ldd	r24, Y+1	; 0x01
    290a:	9a 81       	ldd	r25, Y+2	; 0x02
    290c:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2910:	0f 90       	pop	r0
    2912:	0f 90       	pop	r0
    2914:	0f 90       	pop	r0
    2916:	0f 90       	pop	r0
    2918:	cf 91       	pop	r28
    291a:	df 91       	pop	r29
    291c:	08 95       	ret

0000291e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    291e:	df 93       	push	r29
    2920:	cf 93       	push	r28
    2922:	cd b7       	in	r28, 0x3d	; 61
    2924:	de b7       	in	r29, 0x3e	; 62
    2926:	27 97       	sbiw	r28, 0x07	; 7
    2928:	0f b6       	in	r0, 0x3f	; 63
    292a:	f8 94       	cli
    292c:	de bf       	out	0x3e, r29	; 62
    292e:	0f be       	out	0x3f, r0	; 63
    2930:	cd bf       	out	0x3d, r28	; 61
    2932:	9c 83       	std	Y+4, r25	; 0x04
    2934:	8b 83       	std	Y+3, r24	; 0x03
    2936:	7e 83       	std	Y+6, r23	; 0x06
    2938:	6d 83       	std	Y+5, r22	; 0x05
    293a:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    293c:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    293e:	eb 81       	ldd	r30, Y+3	; 0x03
    2940:	fc 81       	ldd	r31, Y+4	; 0x04
    2942:	82 8d       	ldd	r24, Z+26	; 0x1a
    2944:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2946:	eb 81       	ldd	r30, Y+3	; 0x03
    2948:	fc 81       	ldd	r31, Y+4	; 0x04
    294a:	84 8d       	ldd	r24, Z+28	; 0x1c
    294c:	88 23       	and	r24, r24
    294e:	09 f4       	brne	.+2      	; 0x2952 <prvCopyDataToQueue+0x34>
    2950:	7d c0       	rjmp	.+250    	; 0x2a4c <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    2952:	8f 81       	ldd	r24, Y+7	; 0x07
    2954:	88 23       	and	r24, r24
    2956:	99 f5       	brne	.+102    	; 0x29be <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2958:	eb 81       	ldd	r30, Y+3	; 0x03
    295a:	fc 81       	ldd	r31, Y+4	; 0x04
    295c:	62 81       	ldd	r22, Z+2	; 0x02
    295e:	73 81       	ldd	r23, Z+3	; 0x03
    2960:	eb 81       	ldd	r30, Y+3	; 0x03
    2962:	fc 81       	ldd	r31, Y+4	; 0x04
    2964:	84 8d       	ldd	r24, Z+28	; 0x1c
    2966:	48 2f       	mov	r20, r24
    2968:	50 e0       	ldi	r21, 0x00	; 0
    296a:	2d 81       	ldd	r18, Y+5	; 0x05
    296c:	3e 81       	ldd	r19, Y+6	; 0x06
    296e:	cb 01       	movw	r24, r22
    2970:	b9 01       	movw	r22, r18
    2972:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2976:	eb 81       	ldd	r30, Y+3	; 0x03
    2978:	fc 81       	ldd	r31, Y+4	; 0x04
    297a:	22 81       	ldd	r18, Z+2	; 0x02
    297c:	33 81       	ldd	r19, Z+3	; 0x03
    297e:	eb 81       	ldd	r30, Y+3	; 0x03
    2980:	fc 81       	ldd	r31, Y+4	; 0x04
    2982:	84 8d       	ldd	r24, Z+28	; 0x1c
    2984:	88 2f       	mov	r24, r24
    2986:	90 e0       	ldi	r25, 0x00	; 0
    2988:	82 0f       	add	r24, r18
    298a:	93 1f       	adc	r25, r19
    298c:	eb 81       	ldd	r30, Y+3	; 0x03
    298e:	fc 81       	ldd	r31, Y+4	; 0x04
    2990:	93 83       	std	Z+3, r25	; 0x03
    2992:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2994:	eb 81       	ldd	r30, Y+3	; 0x03
    2996:	fc 81       	ldd	r31, Y+4	; 0x04
    2998:	22 81       	ldd	r18, Z+2	; 0x02
    299a:	33 81       	ldd	r19, Z+3	; 0x03
    299c:	eb 81       	ldd	r30, Y+3	; 0x03
    299e:	fc 81       	ldd	r31, Y+4	; 0x04
    29a0:	84 81       	ldd	r24, Z+4	; 0x04
    29a2:	95 81       	ldd	r25, Z+5	; 0x05
    29a4:	28 17       	cp	r18, r24
    29a6:	39 07       	cpc	r19, r25
    29a8:	08 f4       	brcc	.+2      	; 0x29ac <prvCopyDataToQueue+0x8e>
    29aa:	50 c0       	rjmp	.+160    	; 0x2a4c <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    29ac:	eb 81       	ldd	r30, Y+3	; 0x03
    29ae:	fc 81       	ldd	r31, Y+4	; 0x04
    29b0:	80 81       	ld	r24, Z
    29b2:	91 81       	ldd	r25, Z+1	; 0x01
    29b4:	eb 81       	ldd	r30, Y+3	; 0x03
    29b6:	fc 81       	ldd	r31, Y+4	; 0x04
    29b8:	93 83       	std	Z+3, r25	; 0x03
    29ba:	82 83       	std	Z+2, r24	; 0x02
    29bc:	47 c0       	rjmp	.+142    	; 0x2a4c <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    29be:	eb 81       	ldd	r30, Y+3	; 0x03
    29c0:	fc 81       	ldd	r31, Y+4	; 0x04
    29c2:	66 81       	ldd	r22, Z+6	; 0x06
    29c4:	77 81       	ldd	r23, Z+7	; 0x07
    29c6:	eb 81       	ldd	r30, Y+3	; 0x03
    29c8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    29cc:	48 2f       	mov	r20, r24
    29ce:	50 e0       	ldi	r21, 0x00	; 0
    29d0:	2d 81       	ldd	r18, Y+5	; 0x05
    29d2:	3e 81       	ldd	r19, Y+6	; 0x06
    29d4:	cb 01       	movw	r24, r22
    29d6:	b9 01       	movw	r22, r18
    29d8:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    29dc:	eb 81       	ldd	r30, Y+3	; 0x03
    29de:	fc 81       	ldd	r31, Y+4	; 0x04
    29e0:	26 81       	ldd	r18, Z+6	; 0x06
    29e2:	37 81       	ldd	r19, Z+7	; 0x07
    29e4:	eb 81       	ldd	r30, Y+3	; 0x03
    29e6:	fc 81       	ldd	r31, Y+4	; 0x04
    29e8:	84 8d       	ldd	r24, Z+28	; 0x1c
    29ea:	88 2f       	mov	r24, r24
    29ec:	90 e0       	ldi	r25, 0x00	; 0
    29ee:	90 95       	com	r25
    29f0:	81 95       	neg	r24
    29f2:	9f 4f       	sbci	r25, 0xFF	; 255
    29f4:	82 0f       	add	r24, r18
    29f6:	93 1f       	adc	r25, r19
    29f8:	eb 81       	ldd	r30, Y+3	; 0x03
    29fa:	fc 81       	ldd	r31, Y+4	; 0x04
    29fc:	97 83       	std	Z+7, r25	; 0x07
    29fe:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2a00:	eb 81       	ldd	r30, Y+3	; 0x03
    2a02:	fc 81       	ldd	r31, Y+4	; 0x04
    2a04:	26 81       	ldd	r18, Z+6	; 0x06
    2a06:	37 81       	ldd	r19, Z+7	; 0x07
    2a08:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a0c:	80 81       	ld	r24, Z
    2a0e:	91 81       	ldd	r25, Z+1	; 0x01
    2a10:	28 17       	cp	r18, r24
    2a12:	39 07       	cpc	r19, r25
    2a14:	90 f4       	brcc	.+36     	; 0x2a3a <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2a16:	eb 81       	ldd	r30, Y+3	; 0x03
    2a18:	fc 81       	ldd	r31, Y+4	; 0x04
    2a1a:	24 81       	ldd	r18, Z+4	; 0x04
    2a1c:	35 81       	ldd	r19, Z+5	; 0x05
    2a1e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a20:	fc 81       	ldd	r31, Y+4	; 0x04
    2a22:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a24:	88 2f       	mov	r24, r24
    2a26:	90 e0       	ldi	r25, 0x00	; 0
    2a28:	90 95       	com	r25
    2a2a:	81 95       	neg	r24
    2a2c:	9f 4f       	sbci	r25, 0xFF	; 255
    2a2e:	82 0f       	add	r24, r18
    2a30:	93 1f       	adc	r25, r19
    2a32:	eb 81       	ldd	r30, Y+3	; 0x03
    2a34:	fc 81       	ldd	r31, Y+4	; 0x04
    2a36:	97 83       	std	Z+7, r25	; 0x07
    2a38:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    2a3a:	8f 81       	ldd	r24, Y+7	; 0x07
    2a3c:	82 30       	cpi	r24, 0x02	; 2
    2a3e:	31 f4       	brne	.+12     	; 0x2a4c <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2a40:	89 81       	ldd	r24, Y+1	; 0x01
    2a42:	88 23       	and	r24, r24
    2a44:	19 f0       	breq	.+6      	; 0x2a4c <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    2a46:	89 81       	ldd	r24, Y+1	; 0x01
    2a48:	81 50       	subi	r24, 0x01	; 1
    2a4a:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2a4c:	89 81       	ldd	r24, Y+1	; 0x01
    2a4e:	8f 5f       	subi	r24, 0xFF	; 255
    2a50:	eb 81       	ldd	r30, Y+3	; 0x03
    2a52:	fc 81       	ldd	r31, Y+4	; 0x04
    2a54:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    2a56:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2a58:	27 96       	adiw	r28, 0x07	; 7
    2a5a:	0f b6       	in	r0, 0x3f	; 63
    2a5c:	f8 94       	cli
    2a5e:	de bf       	out	0x3e, r29	; 62
    2a60:	0f be       	out	0x3f, r0	; 63
    2a62:	cd bf       	out	0x3d, r28	; 61
    2a64:	cf 91       	pop	r28
    2a66:	df 91       	pop	r29
    2a68:	08 95       	ret

00002a6a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    2a6a:	df 93       	push	r29
    2a6c:	cf 93       	push	r28
    2a6e:	00 d0       	rcall	.+0      	; 0x2a70 <prvCopyDataFromQueue+0x6>
    2a70:	00 d0       	rcall	.+0      	; 0x2a72 <prvCopyDataFromQueue+0x8>
    2a72:	cd b7       	in	r28, 0x3d	; 61
    2a74:	de b7       	in	r29, 0x3e	; 62
    2a76:	9a 83       	std	Y+2, r25	; 0x02
    2a78:	89 83       	std	Y+1, r24	; 0x01
    2a7a:	7c 83       	std	Y+4, r23	; 0x04
    2a7c:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2a7e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a80:	fa 81       	ldd	r31, Y+2	; 0x02
    2a82:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a84:	88 23       	and	r24, r24
    2a86:	89 f1       	breq	.+98     	; 0x2aea <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2a88:	e9 81       	ldd	r30, Y+1	; 0x01
    2a8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a8c:	26 81       	ldd	r18, Z+6	; 0x06
    2a8e:	37 81       	ldd	r19, Z+7	; 0x07
    2a90:	e9 81       	ldd	r30, Y+1	; 0x01
    2a92:	fa 81       	ldd	r31, Y+2	; 0x02
    2a94:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a96:	88 2f       	mov	r24, r24
    2a98:	90 e0       	ldi	r25, 0x00	; 0
    2a9a:	82 0f       	add	r24, r18
    2a9c:	93 1f       	adc	r25, r19
    2a9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2aa0:	fa 81       	ldd	r31, Y+2	; 0x02
    2aa2:	97 83       	std	Z+7, r25	; 0x07
    2aa4:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2aa6:	e9 81       	ldd	r30, Y+1	; 0x01
    2aa8:	fa 81       	ldd	r31, Y+2	; 0x02
    2aaa:	26 81       	ldd	r18, Z+6	; 0x06
    2aac:	37 81       	ldd	r19, Z+7	; 0x07
    2aae:	e9 81       	ldd	r30, Y+1	; 0x01
    2ab0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ab2:	84 81       	ldd	r24, Z+4	; 0x04
    2ab4:	95 81       	ldd	r25, Z+5	; 0x05
    2ab6:	28 17       	cp	r18, r24
    2ab8:	39 07       	cpc	r19, r25
    2aba:	40 f0       	brcs	.+16     	; 0x2acc <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2abc:	e9 81       	ldd	r30, Y+1	; 0x01
    2abe:	fa 81       	ldd	r31, Y+2	; 0x02
    2ac0:	80 81       	ld	r24, Z
    2ac2:	91 81       	ldd	r25, Z+1	; 0x01
    2ac4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ac6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ac8:	97 83       	std	Z+7, r25	; 0x07
    2aca:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2acc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ace:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad0:	46 81       	ldd	r20, Z+6	; 0x06
    2ad2:	57 81       	ldd	r21, Z+7	; 0x07
    2ad4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ada:	28 2f       	mov	r18, r24
    2adc:	30 e0       	ldi	r19, 0x00	; 0
    2ade:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae2:	ba 01       	movw	r22, r20
    2ae4:	a9 01       	movw	r20, r18
    2ae6:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <memcpy>
    }
}
    2aea:	0f 90       	pop	r0
    2aec:	0f 90       	pop	r0
    2aee:	0f 90       	pop	r0
    2af0:	0f 90       	pop	r0
    2af2:	cf 91       	pop	r28
    2af4:	df 91       	pop	r29
    2af6:	08 95       	ret

00002af8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2af8:	df 93       	push	r29
    2afa:	cf 93       	push	r28
    2afc:	00 d0       	rcall	.+0      	; 0x2afe <prvUnlockQueue+0x6>
    2afe:	00 d0       	rcall	.+0      	; 0x2b00 <prvUnlockQueue+0x8>
    2b00:	cd b7       	in	r28, 0x3d	; 61
    2b02:	de b7       	in	r29, 0x3e	; 62
    2b04:	9c 83       	std	Y+4, r25	; 0x04
    2b06:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    2b08:	0f b6       	in	r0, 0x3f	; 63
    2b0a:	f8 94       	cli
    2b0c:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    2b0e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b10:	fc 81       	ldd	r31, Y+4	; 0x04
    2b12:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b14:	8a 83       	std	Y+2, r24	; 0x02
    2b16:	11 c0       	rjmp	.+34     	; 0x2b3a <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b18:	eb 81       	ldd	r30, Y+3	; 0x03
    2b1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b1c:	81 89       	ldd	r24, Z+17	; 0x11
    2b1e:	88 23       	and	r24, r24
    2b20:	79 f0       	breq	.+30     	; 0x2b40 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b22:	8b 81       	ldd	r24, Y+3	; 0x03
    2b24:	9c 81       	ldd	r25, Y+4	; 0x04
    2b26:	41 96       	adiw	r24, 0x11	; 17
    2b28:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    2b2c:	88 23       	and	r24, r24
    2b2e:	11 f0       	breq	.+4      	; 0x2b34 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    2b30:	0e 94 3c 23 	call	0x4678	; 0x4678 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    2b34:	8a 81       	ldd	r24, Y+2	; 0x02
    2b36:	81 50       	subi	r24, 0x01	; 1
    2b38:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    2b3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b3c:	18 16       	cp	r1, r24
    2b3e:	64 f3       	brlt	.-40     	; 0x2b18 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    2b40:	eb 81       	ldd	r30, Y+3	; 0x03
    2b42:	fc 81       	ldd	r31, Y+4	; 0x04
    2b44:	8f ef       	ldi	r24, 0xFF	; 255
    2b46:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    2b48:	0f 90       	pop	r0
    2b4a:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    2b4c:	0f b6       	in	r0, 0x3f	; 63
    2b4e:	f8 94       	cli
    2b50:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    2b52:	eb 81       	ldd	r30, Y+3	; 0x03
    2b54:	fc 81       	ldd	r31, Y+4	; 0x04
    2b56:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b58:	89 83       	std	Y+1, r24	; 0x01
    2b5a:	11 c0       	rjmp	.+34     	; 0x2b7e <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2b5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b60:	80 85       	ldd	r24, Z+8	; 0x08
    2b62:	88 23       	and	r24, r24
    2b64:	79 f0       	breq	.+30     	; 0x2b84 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2b66:	8b 81       	ldd	r24, Y+3	; 0x03
    2b68:	9c 81       	ldd	r25, Y+4	; 0x04
    2b6a:	08 96       	adiw	r24, 0x08	; 8
    2b6c:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskRemoveFromEventList>
    2b70:	88 23       	and	r24, r24
    2b72:	11 f0       	breq	.+4      	; 0x2b78 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    2b74:	0e 94 3c 23 	call	0x4678	; 0x4678 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    2b78:	89 81       	ldd	r24, Y+1	; 0x01
    2b7a:	81 50       	subi	r24, 0x01	; 1
    2b7c:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    2b7e:	89 81       	ldd	r24, Y+1	; 0x01
    2b80:	18 16       	cp	r1, r24
    2b82:	64 f3       	brlt	.-40     	; 0x2b5c <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    2b84:	eb 81       	ldd	r30, Y+3	; 0x03
    2b86:	fc 81       	ldd	r31, Y+4	; 0x04
    2b88:	8f ef       	ldi	r24, 0xFF	; 255
    2b8a:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    2b8c:	0f 90       	pop	r0
    2b8e:	0f be       	out	0x3f, r0	; 63
}
    2b90:	0f 90       	pop	r0
    2b92:	0f 90       	pop	r0
    2b94:	0f 90       	pop	r0
    2b96:	0f 90       	pop	r0
    2b98:	cf 91       	pop	r28
    2b9a:	df 91       	pop	r29
    2b9c:	08 95       	ret

00002b9e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    2b9e:	df 93       	push	r29
    2ba0:	cf 93       	push	r28
    2ba2:	00 d0       	rcall	.+0      	; 0x2ba4 <prvIsQueueEmpty+0x6>
    2ba4:	0f 92       	push	r0
    2ba6:	cd b7       	in	r28, 0x3d	; 61
    2ba8:	de b7       	in	r29, 0x3e	; 62
    2baa:	9b 83       	std	Y+3, r25	; 0x03
    2bac:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2bae:	0f b6       	in	r0, 0x3f	; 63
    2bb0:	f8 94       	cli
    2bb2:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2bb4:	ea 81       	ldd	r30, Y+2	; 0x02
    2bb6:	fb 81       	ldd	r31, Y+3	; 0x03
    2bb8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bba:	88 23       	and	r24, r24
    2bbc:	19 f4       	brne	.+6      	; 0x2bc4 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    2bbe:	81 e0       	ldi	r24, 0x01	; 1
    2bc0:	89 83       	std	Y+1, r24	; 0x01
    2bc2:	01 c0       	rjmp	.+2      	; 0x2bc6 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    2bc4:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2bc6:	0f 90       	pop	r0
    2bc8:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2bca:	89 81       	ldd	r24, Y+1	; 0x01
}
    2bcc:	0f 90       	pop	r0
    2bce:	0f 90       	pop	r0
    2bd0:	0f 90       	pop	r0
    2bd2:	cf 91       	pop	r28
    2bd4:	df 91       	pop	r29
    2bd6:	08 95       	ret

00002bd8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2bd8:	df 93       	push	r29
    2bda:	cf 93       	push	r28
    2bdc:	00 d0       	rcall	.+0      	; 0x2bde <xQueueIsQueueEmptyFromISR+0x6>
    2bde:	00 d0       	rcall	.+0      	; 0x2be0 <xQueueIsQueueEmptyFromISR+0x8>
    2be0:	0f 92       	push	r0
    2be2:	cd b7       	in	r28, 0x3d	; 61
    2be4:	de b7       	in	r29, 0x3e	; 62
    2be6:	9d 83       	std	Y+5, r25	; 0x05
    2be8:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2bea:	8c 81       	ldd	r24, Y+4	; 0x04
    2bec:	9d 81       	ldd	r25, Y+5	; 0x05
    2bee:	9a 83       	std	Y+2, r25	; 0x02
    2bf0:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2bf2:	e9 81       	ldd	r30, Y+1	; 0x01
    2bf4:	fa 81       	ldd	r31, Y+2	; 0x02
    2bf6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bf8:	88 23       	and	r24, r24
    2bfa:	19 f4       	brne	.+6      	; 0x2c02 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    2bfc:	81 e0       	ldi	r24, 0x01	; 1
    2bfe:	8b 83       	std	Y+3, r24	; 0x03
    2c00:	01 c0       	rjmp	.+2      	; 0x2c04 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    2c02:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2c04:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2c06:	0f 90       	pop	r0
    2c08:	0f 90       	pop	r0
    2c0a:	0f 90       	pop	r0
    2c0c:	0f 90       	pop	r0
    2c0e:	0f 90       	pop	r0
    2c10:	cf 91       	pop	r28
    2c12:	df 91       	pop	r29
    2c14:	08 95       	ret

00002c16 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    2c16:	df 93       	push	r29
    2c18:	cf 93       	push	r28
    2c1a:	00 d0       	rcall	.+0      	; 0x2c1c <prvIsQueueFull+0x6>
    2c1c:	0f 92       	push	r0
    2c1e:	cd b7       	in	r28, 0x3d	; 61
    2c20:	de b7       	in	r29, 0x3e	; 62
    2c22:	9b 83       	std	Y+3, r25	; 0x03
    2c24:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2c26:	0f b6       	in	r0, 0x3f	; 63
    2c28:	f8 94       	cli
    2c2a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2c2c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c2e:	fb 81       	ldd	r31, Y+3	; 0x03
    2c30:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c32:	ea 81       	ldd	r30, Y+2	; 0x02
    2c34:	fb 81       	ldd	r31, Y+3	; 0x03
    2c36:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c38:	98 17       	cp	r25, r24
    2c3a:	19 f4       	brne	.+6      	; 0x2c42 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    2c3c:	81 e0       	ldi	r24, 0x01	; 1
    2c3e:	89 83       	std	Y+1, r24	; 0x01
    2c40:	01 c0       	rjmp	.+2      	; 0x2c44 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    2c42:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2c44:	0f 90       	pop	r0
    2c46:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2c48:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c4a:	0f 90       	pop	r0
    2c4c:	0f 90       	pop	r0
    2c4e:	0f 90       	pop	r0
    2c50:	cf 91       	pop	r28
    2c52:	df 91       	pop	r29
    2c54:	08 95       	ret

00002c56 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2c56:	df 93       	push	r29
    2c58:	cf 93       	push	r28
    2c5a:	00 d0       	rcall	.+0      	; 0x2c5c <xQueueIsQueueFullFromISR+0x6>
    2c5c:	00 d0       	rcall	.+0      	; 0x2c5e <xQueueIsQueueFullFromISR+0x8>
    2c5e:	0f 92       	push	r0
    2c60:	cd b7       	in	r28, 0x3d	; 61
    2c62:	de b7       	in	r29, 0x3e	; 62
    2c64:	9d 83       	std	Y+5, r25	; 0x05
    2c66:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2c68:	8c 81       	ldd	r24, Y+4	; 0x04
    2c6a:	9d 81       	ldd	r25, Y+5	; 0x05
    2c6c:	9a 83       	std	Y+2, r25	; 0x02
    2c6e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2c70:	e9 81       	ldd	r30, Y+1	; 0x01
    2c72:	fa 81       	ldd	r31, Y+2	; 0x02
    2c74:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c76:	e9 81       	ldd	r30, Y+1	; 0x01
    2c78:	fa 81       	ldd	r31, Y+2	; 0x02
    2c7a:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c7c:	98 17       	cp	r25, r24
    2c7e:	19 f4       	brne	.+6      	; 0x2c86 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    2c80:	81 e0       	ldi	r24, 0x01	; 1
    2c82:	8b 83       	std	Y+3, r24	; 0x03
    2c84:	01 c0       	rjmp	.+2      	; 0x2c88 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    2c86:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2c88:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2c8a:	0f 90       	pop	r0
    2c8c:	0f 90       	pop	r0
    2c8e:	0f 90       	pop	r0
    2c90:	0f 90       	pop	r0
    2c92:	0f 90       	pop	r0
    2c94:	cf 91       	pop	r28
    2c96:	df 91       	pop	r29
    2c98:	08 95       	ret

00002c9a <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    2c9a:	df 93       	push	r29
    2c9c:	cf 93       	push	r28
    2c9e:	cd b7       	in	r28, 0x3d	; 61
    2ca0:	de b7       	in	r29, 0x3e	; 62
    2ca2:	2a 97       	sbiw	r28, 0x0a	; 10
    2ca4:	0f b6       	in	r0, 0x3f	; 63
    2ca6:	f8 94       	cli
    2ca8:	de bf       	out	0x3e, r29	; 62
    2caa:	0f be       	out	0x3f, r0	; 63
    2cac:	cd bf       	out	0x3d, r28	; 61
    2cae:	9d 83       	std	Y+5, r25	; 0x05
    2cb0:	8c 83       	std	Y+4, r24	; 0x04
    2cb2:	7f 83       	std	Y+7, r23	; 0x07
    2cb4:	6e 83       	std	Y+6, r22	; 0x06
    2cb6:	59 87       	std	Y+9, r21	; 0x09
    2cb8:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2cba:	8c 81       	ldd	r24, Y+4	; 0x04
    2cbc:	9d 81       	ldd	r25, Y+5	; 0x05
    2cbe:	9a 83       	std	Y+2, r25	; 0x02
    2cc0:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2cc2:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2cc4:	89 81       	ldd	r24, Y+1	; 0x01
    2cc6:	9a 81       	ldd	r25, Y+2	; 0x02
    2cc8:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <prvIsQueueFull>
    2ccc:	88 23       	and	r24, r24
    2cce:	a9 f0       	breq	.+42     	; 0x2cfa <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2cd0:	88 85       	ldd	r24, Y+8	; 0x08
    2cd2:	99 85       	ldd	r25, Y+9	; 0x09
    2cd4:	00 97       	sbiw	r24, 0x00	; 0
    2cd6:	71 f0       	breq	.+28     	; 0x2cf4 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2cd8:	89 81       	ldd	r24, Y+1	; 0x01
    2cda:	9a 81       	ldd	r25, Y+2	; 0x02
    2cdc:	9c 01       	movw	r18, r24
    2cde:	28 5f       	subi	r18, 0xF8	; 248
    2ce0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ce2:	88 85       	ldd	r24, Y+8	; 0x08
    2ce4:	99 85       	ldd	r25, Y+9	; 0x09
    2ce6:	b9 01       	movw	r22, r18
    2ce8:	0e 94 19 08 	call	0x1032	; 0x1032 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2cec:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2cee:	8c ef       	ldi	r24, 0xFC	; 252
    2cf0:	8a 87       	std	Y+10, r24	; 0x0a
    2cf2:	2a c0       	rjmp	.+84     	; 0x2d48 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2cf4:	78 94       	sei
                    return errQUEUE_FULL;
    2cf6:	1a 86       	std	Y+10, r1	; 0x0a
    2cf8:	27 c0       	rjmp	.+78     	; 0x2d48 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    2cfa:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2cfc:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2cfe:	e9 81       	ldd	r30, Y+1	; 0x01
    2d00:	fa 81       	ldd	r31, Y+2	; 0x02
    2d02:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d04:	e9 81       	ldd	r30, Y+1	; 0x01
    2d06:	fa 81       	ldd	r31, Y+2	; 0x02
    2d08:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d0a:	98 17       	cp	r25, r24
    2d0c:	c8 f4       	brcc	.+50     	; 0x2d40 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2d0e:	89 81       	ldd	r24, Y+1	; 0x01
    2d10:	9a 81       	ldd	r25, Y+2	; 0x02
    2d12:	2e 81       	ldd	r18, Y+6	; 0x06
    2d14:	3f 81       	ldd	r19, Y+7	; 0x07
    2d16:	b9 01       	movw	r22, r18
    2d18:	40 e0       	ldi	r20, 0x00	; 0
    2d1a:	0e 94 8f 14 	call	0x291e	; 0x291e <prvCopyDataToQueue>
                xReturn = pdPASS;
    2d1e:	81 e0       	ldi	r24, 0x01	; 1
    2d20:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d22:	e9 81       	ldd	r30, Y+1	; 0x01
    2d24:	fa 81       	ldd	r31, Y+2	; 0x02
    2d26:	81 89       	ldd	r24, Z+17	; 0x11
    2d28:	88 23       	and	r24, r24
    2d2a:	59 f0       	breq	.+22     	; 0x2d42 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2d2c:	89 81       	ldd	r24, Y+1	; 0x01
    2d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d30:	41 96       	adiw	r24, 0x11	; 17
    2d32:	0e 94 2c 0a 	call	0x1458	; 0x1458 <xCoRoutineRemoveFromEventList>
    2d36:	88 23       	and	r24, r24
    2d38:	21 f0       	breq	.+8      	; 0x2d42 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    2d3a:	8b ef       	ldi	r24, 0xFB	; 251
    2d3c:	8b 83       	std	Y+3, r24	; 0x03
    2d3e:	01 c0       	rjmp	.+2      	; 0x2d42 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    2d40:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2d42:	78 94       	sei

        return xReturn;
    2d44:	8b 81       	ldd	r24, Y+3	; 0x03
    2d46:	8a 87       	std	Y+10, r24	; 0x0a
    2d48:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2d4a:	2a 96       	adiw	r28, 0x0a	; 10
    2d4c:	0f b6       	in	r0, 0x3f	; 63
    2d4e:	f8 94       	cli
    2d50:	de bf       	out	0x3e, r29	; 62
    2d52:	0f be       	out	0x3f, r0	; 63
    2d54:	cd bf       	out	0x3d, r28	; 61
    2d56:	cf 91       	pop	r28
    2d58:	df 91       	pop	r29
    2d5a:	08 95       	ret

00002d5c <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    2d5c:	df 93       	push	r29
    2d5e:	cf 93       	push	r28
    2d60:	cd b7       	in	r28, 0x3d	; 61
    2d62:	de b7       	in	r29, 0x3e	; 62
    2d64:	2a 97       	sbiw	r28, 0x0a	; 10
    2d66:	0f b6       	in	r0, 0x3f	; 63
    2d68:	f8 94       	cli
    2d6a:	de bf       	out	0x3e, r29	; 62
    2d6c:	0f be       	out	0x3f, r0	; 63
    2d6e:	cd bf       	out	0x3d, r28	; 61
    2d70:	9d 83       	std	Y+5, r25	; 0x05
    2d72:	8c 83       	std	Y+4, r24	; 0x04
    2d74:	7f 83       	std	Y+7, r23	; 0x07
    2d76:	6e 83       	std	Y+6, r22	; 0x06
    2d78:	59 87       	std	Y+9, r21	; 0x09
    2d7a:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2d7c:	8c 81       	ldd	r24, Y+4	; 0x04
    2d7e:	9d 81       	ldd	r25, Y+5	; 0x05
    2d80:	9a 83       	std	Y+2, r25	; 0x02
    2d82:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2d84:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2d86:	e9 81       	ldd	r30, Y+1	; 0x01
    2d88:	fa 81       	ldd	r31, Y+2	; 0x02
    2d8a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d8c:	88 23       	and	r24, r24
    2d8e:	a9 f4       	brne	.+42     	; 0x2dba <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2d90:	88 85       	ldd	r24, Y+8	; 0x08
    2d92:	99 85       	ldd	r25, Y+9	; 0x09
    2d94:	00 97       	sbiw	r24, 0x00	; 0
    2d96:	71 f0       	breq	.+28     	; 0x2db4 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2d98:	89 81       	ldd	r24, Y+1	; 0x01
    2d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d9c:	9c 01       	movw	r18, r24
    2d9e:	2f 5e       	subi	r18, 0xEF	; 239
    2da0:	3f 4f       	sbci	r19, 0xFF	; 255
    2da2:	88 85       	ldd	r24, Y+8	; 0x08
    2da4:	99 85       	ldd	r25, Y+9	; 0x09
    2da6:	b9 01       	movw	r22, r18
    2da8:	0e 94 19 08 	call	0x1032	; 0x1032 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2dac:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2dae:	8c ef       	ldi	r24, 0xFC	; 252
    2db0:	8a 87       	std	Y+10, r24	; 0x0a
    2db2:	58 c0       	rjmp	.+176    	; 0x2e64 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2db4:	78 94       	sei
                    return errQUEUE_FULL;
    2db6:	1a 86       	std	Y+10, r1	; 0x0a
    2db8:	55 c0       	rjmp	.+170    	; 0x2e64 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    2dba:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2dbc:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2dbe:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc0:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dc4:	88 23       	and	r24, r24
    2dc6:	09 f4       	brne	.+2      	; 0x2dca <xQueueCRReceive+0x6e>
    2dc8:	49 c0       	rjmp	.+146    	; 0x2e5c <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2dca:	e9 81       	ldd	r30, Y+1	; 0x01
    2dcc:	fa 81       	ldd	r31, Y+2	; 0x02
    2dce:	26 81       	ldd	r18, Z+6	; 0x06
    2dd0:	37 81       	ldd	r19, Z+7	; 0x07
    2dd2:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd4:	fa 81       	ldd	r31, Y+2	; 0x02
    2dd6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2dd8:	88 2f       	mov	r24, r24
    2dda:	90 e0       	ldi	r25, 0x00	; 0
    2ddc:	82 0f       	add	r24, r18
    2dde:	93 1f       	adc	r25, r19
    2de0:	e9 81       	ldd	r30, Y+1	; 0x01
    2de2:	fa 81       	ldd	r31, Y+2	; 0x02
    2de4:	97 83       	std	Z+7, r25	; 0x07
    2de6:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2de8:	e9 81       	ldd	r30, Y+1	; 0x01
    2dea:	fa 81       	ldd	r31, Y+2	; 0x02
    2dec:	26 81       	ldd	r18, Z+6	; 0x06
    2dee:	37 81       	ldd	r19, Z+7	; 0x07
    2df0:	e9 81       	ldd	r30, Y+1	; 0x01
    2df2:	fa 81       	ldd	r31, Y+2	; 0x02
    2df4:	84 81       	ldd	r24, Z+4	; 0x04
    2df6:	95 81       	ldd	r25, Z+5	; 0x05
    2df8:	28 17       	cp	r18, r24
    2dfa:	39 07       	cpc	r19, r25
    2dfc:	40 f0       	brcs	.+16     	; 0x2e0e <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2dfe:	e9 81       	ldd	r30, Y+1	; 0x01
    2e00:	fa 81       	ldd	r31, Y+2	; 0x02
    2e02:	80 81       	ld	r24, Z
    2e04:	91 81       	ldd	r25, Z+1	; 0x01
    2e06:	e9 81       	ldd	r30, Y+1	; 0x01
    2e08:	fa 81       	ldd	r31, Y+2	; 0x02
    2e0a:	97 83       	std	Z+7, r25	; 0x07
    2e0c:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    2e0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e10:	fa 81       	ldd	r31, Y+2	; 0x02
    2e12:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e14:	81 50       	subi	r24, 0x01	; 1
    2e16:	e9 81       	ldd	r30, Y+1	; 0x01
    2e18:	fa 81       	ldd	r31, Y+2	; 0x02
    2e1a:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2e20:	46 81       	ldd	r20, Z+6	; 0x06
    2e22:	57 81       	ldd	r21, Z+7	; 0x07
    2e24:	e9 81       	ldd	r30, Y+1	; 0x01
    2e26:	fa 81       	ldd	r31, Y+2	; 0x02
    2e28:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e2a:	28 2f       	mov	r18, r24
    2e2c:	30 e0       	ldi	r19, 0x00	; 0
    2e2e:	8e 81       	ldd	r24, Y+6	; 0x06
    2e30:	9f 81       	ldd	r25, Y+7	; 0x07
    2e32:	ba 01       	movw	r22, r20
    2e34:	a9 01       	movw	r20, r18
    2e36:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <memcpy>

                xReturn = pdPASS;
    2e3a:	81 e0       	ldi	r24, 0x01	; 1
    2e3c:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e40:	fa 81       	ldd	r31, Y+2	; 0x02
    2e42:	80 85       	ldd	r24, Z+8	; 0x08
    2e44:	88 23       	and	r24, r24
    2e46:	59 f0       	breq	.+22     	; 0x2e5e <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e48:	89 81       	ldd	r24, Y+1	; 0x01
    2e4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e4c:	08 96       	adiw	r24, 0x08	; 8
    2e4e:	0e 94 2c 0a 	call	0x1458	; 0x1458 <xCoRoutineRemoveFromEventList>
    2e52:	88 23       	and	r24, r24
    2e54:	21 f0       	breq	.+8      	; 0x2e5e <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    2e56:	8b ef       	ldi	r24, 0xFB	; 251
    2e58:	8b 83       	std	Y+3, r24	; 0x03
    2e5a:	01 c0       	rjmp	.+2      	; 0x2e5e <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    2e5c:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2e5e:	78 94       	sei

        return xReturn;
    2e60:	8b 81       	ldd	r24, Y+3	; 0x03
    2e62:	8a 87       	std	Y+10, r24	; 0x0a
    2e64:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2e66:	2a 96       	adiw	r28, 0x0a	; 10
    2e68:	0f b6       	in	r0, 0x3f	; 63
    2e6a:	f8 94       	cli
    2e6c:	de bf       	out	0x3e, r29	; 62
    2e6e:	0f be       	out	0x3f, r0	; 63
    2e70:	cd bf       	out	0x3d, r28	; 61
    2e72:	cf 91       	pop	r28
    2e74:	df 91       	pop	r29
    2e76:	08 95       	ret

00002e78 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    2e78:	df 93       	push	r29
    2e7a:	cf 93       	push	r28
    2e7c:	cd b7       	in	r28, 0x3d	; 61
    2e7e:	de b7       	in	r29, 0x3e	; 62
    2e80:	28 97       	sbiw	r28, 0x08	; 8
    2e82:	0f b6       	in	r0, 0x3f	; 63
    2e84:	f8 94       	cli
    2e86:	de bf       	out	0x3e, r29	; 62
    2e88:	0f be       	out	0x3f, r0	; 63
    2e8a:	cd bf       	out	0x3d, r28	; 61
    2e8c:	9c 83       	std	Y+4, r25	; 0x04
    2e8e:	8b 83       	std	Y+3, r24	; 0x03
    2e90:	7e 83       	std	Y+6, r23	; 0x06
    2e92:	6d 83       	std	Y+5, r22	; 0x05
    2e94:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    2e96:	8b 81       	ldd	r24, Y+3	; 0x03
    2e98:	9c 81       	ldd	r25, Y+4	; 0x04
    2e9a:	9a 83       	std	Y+2, r25	; 0x02
    2e9c:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2e9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea2:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ea4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea8:	83 8d       	ldd	r24, Z+27	; 0x1b
    2eaa:	98 17       	cp	r25, r24
    2eac:	d0 f4       	brcc	.+52     	; 0x2ee2 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2eae:	89 81       	ldd	r24, Y+1	; 0x01
    2eb0:	9a 81       	ldd	r25, Y+2	; 0x02
    2eb2:	2d 81       	ldd	r18, Y+5	; 0x05
    2eb4:	3e 81       	ldd	r19, Y+6	; 0x06
    2eb6:	b9 01       	movw	r22, r18
    2eb8:	40 e0       	ldi	r20, 0x00	; 0
    2eba:	0e 94 8f 14 	call	0x291e	; 0x291e <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    2ebe:	8f 81       	ldd	r24, Y+7	; 0x07
    2ec0:	88 23       	and	r24, r24
    2ec2:	79 f4       	brne	.+30     	; 0x2ee2 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ec4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ec6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ec8:	81 89       	ldd	r24, Z+17	; 0x11
    2eca:	88 23       	and	r24, r24
    2ecc:	51 f0       	breq	.+20     	; 0x2ee2 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ece:	89 81       	ldd	r24, Y+1	; 0x01
    2ed0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ed2:	41 96       	adiw	r24, 0x11	; 17
    2ed4:	0e 94 2c 0a 	call	0x1458	; 0x1458 <xCoRoutineRemoveFromEventList>
    2ed8:	88 23       	and	r24, r24
    2eda:	19 f0       	breq	.+6      	; 0x2ee2 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    2edc:	81 e0       	ldi	r24, 0x01	; 1
    2ede:	88 87       	std	Y+8, r24	; 0x08
    2ee0:	02 c0       	rjmp	.+4      	; 0x2ee6 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    2ee2:	8f 81       	ldd	r24, Y+7	; 0x07
    2ee4:	88 87       	std	Y+8, r24	; 0x08
    2ee6:	88 85       	ldd	r24, Y+8	; 0x08
    }
    2ee8:	28 96       	adiw	r28, 0x08	; 8
    2eea:	0f b6       	in	r0, 0x3f	; 63
    2eec:	f8 94       	cli
    2eee:	de bf       	out	0x3e, r29	; 62
    2ef0:	0f be       	out	0x3f, r0	; 63
    2ef2:	cd bf       	out	0x3d, r28	; 61
    2ef4:	cf 91       	pop	r28
    2ef6:	df 91       	pop	r29
    2ef8:	08 95       	ret

00002efa <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    2efa:	df 93       	push	r29
    2efc:	cf 93       	push	r28
    2efe:	cd b7       	in	r28, 0x3d	; 61
    2f00:	de b7       	in	r29, 0x3e	; 62
    2f02:	29 97       	sbiw	r28, 0x09	; 9
    2f04:	0f b6       	in	r0, 0x3f	; 63
    2f06:	f8 94       	cli
    2f08:	de bf       	out	0x3e, r29	; 62
    2f0a:	0f be       	out	0x3f, r0	; 63
    2f0c:	cd bf       	out	0x3d, r28	; 61
    2f0e:	9d 83       	std	Y+5, r25	; 0x05
    2f10:	8c 83       	std	Y+4, r24	; 0x04
    2f12:	7f 83       	std	Y+7, r23	; 0x07
    2f14:	6e 83       	std	Y+6, r22	; 0x06
    2f16:	59 87       	std	Y+9, r21	; 0x09
    2f18:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2f1a:	8c 81       	ldd	r24, Y+4	; 0x04
    2f1c:	9d 81       	ldd	r25, Y+5	; 0x05
    2f1e:	9a 83       	std	Y+2, r25	; 0x02
    2f20:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f22:	e9 81       	ldd	r30, Y+1	; 0x01
    2f24:	fa 81       	ldd	r31, Y+2	; 0x02
    2f26:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f28:	88 23       	and	r24, r24
    2f2a:	09 f4       	brne	.+2      	; 0x2f2e <xQueueCRReceiveFromISR+0x34>
    2f2c:	50 c0       	rjmp	.+160    	; 0x2fce <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2f2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f30:	fa 81       	ldd	r31, Y+2	; 0x02
    2f32:	26 81       	ldd	r18, Z+6	; 0x06
    2f34:	37 81       	ldd	r19, Z+7	; 0x07
    2f36:	e9 81       	ldd	r30, Y+1	; 0x01
    2f38:	fa 81       	ldd	r31, Y+2	; 0x02
    2f3a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f3c:	88 2f       	mov	r24, r24
    2f3e:	90 e0       	ldi	r25, 0x00	; 0
    2f40:	82 0f       	add	r24, r18
    2f42:	93 1f       	adc	r25, r19
    2f44:	e9 81       	ldd	r30, Y+1	; 0x01
    2f46:	fa 81       	ldd	r31, Y+2	; 0x02
    2f48:	97 83       	std	Z+7, r25	; 0x07
    2f4a:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f50:	26 81       	ldd	r18, Z+6	; 0x06
    2f52:	37 81       	ldd	r19, Z+7	; 0x07
    2f54:	e9 81       	ldd	r30, Y+1	; 0x01
    2f56:	fa 81       	ldd	r31, Y+2	; 0x02
    2f58:	84 81       	ldd	r24, Z+4	; 0x04
    2f5a:	95 81       	ldd	r25, Z+5	; 0x05
    2f5c:	28 17       	cp	r18, r24
    2f5e:	39 07       	cpc	r19, r25
    2f60:	40 f0       	brcs	.+16     	; 0x2f72 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2f62:	e9 81       	ldd	r30, Y+1	; 0x01
    2f64:	fa 81       	ldd	r31, Y+2	; 0x02
    2f66:	80 81       	ld	r24, Z
    2f68:	91 81       	ldd	r25, Z+1	; 0x01
    2f6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f6e:	97 83       	std	Z+7, r25	; 0x07
    2f70:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    2f72:	e9 81       	ldd	r30, Y+1	; 0x01
    2f74:	fa 81       	ldd	r31, Y+2	; 0x02
    2f76:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f78:	81 50       	subi	r24, 0x01	; 1
    2f7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f7e:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2f80:	e9 81       	ldd	r30, Y+1	; 0x01
    2f82:	fa 81       	ldd	r31, Y+2	; 0x02
    2f84:	46 81       	ldd	r20, Z+6	; 0x06
    2f86:	57 81       	ldd	r21, Z+7	; 0x07
    2f88:	e9 81       	ldd	r30, Y+1	; 0x01
    2f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f8c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f8e:	28 2f       	mov	r18, r24
    2f90:	30 e0       	ldi	r19, 0x00	; 0
    2f92:	8e 81       	ldd	r24, Y+6	; 0x06
    2f94:	9f 81       	ldd	r25, Y+7	; 0x07
    2f96:	ba 01       	movw	r22, r20
    2f98:	a9 01       	movw	r20, r18
    2f9a:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    2f9e:	e8 85       	ldd	r30, Y+8	; 0x08
    2fa0:	f9 85       	ldd	r31, Y+9	; 0x09
    2fa2:	80 81       	ld	r24, Z
    2fa4:	88 23       	and	r24, r24
    2fa6:	81 f4       	brne	.+32     	; 0x2fc8 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2fa8:	e9 81       	ldd	r30, Y+1	; 0x01
    2faa:	fa 81       	ldd	r31, Y+2	; 0x02
    2fac:	80 85       	ldd	r24, Z+8	; 0x08
    2fae:	88 23       	and	r24, r24
    2fb0:	59 f0       	breq	.+22     	; 0x2fc8 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2fb2:	89 81       	ldd	r24, Y+1	; 0x01
    2fb4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fb6:	08 96       	adiw	r24, 0x08	; 8
    2fb8:	0e 94 2c 0a 	call	0x1458	; 0x1458 <xCoRoutineRemoveFromEventList>
    2fbc:	88 23       	and	r24, r24
    2fbe:	21 f0       	breq	.+8      	; 0x2fc8 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    2fc0:	e8 85       	ldd	r30, Y+8	; 0x08
    2fc2:	f9 85       	ldd	r31, Y+9	; 0x09
    2fc4:	81 e0       	ldi	r24, 0x01	; 1
    2fc6:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    2fc8:	81 e0       	ldi	r24, 0x01	; 1
    2fca:	8b 83       	std	Y+3, r24	; 0x03
    2fcc:	01 c0       	rjmp	.+2      	; 0x2fd0 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    2fce:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    2fd0:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2fd2:	29 96       	adiw	r28, 0x09	; 9
    2fd4:	0f b6       	in	r0, 0x3f	; 63
    2fd6:	f8 94       	cli
    2fd8:	de bf       	out	0x3e, r29	; 62
    2fda:	0f be       	out	0x3f, r0	; 63
    2fdc:	cd bf       	out	0x3d, r28	; 61
    2fde:	cf 91       	pop	r28
    2fe0:	df 91       	pop	r29
    2fe2:	08 95       	ret

00002fe4 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    2fe4:	df 93       	push	r29
    2fe6:	cf 93       	push	r28
    2fe8:	cd b7       	in	r28, 0x3d	; 61
    2fea:	de b7       	in	r29, 0x3e	; 62
    2fec:	27 97       	sbiw	r28, 0x07	; 7
    2fee:	0f b6       	in	r0, 0x3f	; 63
    2ff0:	f8 94       	cli
    2ff2:	de bf       	out	0x3e, r29	; 62
    2ff4:	0f be       	out	0x3f, r0	; 63
    2ff6:	cd bf       	out	0x3d, r28	; 61
    2ff8:	9c 83       	std	Y+4, r25	; 0x04
    2ffa:	8b 83       	std	Y+3, r24	; 0x03
    2ffc:	7e 83       	std	Y+6, r23	; 0x06
    2ffe:	6d 83       	std	Y+5, r22	; 0x05
    3000:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    3002:	8b 81       	ldd	r24, Y+3	; 0x03
    3004:	9c 81       	ldd	r25, Y+4	; 0x04
    3006:	9a 83       	std	Y+2, r25	; 0x02
    3008:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    300a:	0f b6       	in	r0, 0x3f	; 63
    300c:	f8 94       	cli
    300e:	0f 92       	push	r0
    3010:	e9 81       	ldd	r30, Y+1	; 0x01
    3012:	fa 81       	ldd	r31, Y+2	; 0x02
    3014:	85 8d       	ldd	r24, Z+29	; 0x1d
    3016:	8f 3f       	cpi	r24, 0xFF	; 255
    3018:	19 f4       	brne	.+6      	; 0x3020 <vQueueWaitForMessageRestricted+0x3c>
    301a:	e9 81       	ldd	r30, Y+1	; 0x01
    301c:	fa 81       	ldd	r31, Y+2	; 0x02
    301e:	15 8e       	std	Z+29, r1	; 0x1d
    3020:	e9 81       	ldd	r30, Y+1	; 0x01
    3022:	fa 81       	ldd	r31, Y+2	; 0x02
    3024:	86 8d       	ldd	r24, Z+30	; 0x1e
    3026:	8f 3f       	cpi	r24, 0xFF	; 255
    3028:	19 f4       	brne	.+6      	; 0x3030 <vQueueWaitForMessageRestricted+0x4c>
    302a:	e9 81       	ldd	r30, Y+1	; 0x01
    302c:	fa 81       	ldd	r31, Y+2	; 0x02
    302e:	16 8e       	std	Z+30, r1	; 0x1e
    3030:	0f 90       	pop	r0
    3032:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3034:	e9 81       	ldd	r30, Y+1	; 0x01
    3036:	fa 81       	ldd	r31, Y+2	; 0x02
    3038:	82 8d       	ldd	r24, Z+26	; 0x1a
    303a:	88 23       	and	r24, r24
    303c:	49 f4       	brne	.+18     	; 0x3050 <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    303e:	89 81       	ldd	r24, Y+1	; 0x01
    3040:	9a 81       	ldd	r25, Y+2	; 0x02
    3042:	41 96       	adiw	r24, 0x11	; 17
    3044:	2d 81       	ldd	r18, Y+5	; 0x05
    3046:	3e 81       	ldd	r19, Y+6	; 0x06
    3048:	b9 01       	movw	r22, r18
    304a:	4f 81       	ldd	r20, Y+7	; 0x07
    304c:	0e 94 ea 1f 	call	0x3fd4	; 0x3fd4 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    3050:	89 81       	ldd	r24, Y+1	; 0x01
    3052:	9a 81       	ldd	r25, Y+2	; 0x02
    3054:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvUnlockQueue>
    }
    3058:	27 96       	adiw	r28, 0x07	; 7
    305a:	0f b6       	in	r0, 0x3f	; 63
    305c:	f8 94       	cli
    305e:	de bf       	out	0x3e, r29	; 62
    3060:	0f be       	out	0x3f, r0	; 63
    3062:	cd bf       	out	0x3d, r28	; 61
    3064:	cf 91       	pop	r28
    3066:	df 91       	pop	r29
    3068:	08 95       	ret

0000306a <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    306a:	8f 92       	push	r8
    306c:	9f 92       	push	r9
    306e:	af 92       	push	r10
    3070:	bf 92       	push	r11
    3072:	cf 92       	push	r12
    3074:	df 92       	push	r13
    3076:	ef 92       	push	r14
    3078:	ff 92       	push	r15
    307a:	0f 93       	push	r16
    307c:	1f 93       	push	r17
    307e:	df 93       	push	r29
    3080:	cf 93       	push	r28
    3082:	cd b7       	in	r28, 0x3d	; 61
    3084:	de b7       	in	r29, 0x3e	; 62
    3086:	60 97       	sbiw	r28, 0x10	; 16
    3088:	0f b6       	in	r0, 0x3f	; 63
    308a:	f8 94       	cli
    308c:	de bf       	out	0x3e, r29	; 62
    308e:	0f be       	out	0x3f, r0	; 63
    3090:	cd bf       	out	0x3d, r28	; 61
    3092:	9f 83       	std	Y+7, r25	; 0x07
    3094:	8e 83       	std	Y+6, r24	; 0x06
    3096:	79 87       	std	Y+9, r23	; 0x09
    3098:	68 87       	std	Y+8, r22	; 0x08
    309a:	5b 87       	std	Y+11, r21	; 0x0b
    309c:	4a 87       	std	Y+10, r20	; 0x0a
    309e:	3d 87       	std	Y+13, r19	; 0x0d
    30a0:	2c 87       	std	Y+12, r18	; 0x0c
    30a2:	0e 87       	std	Y+14, r16	; 0x0e
    30a4:	f8 8a       	std	Y+16, r15	; 0x10
    30a6:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    30a8:	8a 85       	ldd	r24, Y+10	; 0x0a
    30aa:	9b 85       	ldd	r25, Y+11	; 0x0b
    30ac:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    30b0:	9a 83       	std	Y+2, r25	; 0x02
    30b2:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    30b4:	89 81       	ldd	r24, Y+1	; 0x01
    30b6:	9a 81       	ldd	r25, Y+2	; 0x02
    30b8:	00 97       	sbiw	r24, 0x00	; 0
    30ba:	b1 f0       	breq	.+44     	; 0x30e8 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    30bc:	86 e2       	ldi	r24, 0x26	; 38
    30be:	90 e0       	ldi	r25, 0x00	; 0
    30c0:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    30c4:	9d 83       	std	Y+5, r25	; 0x05
    30c6:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    30c8:	8c 81       	ldd	r24, Y+4	; 0x04
    30ca:	9d 81       	ldd	r25, Y+5	; 0x05
    30cc:	00 97       	sbiw	r24, 0x00	; 0
    30ce:	39 f0       	breq	.+14     	; 0x30de <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    30d0:	ec 81       	ldd	r30, Y+4	; 0x04
    30d2:	fd 81       	ldd	r31, Y+5	; 0x05
    30d4:	89 81       	ldd	r24, Y+1	; 0x01
    30d6:	9a 81       	ldd	r25, Y+2	; 0x02
    30d8:	90 8f       	std	Z+24, r25	; 0x18
    30da:	87 8b       	std	Z+23, r24	; 0x17
    30dc:	07 c0       	rjmp	.+14     	; 0x30ec <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    30de:	89 81       	ldd	r24, Y+1	; 0x01
    30e0:	9a 81       	ldd	r25, Y+2	; 0x02
    30e2:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    30e6:	02 c0       	rjmp	.+4      	; 0x30ec <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    30e8:	1d 82       	std	Y+5, r1	; 0x05
    30ea:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    30ec:	8c 81       	ldd	r24, Y+4	; 0x04
    30ee:	9d 81       	ldd	r25, Y+5	; 0x05
    30f0:	00 97       	sbiw	r24, 0x00	; 0
    30f2:	e9 f0       	breq	.+58     	; 0x312e <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    30f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    30f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    30f8:	9c 01       	movw	r18, r24
    30fa:	40 e0       	ldi	r20, 0x00	; 0
    30fc:	50 e0       	ldi	r21, 0x00	; 0
    30fe:	8e 81       	ldd	r24, Y+6	; 0x06
    3100:	9f 81       	ldd	r25, Y+7	; 0x07
    3102:	68 85       	ldd	r22, Y+8	; 0x08
    3104:	79 85       	ldd	r23, Y+9	; 0x09
    3106:	ec 85       	ldd	r30, Y+12	; 0x0c
    3108:	fd 85       	ldd	r31, Y+13	; 0x0d
    310a:	af 85       	ldd	r26, Y+15	; 0x0f
    310c:	b8 89       	ldd	r27, Y+16	; 0x10
    310e:	ac 80       	ldd	r10, Y+4	; 0x04
    3110:	bd 80       	ldd	r11, Y+5	; 0x05
    3112:	8f 01       	movw	r16, r30
    3114:	ee 84       	ldd	r14, Y+14	; 0x0e
    3116:	6d 01       	movw	r12, r26
    3118:	88 24       	eor	r8, r8
    311a:	99 24       	eor	r9, r9
    311c:	0e 94 ad 18 	call	0x315a	; 0x315a <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    3120:	8c 81       	ldd	r24, Y+4	; 0x04
    3122:	9d 81       	ldd	r25, Y+5	; 0x05
    3124:	0e 94 72 19 	call	0x32e4	; 0x32e4 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    3128:	81 e0       	ldi	r24, 0x01	; 1
    312a:	8b 83       	std	Y+3, r24	; 0x03
    312c:	02 c0       	rjmp	.+4      	; 0x3132 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    312e:	8f ef       	ldi	r24, 0xFF	; 255
    3130:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    3132:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3134:	60 96       	adiw	r28, 0x10	; 16
    3136:	0f b6       	in	r0, 0x3f	; 63
    3138:	f8 94       	cli
    313a:	de bf       	out	0x3e, r29	; 62
    313c:	0f be       	out	0x3f, r0	; 63
    313e:	cd bf       	out	0x3d, r28	; 61
    3140:	cf 91       	pop	r28
    3142:	df 91       	pop	r29
    3144:	1f 91       	pop	r17
    3146:	0f 91       	pop	r16
    3148:	ff 90       	pop	r15
    314a:	ef 90       	pop	r14
    314c:	df 90       	pop	r13
    314e:	cf 90       	pop	r12
    3150:	bf 90       	pop	r11
    3152:	af 90       	pop	r10
    3154:	9f 90       	pop	r9
    3156:	8f 90       	pop	r8
    3158:	08 95       	ret

0000315a <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    315a:	8f 92       	push	r8
    315c:	9f 92       	push	r9
    315e:	af 92       	push	r10
    3160:	bf 92       	push	r11
    3162:	cf 92       	push	r12
    3164:	df 92       	push	r13
    3166:	ef 92       	push	r14
    3168:	0f 93       	push	r16
    316a:	1f 93       	push	r17
    316c:	df 93       	push	r29
    316e:	cf 93       	push	r28
    3170:	cd b7       	in	r28, 0x3d	; 61
    3172:	de b7       	in	r29, 0x3e	; 62
    3174:	64 97       	sbiw	r28, 0x14	; 20
    3176:	0f b6       	in	r0, 0x3f	; 63
    3178:	f8 94       	cli
    317a:	de bf       	out	0x3e, r29	; 62
    317c:	0f be       	out	0x3f, r0	; 63
    317e:	cd bf       	out	0x3d, r28	; 61
    3180:	9d 83       	std	Y+5, r25	; 0x05
    3182:	8c 83       	std	Y+4, r24	; 0x04
    3184:	7f 83       	std	Y+7, r23	; 0x07
    3186:	6e 83       	std	Y+6, r22	; 0x06
    3188:	28 87       	std	Y+8, r18	; 0x08
    318a:	39 87       	std	Y+9, r19	; 0x09
    318c:	4a 87       	std	Y+10, r20	; 0x0a
    318e:	5b 87       	std	Y+11, r21	; 0x0b
    3190:	1d 87       	std	Y+13, r17	; 0x0d
    3192:	0c 87       	std	Y+12, r16	; 0x0c
    3194:	ee 86       	std	Y+14, r14	; 0x0e
    3196:	d8 8a       	std	Y+16, r13	; 0x10
    3198:	cf 86       	std	Y+15, r12	; 0x0f
    319a:	ba 8a       	std	Y+18, r11	; 0x12
    319c:	a9 8a       	std	Y+17, r10	; 0x11
    319e:	9c 8a       	std	Y+20, r9	; 0x14
    31a0:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    31a2:	e9 89       	ldd	r30, Y+17	; 0x11
    31a4:	fa 89       	ldd	r31, Y+18	; 0x12
    31a6:	27 89       	ldd	r18, Z+23	; 0x17
    31a8:	30 8d       	ldd	r19, Z+24	; 0x18
    31aa:	88 85       	ldd	r24, Y+8	; 0x08
    31ac:	99 85       	ldd	r25, Y+9	; 0x09
    31ae:	01 97       	sbiw	r24, 0x01	; 1
    31b0:	82 0f       	add	r24, r18
    31b2:	93 1f       	adc	r25, r19
    31b4:	9b 83       	std	Y+3, r25	; 0x03
    31b6:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    31b8:	8e 81       	ldd	r24, Y+6	; 0x06
    31ba:	9f 81       	ldd	r25, Y+7	; 0x07
    31bc:	00 97       	sbiw	r24, 0x00	; 0
    31be:	51 f1       	breq	.+84     	; 0x3214 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    31c0:	19 82       	std	Y+1, r1	; 0x01
    31c2:	21 c0       	rjmp	.+66     	; 0x3206 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    31c4:	89 81       	ldd	r24, Y+1	; 0x01
    31c6:	48 2f       	mov	r20, r24
    31c8:	50 e0       	ldi	r21, 0x00	; 0
    31ca:	89 81       	ldd	r24, Y+1	; 0x01
    31cc:	28 2f       	mov	r18, r24
    31ce:	30 e0       	ldi	r19, 0x00	; 0
    31d0:	8e 81       	ldd	r24, Y+6	; 0x06
    31d2:	9f 81       	ldd	r25, Y+7	; 0x07
    31d4:	fc 01       	movw	r30, r24
    31d6:	e2 0f       	add	r30, r18
    31d8:	f3 1f       	adc	r31, r19
    31da:	20 81       	ld	r18, Z
    31dc:	89 89       	ldd	r24, Y+17	; 0x11
    31de:	9a 89       	ldd	r25, Y+18	; 0x12
    31e0:	84 0f       	add	r24, r20
    31e2:	95 1f       	adc	r25, r21
    31e4:	fc 01       	movw	r30, r24
    31e6:	79 96       	adiw	r30, 0x19	; 25
    31e8:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    31ea:	89 81       	ldd	r24, Y+1	; 0x01
    31ec:	28 2f       	mov	r18, r24
    31ee:	30 e0       	ldi	r19, 0x00	; 0
    31f0:	8e 81       	ldd	r24, Y+6	; 0x06
    31f2:	9f 81       	ldd	r25, Y+7	; 0x07
    31f4:	fc 01       	movw	r30, r24
    31f6:	e2 0f       	add	r30, r18
    31f8:	f3 1f       	adc	r31, r19
    31fa:	80 81       	ld	r24, Z
    31fc:	88 23       	and	r24, r24
    31fe:	31 f0       	breq	.+12     	; 0x320c <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3200:	89 81       	ldd	r24, Y+1	; 0x01
    3202:	8f 5f       	subi	r24, 0xFF	; 255
    3204:	89 83       	std	Y+1, r24	; 0x01
    3206:	89 81       	ldd	r24, Y+1	; 0x01
    3208:	88 30       	cpi	r24, 0x08	; 8
    320a:	e0 f2       	brcs	.-72     	; 0x31c4 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    320c:	e9 89       	ldd	r30, Y+17	; 0x11
    320e:	fa 89       	ldd	r31, Y+18	; 0x12
    3210:	10 a2       	std	Z+32, r1	; 0x20
    3212:	03 c0       	rjmp	.+6      	; 0x321a <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3214:	e9 89       	ldd	r30, Y+17	; 0x11
    3216:	fa 89       	ldd	r31, Y+18	; 0x12
    3218:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    321a:	8e 85       	ldd	r24, Y+14	; 0x0e
    321c:	84 30       	cpi	r24, 0x04	; 4
    321e:	10 f0       	brcs	.+4      	; 0x3224 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3220:	83 e0       	ldi	r24, 0x03	; 3
    3222:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    3224:	e9 89       	ldd	r30, Y+17	; 0x11
    3226:	fa 89       	ldd	r31, Y+18	; 0x12
    3228:	8e 85       	ldd	r24, Y+14	; 0x0e
    322a:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    322c:	89 89       	ldd	r24, Y+17	; 0x11
    322e:	9a 89       	ldd	r25, Y+18	; 0x12
    3230:	02 96       	adiw	r24, 0x02	; 2
    3232:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3236:	89 89       	ldd	r24, Y+17	; 0x11
    3238:	9a 89       	ldd	r25, Y+18	; 0x12
    323a:	0c 96       	adiw	r24, 0x0c	; 12
    323c:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3240:	e9 89       	ldd	r30, Y+17	; 0x11
    3242:	fa 89       	ldd	r31, Y+18	; 0x12
    3244:	89 89       	ldd	r24, Y+17	; 0x11
    3246:	9a 89       	ldd	r25, Y+18	; 0x12
    3248:	91 87       	std	Z+9, r25	; 0x09
    324a:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    324c:	8e 85       	ldd	r24, Y+14	; 0x0e
    324e:	28 2f       	mov	r18, r24
    3250:	30 e0       	ldi	r19, 0x00	; 0
    3252:	84 e0       	ldi	r24, 0x04	; 4
    3254:	90 e0       	ldi	r25, 0x00	; 0
    3256:	82 1b       	sub	r24, r18
    3258:	93 0b       	sbc	r25, r19
    325a:	e9 89       	ldd	r30, Y+17	; 0x11
    325c:	fa 89       	ldd	r31, Y+18	; 0x12
    325e:	95 87       	std	Z+13, r25	; 0x0d
    3260:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3262:	e9 89       	ldd	r30, Y+17	; 0x11
    3264:	fa 89       	ldd	r31, Y+18	; 0x12
    3266:	89 89       	ldd	r24, Y+17	; 0x11
    3268:	9a 89       	ldd	r25, Y+18	; 0x12
    326a:	93 8b       	std	Z+19, r25	; 0x13
    326c:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    326e:	89 89       	ldd	r24, Y+17	; 0x11
    3270:	9a 89       	ldd	r25, Y+18	; 0x12
    3272:	81 96       	adiw	r24, 0x21	; 33
    3274:	60 e0       	ldi	r22, 0x00	; 0
    3276:	70 e0       	ldi	r23, 0x00	; 0
    3278:	44 e0       	ldi	r20, 0x04	; 4
    327a:	50 e0       	ldi	r21, 0x00	; 0
    327c:	0e 94 d9 32 	call	0x65b2	; 0x65b2 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    3280:	89 89       	ldd	r24, Y+17	; 0x11
    3282:	9a 89       	ldd	r25, Y+18	; 0x12
    3284:	85 96       	adiw	r24, 0x25	; 37
    3286:	60 e0       	ldi	r22, 0x00	; 0
    3288:	70 e0       	ldi	r23, 0x00	; 0
    328a:	41 e0       	ldi	r20, 0x01	; 1
    328c:	50 e0       	ldi	r21, 0x00	; 0
    328e:	0e 94 d9 32 	call	0x65b2	; 0x65b2 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3292:	8a 81       	ldd	r24, Y+2	; 0x02
    3294:	9b 81       	ldd	r25, Y+3	; 0x03
    3296:	2c 81       	ldd	r18, Y+4	; 0x04
    3298:	3d 81       	ldd	r19, Y+5	; 0x05
    329a:	4c 85       	ldd	r20, Y+12	; 0x0c
    329c:	5d 85       	ldd	r21, Y+13	; 0x0d
    329e:	b9 01       	movw	r22, r18
    32a0:	0e 94 c9 00 	call	0x192	; 0x192 <pxPortInitialiseStack>
    32a4:	e9 89       	ldd	r30, Y+17	; 0x11
    32a6:	fa 89       	ldd	r31, Y+18	; 0x12
    32a8:	91 83       	std	Z+1, r25	; 0x01
    32aa:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    32ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    32ae:	98 89       	ldd	r25, Y+16	; 0x10
    32b0:	00 97       	sbiw	r24, 0x00	; 0
    32b2:	31 f0       	breq	.+12     	; 0x32c0 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    32b4:	ef 85       	ldd	r30, Y+15	; 0x0f
    32b6:	f8 89       	ldd	r31, Y+16	; 0x10
    32b8:	89 89       	ldd	r24, Y+17	; 0x11
    32ba:	9a 89       	ldd	r25, Y+18	; 0x12
    32bc:	91 83       	std	Z+1, r25	; 0x01
    32be:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    32c0:	64 96       	adiw	r28, 0x14	; 20
    32c2:	0f b6       	in	r0, 0x3f	; 63
    32c4:	f8 94       	cli
    32c6:	de bf       	out	0x3e, r29	; 62
    32c8:	0f be       	out	0x3f, r0	; 63
    32ca:	cd bf       	out	0x3d, r28	; 61
    32cc:	cf 91       	pop	r28
    32ce:	df 91       	pop	r29
    32d0:	1f 91       	pop	r17
    32d2:	0f 91       	pop	r16
    32d4:	ef 90       	pop	r14
    32d6:	df 90       	pop	r13
    32d8:	cf 90       	pop	r12
    32da:	bf 90       	pop	r11
    32dc:	af 90       	pop	r10
    32de:	9f 90       	pop	r9
    32e0:	8f 90       	pop	r8
    32e2:	08 95       	ret

000032e4 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    32e4:	df 93       	push	r29
    32e6:	cf 93       	push	r28
    32e8:	00 d0       	rcall	.+0      	; 0x32ea <prvAddNewTaskToReadyList+0x6>
    32ea:	00 d0       	rcall	.+0      	; 0x32ec <prvAddNewTaskToReadyList+0x8>
    32ec:	cd b7       	in	r28, 0x3d	; 61
    32ee:	de b7       	in	r29, 0x3e	; 62
    32f0:	9c 83       	std	Y+4, r25	; 0x04
    32f2:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    32f4:	0f b6       	in	r0, 0x3f	; 63
    32f6:	f8 94       	cli
    32f8:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    32fa:	80 91 a9 06 	lds	r24, 0x06A9
    32fe:	8f 5f       	subi	r24, 0xFF	; 255
    3300:	80 93 a9 06 	sts	0x06A9, r24

        if( pxCurrentTCB == NULL )
    3304:	80 91 a6 06 	lds	r24, 0x06A6
    3308:	90 91 a7 06 	lds	r25, 0x06A7
    330c:	00 97       	sbiw	r24, 0x00	; 0
    330e:	69 f4       	brne	.+26     	; 0x332a <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3310:	8b 81       	ldd	r24, Y+3	; 0x03
    3312:	9c 81       	ldd	r25, Y+4	; 0x04
    3314:	90 93 a7 06 	sts	0x06A7, r25
    3318:	80 93 a6 06 	sts	0x06A6, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    331c:	80 91 a9 06 	lds	r24, 0x06A9
    3320:	81 30       	cpi	r24, 0x01	; 1
    3322:	b9 f4       	brne	.+46     	; 0x3352 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    3324:	0e 94 56 23 	call	0x46ac	; 0x46ac <prvInitialiseTaskLists>
    3328:	14 c0       	rjmp	.+40     	; 0x3352 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    332a:	80 91 ad 06 	lds	r24, 0x06AD
    332e:	88 23       	and	r24, r24
    3330:	81 f4       	brne	.+32     	; 0x3352 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3332:	e0 91 a6 06 	lds	r30, 0x06A6
    3336:	f0 91 a7 06 	lds	r31, 0x06A7
    333a:	96 89       	ldd	r25, Z+22	; 0x16
    333c:	eb 81       	ldd	r30, Y+3	; 0x03
    333e:	fc 81       	ldd	r31, Y+4	; 0x04
    3340:	86 89       	ldd	r24, Z+22	; 0x16
    3342:	89 17       	cp	r24, r25
    3344:	30 f0       	brcs	.+12     	; 0x3352 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    3346:	8b 81       	ldd	r24, Y+3	; 0x03
    3348:	9c 81       	ldd	r25, Y+4	; 0x04
    334a:	90 93 a7 06 	sts	0x06A7, r25
    334e:	80 93 a6 06 	sts	0x06A6, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    3352:	80 91 b2 06 	lds	r24, 0x06B2
    3356:	8f 5f       	subi	r24, 0xFF	; 255
    3358:	80 93 b2 06 	sts	0x06B2, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    335c:	eb 81       	ldd	r30, Y+3	; 0x03
    335e:	fc 81       	ldd	r31, Y+4	; 0x04
    3360:	96 89       	ldd	r25, Z+22	; 0x16
    3362:	80 91 ac 06 	lds	r24, 0x06AC
    3366:	89 17       	cp	r24, r25
    3368:	28 f4       	brcc	.+10     	; 0x3374 <prvAddNewTaskToReadyList+0x90>
    336a:	eb 81       	ldd	r30, Y+3	; 0x03
    336c:	fc 81       	ldd	r31, Y+4	; 0x04
    336e:	86 89       	ldd	r24, Z+22	; 0x16
    3370:	80 93 ac 06 	sts	0x06AC, r24
    3374:	eb 81       	ldd	r30, Y+3	; 0x03
    3376:	fc 81       	ldd	r31, Y+4	; 0x04
    3378:	86 89       	ldd	r24, Z+22	; 0x16
    337a:	28 2f       	mov	r18, r24
    337c:	30 e0       	ldi	r19, 0x00	; 0
    337e:	c9 01       	movw	r24, r18
    3380:	88 0f       	add	r24, r24
    3382:	99 1f       	adc	r25, r25
    3384:	88 0f       	add	r24, r24
    3386:	99 1f       	adc	r25, r25
    3388:	88 0f       	add	r24, r24
    338a:	99 1f       	adc	r25, r25
    338c:	82 0f       	add	r24, r18
    338e:	93 1f       	adc	r25, r19
    3390:	fc 01       	movw	r30, r24
    3392:	e8 54       	subi	r30, 0x48	; 72
    3394:	f9 4f       	sbci	r31, 0xF9	; 249
    3396:	81 81       	ldd	r24, Z+1	; 0x01
    3398:	92 81       	ldd	r25, Z+2	; 0x02
    339a:	9a 83       	std	Y+2, r25	; 0x02
    339c:	89 83       	std	Y+1, r24	; 0x01
    339e:	eb 81       	ldd	r30, Y+3	; 0x03
    33a0:	fc 81       	ldd	r31, Y+4	; 0x04
    33a2:	89 81       	ldd	r24, Y+1	; 0x01
    33a4:	9a 81       	ldd	r25, Y+2	; 0x02
    33a6:	95 83       	std	Z+5, r25	; 0x05
    33a8:	84 83       	std	Z+4, r24	; 0x04
    33aa:	e9 81       	ldd	r30, Y+1	; 0x01
    33ac:	fa 81       	ldd	r31, Y+2	; 0x02
    33ae:	84 81       	ldd	r24, Z+4	; 0x04
    33b0:	95 81       	ldd	r25, Z+5	; 0x05
    33b2:	eb 81       	ldd	r30, Y+3	; 0x03
    33b4:	fc 81       	ldd	r31, Y+4	; 0x04
    33b6:	97 83       	std	Z+7, r25	; 0x07
    33b8:	86 83       	std	Z+6, r24	; 0x06
    33ba:	e9 81       	ldd	r30, Y+1	; 0x01
    33bc:	fa 81       	ldd	r31, Y+2	; 0x02
    33be:	04 80       	ldd	r0, Z+4	; 0x04
    33c0:	f5 81       	ldd	r31, Z+5	; 0x05
    33c2:	e0 2d       	mov	r30, r0
    33c4:	8b 81       	ldd	r24, Y+3	; 0x03
    33c6:	9c 81       	ldd	r25, Y+4	; 0x04
    33c8:	02 96       	adiw	r24, 0x02	; 2
    33ca:	93 83       	std	Z+3, r25	; 0x03
    33cc:	82 83       	std	Z+2, r24	; 0x02
    33ce:	8b 81       	ldd	r24, Y+3	; 0x03
    33d0:	9c 81       	ldd	r25, Y+4	; 0x04
    33d2:	02 96       	adiw	r24, 0x02	; 2
    33d4:	e9 81       	ldd	r30, Y+1	; 0x01
    33d6:	fa 81       	ldd	r31, Y+2	; 0x02
    33d8:	95 83       	std	Z+5, r25	; 0x05
    33da:	84 83       	std	Z+4, r24	; 0x04
    33dc:	eb 81       	ldd	r30, Y+3	; 0x03
    33de:	fc 81       	ldd	r31, Y+4	; 0x04
    33e0:	86 89       	ldd	r24, Z+22	; 0x16
    33e2:	28 2f       	mov	r18, r24
    33e4:	30 e0       	ldi	r19, 0x00	; 0
    33e6:	c9 01       	movw	r24, r18
    33e8:	88 0f       	add	r24, r24
    33ea:	99 1f       	adc	r25, r25
    33ec:	88 0f       	add	r24, r24
    33ee:	99 1f       	adc	r25, r25
    33f0:	88 0f       	add	r24, r24
    33f2:	99 1f       	adc	r25, r25
    33f4:	82 0f       	add	r24, r18
    33f6:	93 1f       	adc	r25, r19
    33f8:	88 54       	subi	r24, 0x48	; 72
    33fa:	99 4f       	sbci	r25, 0xF9	; 249
    33fc:	eb 81       	ldd	r30, Y+3	; 0x03
    33fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3400:	93 87       	std	Z+11, r25	; 0x0b
    3402:	82 87       	std	Z+10, r24	; 0x0a
    3404:	eb 81       	ldd	r30, Y+3	; 0x03
    3406:	fc 81       	ldd	r31, Y+4	; 0x04
    3408:	86 89       	ldd	r24, Z+22	; 0x16
    340a:	28 2f       	mov	r18, r24
    340c:	30 e0       	ldi	r19, 0x00	; 0
    340e:	c9 01       	movw	r24, r18
    3410:	88 0f       	add	r24, r24
    3412:	99 1f       	adc	r25, r25
    3414:	88 0f       	add	r24, r24
    3416:	99 1f       	adc	r25, r25
    3418:	88 0f       	add	r24, r24
    341a:	99 1f       	adc	r25, r25
    341c:	82 0f       	add	r24, r18
    341e:	93 1f       	adc	r25, r19
    3420:	fc 01       	movw	r30, r24
    3422:	e8 54       	subi	r30, 0x48	; 72
    3424:	f9 4f       	sbci	r31, 0xF9	; 249
    3426:	80 81       	ld	r24, Z
    3428:	8f 5f       	subi	r24, 0xFF	; 255
    342a:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    342c:	0f 90       	pop	r0
    342e:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    3430:	80 91 ad 06 	lds	r24, 0x06AD
    3434:	88 23       	and	r24, r24
    3436:	61 f0       	breq	.+24     	; 0x3450 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3438:	e0 91 a6 06 	lds	r30, 0x06A6
    343c:	f0 91 a7 06 	lds	r31, 0x06A7
    3440:	96 89       	ldd	r25, Z+22	; 0x16
    3442:	eb 81       	ldd	r30, Y+3	; 0x03
    3444:	fc 81       	ldd	r31, Y+4	; 0x04
    3446:	86 89       	ldd	r24, Z+22	; 0x16
    3448:	98 17       	cp	r25, r24
    344a:	10 f4       	brcc	.+4      	; 0x3450 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    344c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3450:	0f 90       	pop	r0
    3452:	0f 90       	pop	r0
    3454:	0f 90       	pop	r0
    3456:	0f 90       	pop	r0
    3458:	cf 91       	pop	r28
    345a:	df 91       	pop	r29
    345c:	08 95       	ret

0000345e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    345e:	df 93       	push	r29
    3460:	cf 93       	push	r28
    3462:	00 d0       	rcall	.+0      	; 0x3464 <vTaskDelete+0x6>
    3464:	00 d0       	rcall	.+0      	; 0x3466 <vTaskDelete+0x8>
    3466:	00 d0       	rcall	.+0      	; 0x3468 <vTaskDelete+0xa>
    3468:	cd b7       	in	r28, 0x3d	; 61
    346a:	de b7       	in	r29, 0x3e	; 62
    346c:	9c 83       	std	Y+4, r25	; 0x04
    346e:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    3470:	0f b6       	in	r0, 0x3f	; 63
    3472:	f8 94       	cli
    3474:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3476:	8b 81       	ldd	r24, Y+3	; 0x03
    3478:	9c 81       	ldd	r25, Y+4	; 0x04
    347a:	00 97       	sbiw	r24, 0x00	; 0
    347c:	39 f4       	brne	.+14     	; 0x348c <vTaskDelete+0x2e>
    347e:	80 91 a6 06 	lds	r24, 0x06A6
    3482:	90 91 a7 06 	lds	r25, 0x06A7
    3486:	9e 83       	std	Y+6, r25	; 0x06
    3488:	8d 83       	std	Y+5, r24	; 0x05
    348a:	04 c0       	rjmp	.+8      	; 0x3494 <vTaskDelete+0x36>
    348c:	8b 81       	ldd	r24, Y+3	; 0x03
    348e:	9c 81       	ldd	r25, Y+4	; 0x04
    3490:	9e 83       	std	Y+6, r25	; 0x06
    3492:	8d 83       	std	Y+5, r24	; 0x05
    3494:	8d 81       	ldd	r24, Y+5	; 0x05
    3496:	9e 81       	ldd	r25, Y+6	; 0x06
    3498:	9a 83       	std	Y+2, r25	; 0x02
    349a:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    349c:	89 81       	ldd	r24, Y+1	; 0x01
    349e:	9a 81       	ldd	r25, Y+2	; 0x02
    34a0:	02 96       	adiw	r24, 0x02	; 2
    34a2:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    34a6:	e9 81       	ldd	r30, Y+1	; 0x01
    34a8:	fa 81       	ldd	r31, Y+2	; 0x02
    34aa:	84 89       	ldd	r24, Z+20	; 0x14
    34ac:	95 89       	ldd	r25, Z+21	; 0x15
    34ae:	00 97       	sbiw	r24, 0x00	; 0
    34b0:	29 f0       	breq	.+10     	; 0x34bc <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    34b2:	89 81       	ldd	r24, Y+1	; 0x01
    34b4:	9a 81       	ldd	r25, Y+2	; 0x02
    34b6:	0c 96       	adiw	r24, 0x0c	; 12
    34b8:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    34bc:	80 91 b2 06 	lds	r24, 0x06B2
    34c0:	8f 5f       	subi	r24, 0xFF	; 255
    34c2:	80 93 b2 06 	sts	0x06B2, r24

            if( pxTCB == pxCurrentTCB )
    34c6:	20 91 a6 06 	lds	r18, 0x06A6
    34ca:	30 91 a7 06 	lds	r19, 0x06A7
    34ce:	89 81       	ldd	r24, Y+1	; 0x01
    34d0:	9a 81       	ldd	r25, Y+2	; 0x02
    34d2:	82 17       	cp	r24, r18
    34d4:	93 07       	cpc	r25, r19
    34d6:	81 f4       	brne	.+32     	; 0x34f8 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    34d8:	89 81       	ldd	r24, Y+1	; 0x01
    34da:	9a 81       	ldd	r25, Y+2	; 0x02
    34dc:	9c 01       	movw	r18, r24
    34de:	2e 5f       	subi	r18, 0xFE	; 254
    34e0:	3f 4f       	sbci	r19, 0xFF	; 255
    34e2:	8b ef       	ldi	r24, 0xFB	; 251
    34e4:	96 e0       	ldi	r25, 0x06	; 6
    34e6:	b9 01       	movw	r22, r18
    34e8:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    34ec:	80 91 a8 06 	lds	r24, 0x06A8
    34f0:	8f 5f       	subi	r24, 0xFF	; 255
    34f2:	80 93 a8 06 	sts	0x06A8, r24
    34f6:	07 c0       	rjmp	.+14     	; 0x3506 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    34f8:	80 91 a9 06 	lds	r24, 0x06A9
    34fc:	81 50       	subi	r24, 0x01	; 1
    34fe:	80 93 a9 06 	sts	0x06A9, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    3502:	0e 94 d8 23 	call	0x47b0	; 0x47b0 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    3506:	0f 90       	pop	r0
    3508:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    350a:	20 91 a6 06 	lds	r18, 0x06A6
    350e:	30 91 a7 06 	lds	r19, 0x06A7
    3512:	89 81       	ldd	r24, Y+1	; 0x01
    3514:	9a 81       	ldd	r25, Y+2	; 0x02
    3516:	82 17       	cp	r24, r18
    3518:	93 07       	cpc	r25, r19
    351a:	21 f0       	breq	.+8      	; 0x3524 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    351c:	89 81       	ldd	r24, Y+1	; 0x01
    351e:	9a 81       	ldd	r25, Y+2	; 0x02
    3520:	0e 94 c2 23 	call	0x4784	; 0x4784 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    3524:	80 91 ad 06 	lds	r24, 0x06AD
    3528:	88 23       	and	r24, r24
    352a:	59 f0       	breq	.+22     	; 0x3542 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    352c:	20 91 a6 06 	lds	r18, 0x06A6
    3530:	30 91 a7 06 	lds	r19, 0x06A7
    3534:	89 81       	ldd	r24, Y+1	; 0x01
    3536:	9a 81       	ldd	r25, Y+2	; 0x02
    3538:	82 17       	cp	r24, r18
    353a:	93 07       	cpc	r25, r19
    353c:	11 f4       	brne	.+4      	; 0x3542 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    353e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    3542:	26 96       	adiw	r28, 0x06	; 6
    3544:	0f b6       	in	r0, 0x3f	; 63
    3546:	f8 94       	cli
    3548:	de bf       	out	0x3e, r29	; 62
    354a:	0f be       	out	0x3f, r0	; 63
    354c:	cd bf       	out	0x3d, r28	; 61
    354e:	cf 91       	pop	r28
    3550:	df 91       	pop	r29
    3552:	08 95       	ret

00003554 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    3554:	df 93       	push	r29
    3556:	cf 93       	push	r28
    3558:	cd b7       	in	r28, 0x3d	; 61
    355a:	de b7       	in	r29, 0x3e	; 62
    355c:	2a 97       	sbiw	r28, 0x0a	; 10
    355e:	0f b6       	in	r0, 0x3f	; 63
    3560:	f8 94       	cli
    3562:	de bf       	out	0x3e, r29	; 62
    3564:	0f be       	out	0x3f, r0	; 63
    3566:	cd bf       	out	0x3d, r28	; 61
    3568:	98 87       	std	Y+8, r25	; 0x08
    356a:	8f 83       	std	Y+7, r24	; 0x07
    356c:	7a 87       	std	Y+10, r23	; 0x0a
    356e:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3570:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    3572:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3576:	80 91 aa 06 	lds	r24, 0x06AA
    357a:	90 91 ab 06 	lds	r25, 0x06AB
    357e:	9a 83       	std	Y+2, r25	; 0x02
    3580:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3582:	ef 81       	ldd	r30, Y+7	; 0x07
    3584:	f8 85       	ldd	r31, Y+8	; 0x08
    3586:	20 81       	ld	r18, Z
    3588:	31 81       	ldd	r19, Z+1	; 0x01
    358a:	89 85       	ldd	r24, Y+9	; 0x09
    358c:	9a 85       	ldd	r25, Y+10	; 0x0a
    358e:	82 0f       	add	r24, r18
    3590:	93 1f       	adc	r25, r19
    3592:	9e 83       	std	Y+6, r25	; 0x06
    3594:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    3596:	ef 81       	ldd	r30, Y+7	; 0x07
    3598:	f8 85       	ldd	r31, Y+8	; 0x08
    359a:	20 81       	ld	r18, Z
    359c:	31 81       	ldd	r19, Z+1	; 0x01
    359e:	89 81       	ldd	r24, Y+1	; 0x01
    35a0:	9a 81       	ldd	r25, Y+2	; 0x02
    35a2:	82 17       	cp	r24, r18
    35a4:	93 07       	cpc	r25, r19
    35a6:	98 f4       	brcc	.+38     	; 0x35ce <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    35a8:	ef 81       	ldd	r30, Y+7	; 0x07
    35aa:	f8 85       	ldd	r31, Y+8	; 0x08
    35ac:	20 81       	ld	r18, Z
    35ae:	31 81       	ldd	r19, Z+1	; 0x01
    35b0:	8d 81       	ldd	r24, Y+5	; 0x05
    35b2:	9e 81       	ldd	r25, Y+6	; 0x06
    35b4:	82 17       	cp	r24, r18
    35b6:	93 07       	cpc	r25, r19
    35b8:	e0 f4       	brcc	.+56     	; 0x35f2 <xTaskDelayUntil+0x9e>
    35ba:	2d 81       	ldd	r18, Y+5	; 0x05
    35bc:	3e 81       	ldd	r19, Y+6	; 0x06
    35be:	89 81       	ldd	r24, Y+1	; 0x01
    35c0:	9a 81       	ldd	r25, Y+2	; 0x02
    35c2:	82 17       	cp	r24, r18
    35c4:	93 07       	cpc	r25, r19
    35c6:	a8 f4       	brcc	.+42     	; 0x35f2 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    35c8:	81 e0       	ldi	r24, 0x01	; 1
    35ca:	8b 83       	std	Y+3, r24	; 0x03
    35cc:	12 c0       	rjmp	.+36     	; 0x35f2 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    35ce:	ef 81       	ldd	r30, Y+7	; 0x07
    35d0:	f8 85       	ldd	r31, Y+8	; 0x08
    35d2:	20 81       	ld	r18, Z
    35d4:	31 81       	ldd	r19, Z+1	; 0x01
    35d6:	8d 81       	ldd	r24, Y+5	; 0x05
    35d8:	9e 81       	ldd	r25, Y+6	; 0x06
    35da:	82 17       	cp	r24, r18
    35dc:	93 07       	cpc	r25, r19
    35de:	38 f0       	brcs	.+14     	; 0x35ee <xTaskDelayUntil+0x9a>
    35e0:	2d 81       	ldd	r18, Y+5	; 0x05
    35e2:	3e 81       	ldd	r19, Y+6	; 0x06
    35e4:	89 81       	ldd	r24, Y+1	; 0x01
    35e6:	9a 81       	ldd	r25, Y+2	; 0x02
    35e8:	82 17       	cp	r24, r18
    35ea:	93 07       	cpc	r25, r19
    35ec:	10 f4       	brcc	.+4      	; 0x35f2 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    35ee:	81 e0       	ldi	r24, 0x01	; 1
    35f0:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    35f2:	ef 81       	ldd	r30, Y+7	; 0x07
    35f4:	f8 85       	ldd	r31, Y+8	; 0x08
    35f6:	8d 81       	ldd	r24, Y+5	; 0x05
    35f8:	9e 81       	ldd	r25, Y+6	; 0x06
    35fa:	91 83       	std	Z+1, r25	; 0x01
    35fc:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    35fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3600:	88 23       	and	r24, r24
    3602:	49 f0       	breq	.+18     	; 0x3616 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3604:	8d 81       	ldd	r24, Y+5	; 0x05
    3606:	9e 81       	ldd	r25, Y+6	; 0x06
    3608:	29 81       	ldd	r18, Y+1	; 0x01
    360a:	3a 81       	ldd	r19, Y+2	; 0x02
    360c:	82 1b       	sub	r24, r18
    360e:	93 0b       	sbc	r25, r19
    3610:	60 e0       	ldi	r22, 0x00	; 0
    3612:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    3616:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    361a:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    361c:	8c 81       	ldd	r24, Y+4	; 0x04
    361e:	88 23       	and	r24, r24
    3620:	11 f4       	brne	.+4      	; 0x3626 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    3622:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    3626:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3628:	2a 96       	adiw	r28, 0x0a	; 10
    362a:	0f b6       	in	r0, 0x3f	; 63
    362c:	f8 94       	cli
    362e:	de bf       	out	0x3e, r29	; 62
    3630:	0f be       	out	0x3f, r0	; 63
    3632:	cd bf       	out	0x3d, r28	; 61
    3634:	cf 91       	pop	r28
    3636:	df 91       	pop	r29
    3638:	08 95       	ret

0000363a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    363a:	df 93       	push	r29
    363c:	cf 93       	push	r28
    363e:	00 d0       	rcall	.+0      	; 0x3640 <vTaskDelay+0x6>
    3640:	0f 92       	push	r0
    3642:	cd b7       	in	r28, 0x3d	; 61
    3644:	de b7       	in	r29, 0x3e	; 62
    3646:	9b 83       	std	Y+3, r25	; 0x03
    3648:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    364a:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    364c:	8a 81       	ldd	r24, Y+2	; 0x02
    364e:	9b 81       	ldd	r25, Y+3	; 0x03
    3650:	00 97       	sbiw	r24, 0x00	; 0
    3652:	51 f0       	breq	.+20     	; 0x3668 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    3654:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3658:	8a 81       	ldd	r24, Y+2	; 0x02
    365a:	9b 81       	ldd	r25, Y+3	; 0x03
    365c:	60 e0       	ldi	r22, 0x00	; 0
    365e:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3662:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    3666:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3668:	89 81       	ldd	r24, Y+1	; 0x01
    366a:	88 23       	and	r24, r24
    366c:	11 f4       	brne	.+4      	; 0x3672 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    366e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3672:	0f 90       	pop	r0
    3674:	0f 90       	pop	r0
    3676:	0f 90       	pop	r0
    3678:	cf 91       	pop	r28
    367a:	df 91       	pop	r29
    367c:	08 95       	ret

0000367e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    367e:	ef 92       	push	r14
    3680:	ff 92       	push	r15
    3682:	0f 93       	push	r16
    3684:	df 93       	push	r29
    3686:	cf 93       	push	r28
    3688:	00 d0       	rcall	.+0      	; 0x368a <vTaskStartScheduler+0xc>
    368a:	cd b7       	in	r28, 0x3d	; 61
    368c:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    368e:	86 e4       	ldi	r24, 0x46	; 70
    3690:	93 e2       	ldi	r25, 0x23	; 35
    3692:	20 e6       	ldi	r18, 0x60	; 96
    3694:	30 e0       	ldi	r19, 0x00	; 0
    3696:	e5 eb       	ldi	r30, 0xB5	; 181
    3698:	f6 e0       	ldi	r31, 0x06	; 6
    369a:	b9 01       	movw	r22, r18
    369c:	45 e5       	ldi	r20, 0x55	; 85
    369e:	50 e0       	ldi	r21, 0x00	; 0
    36a0:	20 e0       	ldi	r18, 0x00	; 0
    36a2:	30 e0       	ldi	r19, 0x00	; 0
    36a4:	00 e0       	ldi	r16, 0x00	; 0
    36a6:	7f 01       	movw	r14, r30
    36a8:	0e 94 35 18 	call	0x306a	; 0x306a <xTaskCreate>
    36ac:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    36ae:	89 81       	ldd	r24, Y+1	; 0x01
    36b0:	81 30       	cpi	r24, 0x01	; 1
    36b2:	19 f4       	brne	.+6      	; 0x36ba <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    36b4:	0e 94 25 2c 	call	0x584a	; 0x584a <xTimerCreateTimerTask>
    36b8:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    36ba:	89 81       	ldd	r24, Y+1	; 0x01
    36bc:	81 30       	cpi	r24, 0x01	; 1
    36be:	81 f4       	brne	.+32     	; 0x36e0 <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    36c0:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    36c2:	8f ef       	ldi	r24, 0xFF	; 255
    36c4:	9f ef       	ldi	r25, 0xFF	; 255
    36c6:	90 93 b4 06 	sts	0x06B4, r25
    36ca:	80 93 b3 06 	sts	0x06B3, r24
        xSchedulerRunning = pdTRUE;
    36ce:	81 e0       	ldi	r24, 0x01	; 1
    36d0:	80 93 ad 06 	sts	0x06AD, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    36d4:	10 92 ab 06 	sts	0x06AB, r1
    36d8:	10 92 aa 06 	sts	0x06AA, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    36dc:	0e 94 4c 02 	call	0x498	; 0x498 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    36e0:	80 91 8a 00 	lds	r24, 0x008A
}
    36e4:	0f 90       	pop	r0
    36e6:	0f 90       	pop	r0
    36e8:	cf 91       	pop	r28
    36ea:	df 91       	pop	r29
    36ec:	0f 91       	pop	r16
    36ee:	ff 90       	pop	r15
    36f0:	ef 90       	pop	r14
    36f2:	08 95       	ret

000036f4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    36f4:	df 93       	push	r29
    36f6:	cf 93       	push	r28
    36f8:	cd b7       	in	r28, 0x3d	; 61
    36fa:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    36fc:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    36fe:	10 92 ad 06 	sts	0x06AD, r1
    vPortEndScheduler();
    3702:	0e 94 81 02 	call	0x502	; 0x502 <vPortEndScheduler>
}
    3706:	cf 91       	pop	r28
    3708:	df 91       	pop	r29
    370a:	08 95       	ret

0000370c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    370c:	df 93       	push	r29
    370e:	cf 93       	push	r28
    3710:	cd b7       	in	r28, 0x3d	; 61
    3712:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3714:	80 91 b7 06 	lds	r24, 0x06B7
    3718:	8f 5f       	subi	r24, 0xFF	; 255
    371a:	80 93 b7 06 	sts	0x06B7, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    371e:	cf 91       	pop	r28
    3720:	df 91       	pop	r29
    3722:	08 95       	ret

00003724 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3724:	df 93       	push	r29
    3726:	cf 93       	push	r28
    3728:	cd b7       	in	r28, 0x3d	; 61
    372a:	de b7       	in	r29, 0x3e	; 62
    372c:	2b 97       	sbiw	r28, 0x0b	; 11
    372e:	0f b6       	in	r0, 0x3f	; 63
    3730:	f8 94       	cli
    3732:	de bf       	out	0x3e, r29	; 62
    3734:	0f be       	out	0x3f, r0	; 63
    3736:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    3738:	1b 86       	std	Y+11, r1	; 0x0b
    373a:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    373c:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    373e:	0f b6       	in	r0, 0x3f	; 63
    3740:	f8 94       	cli
    3742:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3744:	80 91 b7 06 	lds	r24, 0x06B7
    3748:	81 50       	subi	r24, 0x01	; 1
    374a:	80 93 b7 06 	sts	0x06B7, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    374e:	80 91 b7 06 	lds	r24, 0x06B7
    3752:	88 23       	and	r24, r24
    3754:	09 f0       	breq	.+2      	; 0x3758 <xTaskResumeAll+0x34>
    3756:	2a c1       	rjmp	.+596    	; 0x39ac <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3758:	80 91 a9 06 	lds	r24, 0x06A9
    375c:	88 23       	and	r24, r24
    375e:	09 f4       	brne	.+2      	; 0x3762 <xTaskResumeAll+0x3e>
    3760:	25 c1       	rjmp	.+586    	; 0x39ac <xTaskResumeAll+0x288>
    3762:	f3 c0       	rjmp	.+486    	; 0x394a <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3764:	e0 91 f7 06 	lds	r30, 0x06F7
    3768:	f0 91 f8 06 	lds	r31, 0x06F8
    376c:	86 81       	ldd	r24, Z+6	; 0x06
    376e:	97 81       	ldd	r25, Z+7	; 0x07
    3770:	9b 87       	std	Y+11, r25	; 0x0b
    3772:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3774:	ea 85       	ldd	r30, Y+10	; 0x0a
    3776:	fb 85       	ldd	r31, Y+11	; 0x0b
    3778:	84 89       	ldd	r24, Z+20	; 0x14
    377a:	95 89       	ldd	r25, Z+21	; 0x15
    377c:	98 87       	std	Y+8, r25	; 0x08
    377e:	8f 83       	std	Y+7, r24	; 0x07
    3780:	ea 85       	ldd	r30, Y+10	; 0x0a
    3782:	fb 85       	ldd	r31, Y+11	; 0x0b
    3784:	a6 85       	ldd	r26, Z+14	; 0x0e
    3786:	b7 85       	ldd	r27, Z+15	; 0x0f
    3788:	ea 85       	ldd	r30, Y+10	; 0x0a
    378a:	fb 85       	ldd	r31, Y+11	; 0x0b
    378c:	80 89       	ldd	r24, Z+16	; 0x10
    378e:	91 89       	ldd	r25, Z+17	; 0x11
    3790:	15 96       	adiw	r26, 0x05	; 5
    3792:	9c 93       	st	X, r25
    3794:	8e 93       	st	-X, r24
    3796:	14 97       	sbiw	r26, 0x04	; 4
    3798:	ea 85       	ldd	r30, Y+10	; 0x0a
    379a:	fb 85       	ldd	r31, Y+11	; 0x0b
    379c:	a0 89       	ldd	r26, Z+16	; 0x10
    379e:	b1 89       	ldd	r27, Z+17	; 0x11
    37a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    37a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    37a4:	86 85       	ldd	r24, Z+14	; 0x0e
    37a6:	97 85       	ldd	r25, Z+15	; 0x0f
    37a8:	13 96       	adiw	r26, 0x03	; 3
    37aa:	9c 93       	st	X, r25
    37ac:	8e 93       	st	-X, r24
    37ae:	12 97       	sbiw	r26, 0x02	; 2
    37b0:	ef 81       	ldd	r30, Y+7	; 0x07
    37b2:	f8 85       	ldd	r31, Y+8	; 0x08
    37b4:	21 81       	ldd	r18, Z+1	; 0x01
    37b6:	32 81       	ldd	r19, Z+2	; 0x02
    37b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    37ba:	9b 85       	ldd	r25, Y+11	; 0x0b
    37bc:	0c 96       	adiw	r24, 0x0c	; 12
    37be:	28 17       	cp	r18, r24
    37c0:	39 07       	cpc	r19, r25
    37c2:	41 f4       	brne	.+16     	; 0x37d4 <xTaskResumeAll+0xb0>
    37c4:	ea 85       	ldd	r30, Y+10	; 0x0a
    37c6:	fb 85       	ldd	r31, Y+11	; 0x0b
    37c8:	80 89       	ldd	r24, Z+16	; 0x10
    37ca:	91 89       	ldd	r25, Z+17	; 0x11
    37cc:	ef 81       	ldd	r30, Y+7	; 0x07
    37ce:	f8 85       	ldd	r31, Y+8	; 0x08
    37d0:	92 83       	std	Z+2, r25	; 0x02
    37d2:	81 83       	std	Z+1, r24	; 0x01
    37d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    37d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    37d8:	15 8a       	std	Z+21, r1	; 0x15
    37da:	14 8a       	std	Z+20, r1	; 0x14
    37dc:	ef 81       	ldd	r30, Y+7	; 0x07
    37de:	f8 85       	ldd	r31, Y+8	; 0x08
    37e0:	80 81       	ld	r24, Z
    37e2:	81 50       	subi	r24, 0x01	; 1
    37e4:	ef 81       	ldd	r30, Y+7	; 0x07
    37e6:	f8 85       	ldd	r31, Y+8	; 0x08
    37e8:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    37ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    37ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    37ee:	82 85       	ldd	r24, Z+10	; 0x0a
    37f0:	93 85       	ldd	r25, Z+11	; 0x0b
    37f2:	9e 83       	std	Y+6, r25	; 0x06
    37f4:	8d 83       	std	Y+5, r24	; 0x05
    37f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    37f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    37fa:	a4 81       	ldd	r26, Z+4	; 0x04
    37fc:	b5 81       	ldd	r27, Z+5	; 0x05
    37fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    3800:	fb 85       	ldd	r31, Y+11	; 0x0b
    3802:	86 81       	ldd	r24, Z+6	; 0x06
    3804:	97 81       	ldd	r25, Z+7	; 0x07
    3806:	15 96       	adiw	r26, 0x05	; 5
    3808:	9c 93       	st	X, r25
    380a:	8e 93       	st	-X, r24
    380c:	14 97       	sbiw	r26, 0x04	; 4
    380e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3810:	fb 85       	ldd	r31, Y+11	; 0x0b
    3812:	a6 81       	ldd	r26, Z+6	; 0x06
    3814:	b7 81       	ldd	r27, Z+7	; 0x07
    3816:	ea 85       	ldd	r30, Y+10	; 0x0a
    3818:	fb 85       	ldd	r31, Y+11	; 0x0b
    381a:	84 81       	ldd	r24, Z+4	; 0x04
    381c:	95 81       	ldd	r25, Z+5	; 0x05
    381e:	13 96       	adiw	r26, 0x03	; 3
    3820:	9c 93       	st	X, r25
    3822:	8e 93       	st	-X, r24
    3824:	12 97       	sbiw	r26, 0x02	; 2
    3826:	ed 81       	ldd	r30, Y+5	; 0x05
    3828:	fe 81       	ldd	r31, Y+6	; 0x06
    382a:	21 81       	ldd	r18, Z+1	; 0x01
    382c:	32 81       	ldd	r19, Z+2	; 0x02
    382e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3830:	9b 85       	ldd	r25, Y+11	; 0x0b
    3832:	02 96       	adiw	r24, 0x02	; 2
    3834:	28 17       	cp	r18, r24
    3836:	39 07       	cpc	r19, r25
    3838:	41 f4       	brne	.+16     	; 0x384a <xTaskResumeAll+0x126>
    383a:	ea 85       	ldd	r30, Y+10	; 0x0a
    383c:	fb 85       	ldd	r31, Y+11	; 0x0b
    383e:	86 81       	ldd	r24, Z+6	; 0x06
    3840:	97 81       	ldd	r25, Z+7	; 0x07
    3842:	ed 81       	ldd	r30, Y+5	; 0x05
    3844:	fe 81       	ldd	r31, Y+6	; 0x06
    3846:	92 83       	std	Z+2, r25	; 0x02
    3848:	81 83       	std	Z+1, r24	; 0x01
    384a:	ea 85       	ldd	r30, Y+10	; 0x0a
    384c:	fb 85       	ldd	r31, Y+11	; 0x0b
    384e:	13 86       	std	Z+11, r1	; 0x0b
    3850:	12 86       	std	Z+10, r1	; 0x0a
    3852:	ed 81       	ldd	r30, Y+5	; 0x05
    3854:	fe 81       	ldd	r31, Y+6	; 0x06
    3856:	80 81       	ld	r24, Z
    3858:	81 50       	subi	r24, 0x01	; 1
    385a:	ed 81       	ldd	r30, Y+5	; 0x05
    385c:	fe 81       	ldd	r31, Y+6	; 0x06
    385e:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3860:	ea 85       	ldd	r30, Y+10	; 0x0a
    3862:	fb 85       	ldd	r31, Y+11	; 0x0b
    3864:	96 89       	ldd	r25, Z+22	; 0x16
    3866:	80 91 ac 06 	lds	r24, 0x06AC
    386a:	89 17       	cp	r24, r25
    386c:	28 f4       	brcc	.+10     	; 0x3878 <xTaskResumeAll+0x154>
    386e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3870:	fb 85       	ldd	r31, Y+11	; 0x0b
    3872:	86 89       	ldd	r24, Z+22	; 0x16
    3874:	80 93 ac 06 	sts	0x06AC, r24
    3878:	ea 85       	ldd	r30, Y+10	; 0x0a
    387a:	fb 85       	ldd	r31, Y+11	; 0x0b
    387c:	86 89       	ldd	r24, Z+22	; 0x16
    387e:	28 2f       	mov	r18, r24
    3880:	30 e0       	ldi	r19, 0x00	; 0
    3882:	c9 01       	movw	r24, r18
    3884:	88 0f       	add	r24, r24
    3886:	99 1f       	adc	r25, r25
    3888:	88 0f       	add	r24, r24
    388a:	99 1f       	adc	r25, r25
    388c:	88 0f       	add	r24, r24
    388e:	99 1f       	adc	r25, r25
    3890:	82 0f       	add	r24, r18
    3892:	93 1f       	adc	r25, r19
    3894:	fc 01       	movw	r30, r24
    3896:	e8 54       	subi	r30, 0x48	; 72
    3898:	f9 4f       	sbci	r31, 0xF9	; 249
    389a:	81 81       	ldd	r24, Z+1	; 0x01
    389c:	92 81       	ldd	r25, Z+2	; 0x02
    389e:	9c 83       	std	Y+4, r25	; 0x04
    38a0:	8b 83       	std	Y+3, r24	; 0x03
    38a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    38a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    38a6:	8b 81       	ldd	r24, Y+3	; 0x03
    38a8:	9c 81       	ldd	r25, Y+4	; 0x04
    38aa:	95 83       	std	Z+5, r25	; 0x05
    38ac:	84 83       	std	Z+4, r24	; 0x04
    38ae:	eb 81       	ldd	r30, Y+3	; 0x03
    38b0:	fc 81       	ldd	r31, Y+4	; 0x04
    38b2:	84 81       	ldd	r24, Z+4	; 0x04
    38b4:	95 81       	ldd	r25, Z+5	; 0x05
    38b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    38b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    38ba:	97 83       	std	Z+7, r25	; 0x07
    38bc:	86 83       	std	Z+6, r24	; 0x06
    38be:	eb 81       	ldd	r30, Y+3	; 0x03
    38c0:	fc 81       	ldd	r31, Y+4	; 0x04
    38c2:	04 80       	ldd	r0, Z+4	; 0x04
    38c4:	f5 81       	ldd	r31, Z+5	; 0x05
    38c6:	e0 2d       	mov	r30, r0
    38c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    38ca:	9b 85       	ldd	r25, Y+11	; 0x0b
    38cc:	02 96       	adiw	r24, 0x02	; 2
    38ce:	93 83       	std	Z+3, r25	; 0x03
    38d0:	82 83       	std	Z+2, r24	; 0x02
    38d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    38d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    38d6:	02 96       	adiw	r24, 0x02	; 2
    38d8:	eb 81       	ldd	r30, Y+3	; 0x03
    38da:	fc 81       	ldd	r31, Y+4	; 0x04
    38dc:	95 83       	std	Z+5, r25	; 0x05
    38de:	84 83       	std	Z+4, r24	; 0x04
    38e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    38e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    38e4:	86 89       	ldd	r24, Z+22	; 0x16
    38e6:	28 2f       	mov	r18, r24
    38e8:	30 e0       	ldi	r19, 0x00	; 0
    38ea:	c9 01       	movw	r24, r18
    38ec:	88 0f       	add	r24, r24
    38ee:	99 1f       	adc	r25, r25
    38f0:	88 0f       	add	r24, r24
    38f2:	99 1f       	adc	r25, r25
    38f4:	88 0f       	add	r24, r24
    38f6:	99 1f       	adc	r25, r25
    38f8:	82 0f       	add	r24, r18
    38fa:	93 1f       	adc	r25, r19
    38fc:	88 54       	subi	r24, 0x48	; 72
    38fe:	99 4f       	sbci	r25, 0xF9	; 249
    3900:	ea 85       	ldd	r30, Y+10	; 0x0a
    3902:	fb 85       	ldd	r31, Y+11	; 0x0b
    3904:	93 87       	std	Z+11, r25	; 0x0b
    3906:	82 87       	std	Z+10, r24	; 0x0a
    3908:	ea 85       	ldd	r30, Y+10	; 0x0a
    390a:	fb 85       	ldd	r31, Y+11	; 0x0b
    390c:	86 89       	ldd	r24, Z+22	; 0x16
    390e:	28 2f       	mov	r18, r24
    3910:	30 e0       	ldi	r19, 0x00	; 0
    3912:	c9 01       	movw	r24, r18
    3914:	88 0f       	add	r24, r24
    3916:	99 1f       	adc	r25, r25
    3918:	88 0f       	add	r24, r24
    391a:	99 1f       	adc	r25, r25
    391c:	88 0f       	add	r24, r24
    391e:	99 1f       	adc	r25, r25
    3920:	82 0f       	add	r24, r18
    3922:	93 1f       	adc	r25, r19
    3924:	fc 01       	movw	r30, r24
    3926:	e8 54       	subi	r30, 0x48	; 72
    3928:	f9 4f       	sbci	r31, 0xF9	; 249
    392a:	80 81       	ld	r24, Z
    392c:	8f 5f       	subi	r24, 0xFF	; 255
    392e:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3930:	ea 85       	ldd	r30, Y+10	; 0x0a
    3932:	fb 85       	ldd	r31, Y+11	; 0x0b
    3934:	96 89       	ldd	r25, Z+22	; 0x16
    3936:	e0 91 a6 06 	lds	r30, 0x06A6
    393a:	f0 91 a7 06 	lds	r31, 0x06A7
    393e:	86 89       	ldd	r24, Z+22	; 0x16
    3940:	98 17       	cp	r25, r24
    3942:	18 f0       	brcs	.+6      	; 0x394a <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    3944:	81 e0       	ldi	r24, 0x01	; 1
    3946:	80 93 b0 06 	sts	0x06B0, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    394a:	80 91 f2 06 	lds	r24, 0x06F2
    394e:	88 23       	and	r24, r24
    3950:	09 f0       	breq	.+2      	; 0x3954 <xTaskResumeAll+0x230>
    3952:	08 cf       	rjmp	.-496    	; 0x3764 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3954:	8a 85       	ldd	r24, Y+10	; 0x0a
    3956:	9b 85       	ldd	r25, Y+11	; 0x0b
    3958:	00 97       	sbiw	r24, 0x00	; 0
    395a:	11 f0       	breq	.+4      	; 0x3960 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    395c:	0e 94 d8 23 	call	0x47b0	; 0x47b0 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3960:	80 91 ae 06 	lds	r24, 0x06AE
    3964:	90 91 af 06 	lds	r25, 0x06AF
    3968:	9a 83       	std	Y+2, r25	; 0x02
    396a:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    396c:	89 81       	ldd	r24, Y+1	; 0x01
    396e:	9a 81       	ldd	r25, Y+2	; 0x02
    3970:	00 97       	sbiw	r24, 0x00	; 0
    3972:	a1 f0       	breq	.+40     	; 0x399c <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3974:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <xTaskIncrementTick>
    3978:	88 23       	and	r24, r24
    397a:	19 f0       	breq	.+6      	; 0x3982 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    397c:	81 e0       	ldi	r24, 0x01	; 1
    397e:	80 93 b0 06 	sts	0x06B0, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3982:	89 81       	ldd	r24, Y+1	; 0x01
    3984:	9a 81       	ldd	r25, Y+2	; 0x02
    3986:	01 97       	sbiw	r24, 0x01	; 1
    3988:	9a 83       	std	Y+2, r25	; 0x02
    398a:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    398c:	89 81       	ldd	r24, Y+1	; 0x01
    398e:	9a 81       	ldd	r25, Y+2	; 0x02
    3990:	00 97       	sbiw	r24, 0x00	; 0
    3992:	81 f7       	brne	.-32     	; 0x3974 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    3994:	10 92 af 06 	sts	0x06AF, r1
    3998:	10 92 ae 06 	sts	0x06AE, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    399c:	80 91 b0 06 	lds	r24, 0x06B0
    39a0:	88 23       	and	r24, r24
    39a2:	21 f0       	breq	.+8      	; 0x39ac <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    39a4:	81 e0       	ldi	r24, 0x01	; 1
    39a6:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    39a8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    39ac:	0f 90       	pop	r0
    39ae:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    39b0:	89 85       	ldd	r24, Y+9	; 0x09
}
    39b2:	2b 96       	adiw	r28, 0x0b	; 11
    39b4:	0f b6       	in	r0, 0x3f	; 63
    39b6:	f8 94       	cli
    39b8:	de bf       	out	0x3e, r29	; 62
    39ba:	0f be       	out	0x3f, r0	; 63
    39bc:	cd bf       	out	0x3d, r28	; 61
    39be:	cf 91       	pop	r28
    39c0:	df 91       	pop	r29
    39c2:	08 95       	ret

000039c4 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    39c4:	df 93       	push	r29
    39c6:	cf 93       	push	r28
    39c8:	00 d0       	rcall	.+0      	; 0x39ca <xTaskGetTickCount+0x6>
    39ca:	cd b7       	in	r28, 0x3d	; 61
    39cc:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    39ce:	0f b6       	in	r0, 0x3f	; 63
    39d0:	f8 94       	cli
    39d2:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    39d4:	80 91 aa 06 	lds	r24, 0x06AA
    39d8:	90 91 ab 06 	lds	r25, 0x06AB
    39dc:	9a 83       	std	Y+2, r25	; 0x02
    39de:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    39e0:	0f 90       	pop	r0
    39e2:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    39e4:	89 81       	ldd	r24, Y+1	; 0x01
    39e6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    39e8:	0f 90       	pop	r0
    39ea:	0f 90       	pop	r0
    39ec:	cf 91       	pop	r28
    39ee:	df 91       	pop	r29
    39f0:	08 95       	ret

000039f2 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    39f2:	df 93       	push	r29
    39f4:	cf 93       	push	r28
    39f6:	00 d0       	rcall	.+0      	; 0x39f8 <xTaskGetTickCountFromISR+0x6>
    39f8:	0f 92       	push	r0
    39fa:	cd b7       	in	r28, 0x3d	; 61
    39fc:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    39fe:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    3a00:	80 91 aa 06 	lds	r24, 0x06AA
    3a04:	90 91 ab 06 	lds	r25, 0x06AB
    3a08:	9b 83       	std	Y+3, r25	; 0x03
    3a0a:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3a0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a0e:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3a10:	0f 90       	pop	r0
    3a12:	0f 90       	pop	r0
    3a14:	0f 90       	pop	r0
    3a16:	cf 91       	pop	r28
    3a18:	df 91       	pop	r29
    3a1a:	08 95       	ret

00003a1c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3a1c:	df 93       	push	r29
    3a1e:	cf 93       	push	r28
    3a20:	cd b7       	in	r28, 0x3d	; 61
    3a22:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    3a24:	80 91 a9 06 	lds	r24, 0x06A9
}
    3a28:	cf 91       	pop	r28
    3a2a:	df 91       	pop	r29
    3a2c:	08 95       	ret

00003a2e <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3a2e:	df 93       	push	r29
    3a30:	cf 93       	push	r28
    3a32:	00 d0       	rcall	.+0      	; 0x3a34 <pcTaskGetName+0x6>
    3a34:	00 d0       	rcall	.+0      	; 0x3a36 <pcTaskGetName+0x8>
    3a36:	00 d0       	rcall	.+0      	; 0x3a38 <pcTaskGetName+0xa>
    3a38:	cd b7       	in	r28, 0x3d	; 61
    3a3a:	de b7       	in	r29, 0x3e	; 62
    3a3c:	9c 83       	std	Y+4, r25	; 0x04
    3a3e:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3a40:	8b 81       	ldd	r24, Y+3	; 0x03
    3a42:	9c 81       	ldd	r25, Y+4	; 0x04
    3a44:	00 97       	sbiw	r24, 0x00	; 0
    3a46:	39 f4       	brne	.+14     	; 0x3a56 <pcTaskGetName+0x28>
    3a48:	80 91 a6 06 	lds	r24, 0x06A6
    3a4c:	90 91 a7 06 	lds	r25, 0x06A7
    3a50:	9e 83       	std	Y+6, r25	; 0x06
    3a52:	8d 83       	std	Y+5, r24	; 0x05
    3a54:	04 c0       	rjmp	.+8      	; 0x3a5e <pcTaskGetName+0x30>
    3a56:	8b 81       	ldd	r24, Y+3	; 0x03
    3a58:	9c 81       	ldd	r25, Y+4	; 0x04
    3a5a:	9e 83       	std	Y+6, r25	; 0x06
    3a5c:	8d 83       	std	Y+5, r24	; 0x05
    3a5e:	8d 81       	ldd	r24, Y+5	; 0x05
    3a60:	9e 81       	ldd	r25, Y+6	; 0x06
    3a62:	9a 83       	std	Y+2, r25	; 0x02
    3a64:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    3a66:	89 81       	ldd	r24, Y+1	; 0x01
    3a68:	9a 81       	ldd	r25, Y+2	; 0x02
    3a6a:	49 96       	adiw	r24, 0x19	; 25
}
    3a6c:	26 96       	adiw	r28, 0x06	; 6
    3a6e:	0f b6       	in	r0, 0x3f	; 63
    3a70:	f8 94       	cli
    3a72:	de bf       	out	0x3e, r29	; 62
    3a74:	0f be       	out	0x3f, r0	; 63
    3a76:	cd bf       	out	0x3d, r28	; 61
    3a78:	cf 91       	pop	r28
    3a7a:	df 91       	pop	r29
    3a7c:	08 95       	ret

00003a7e <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3a7e:	df 93       	push	r29
    3a80:	cf 93       	push	r28
    3a82:	00 d0       	rcall	.+0      	; 0x3a84 <xTaskCatchUpTicks+0x6>
    3a84:	0f 92       	push	r0
    3a86:	cd b7       	in	r28, 0x3d	; 61
    3a88:	de b7       	in	r29, 0x3e	; 62
    3a8a:	9b 83       	std	Y+3, r25	; 0x03
    3a8c:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3a8e:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    3a92:	20 91 ae 06 	lds	r18, 0x06AE
    3a96:	30 91 af 06 	lds	r19, 0x06AF
    3a9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a9e:	82 0f       	add	r24, r18
    3aa0:	93 1f       	adc	r25, r19
    3aa2:	90 93 af 06 	sts	0x06AF, r25
    3aa6:	80 93 ae 06 	sts	0x06AE, r24
    xYieldOccurred = xTaskResumeAll();
    3aaa:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    3aae:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    3ab0:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ab2:	0f 90       	pop	r0
    3ab4:	0f 90       	pop	r0
    3ab6:	0f 90       	pop	r0
    3ab8:	cf 91       	pop	r28
    3aba:	df 91       	pop	r29
    3abc:	08 95       	ret

00003abe <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3abe:	df 93       	push	r29
    3ac0:	cf 93       	push	r28
    3ac2:	cd b7       	in	r28, 0x3d	; 61
    3ac4:	de b7       	in	r29, 0x3e	; 62
    3ac6:	2f 97       	sbiw	r28, 0x0f	; 15
    3ac8:	0f b6       	in	r0, 0x3f	; 63
    3aca:	f8 94       	cli
    3acc:	de bf       	out	0x3e, r29	; 62
    3ace:	0f be       	out	0x3f, r0	; 63
    3ad0:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3ad2:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ad4:	80 91 b7 06 	lds	r24, 0x06B7
    3ad8:	88 23       	and	r24, r24
    3ada:	09 f0       	breq	.+2      	; 0x3ade <xTaskIncrementTick+0x20>
    3adc:	74 c1       	rjmp	.+744    	; 0x3dc6 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3ade:	80 91 aa 06 	lds	r24, 0x06AA
    3ae2:	90 91 ab 06 	lds	r25, 0x06AB
    3ae6:	01 96       	adiw	r24, 0x01	; 1
    3ae8:	9a 87       	std	Y+10, r25	; 0x0a
    3aea:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    3aec:	89 85       	ldd	r24, Y+9	; 0x09
    3aee:	9a 85       	ldd	r25, Y+10	; 0x0a
    3af0:	90 93 ab 06 	sts	0x06AB, r25
    3af4:	80 93 aa 06 	sts	0x06AA, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3af8:	89 85       	ldd	r24, Y+9	; 0x09
    3afa:	9a 85       	ldd	r25, Y+10	; 0x0a
    3afc:	00 97       	sbiw	r24, 0x00	; 0
    3afe:	d9 f4       	brne	.+54     	; 0x3b36 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    3b00:	80 91 ee 06 	lds	r24, 0x06EE
    3b04:	90 91 ef 06 	lds	r25, 0x06EF
    3b08:	98 87       	std	Y+8, r25	; 0x08
    3b0a:	8f 83       	std	Y+7, r24	; 0x07
    3b0c:	80 91 f0 06 	lds	r24, 0x06F0
    3b10:	90 91 f1 06 	lds	r25, 0x06F1
    3b14:	90 93 ef 06 	sts	0x06EF, r25
    3b18:	80 93 ee 06 	sts	0x06EE, r24
    3b1c:	8f 81       	ldd	r24, Y+7	; 0x07
    3b1e:	98 85       	ldd	r25, Y+8	; 0x08
    3b20:	90 93 f1 06 	sts	0x06F1, r25
    3b24:	80 93 f0 06 	sts	0x06F0, r24
    3b28:	80 91 b1 06 	lds	r24, 0x06B1
    3b2c:	8f 5f       	subi	r24, 0xFF	; 255
    3b2e:	80 93 b1 06 	sts	0x06B1, r24
    3b32:	0e 94 d8 23 	call	0x47b0	; 0x47b0 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3b36:	20 91 b3 06 	lds	r18, 0x06B3
    3b3a:	30 91 b4 06 	lds	r19, 0x06B4
    3b3e:	89 85       	ldd	r24, Y+9	; 0x09
    3b40:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b42:	82 17       	cp	r24, r18
    3b44:	93 07       	cpc	r25, r19
    3b46:	08 f4       	brcc	.+2      	; 0x3b4a <xTaskIncrementTick+0x8c>
    3b48:	1f c1       	rjmp	.+574    	; 0x3d88 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3b4a:	e0 91 ee 06 	lds	r30, 0x06EE
    3b4e:	f0 91 ef 06 	lds	r31, 0x06EF
    3b52:	80 81       	ld	r24, Z
    3b54:	88 23       	and	r24, r24
    3b56:	39 f4       	brne	.+14     	; 0x3b66 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3b58:	8f ef       	ldi	r24, 0xFF	; 255
    3b5a:	9f ef       	ldi	r25, 0xFF	; 255
    3b5c:	90 93 b4 06 	sts	0x06B4, r25
    3b60:	80 93 b3 06 	sts	0x06B3, r24
    3b64:	11 c1       	rjmp	.+546    	; 0x3d88 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3b66:	e0 91 ee 06 	lds	r30, 0x06EE
    3b6a:	f0 91 ef 06 	lds	r31, 0x06EF
    3b6e:	05 80       	ldd	r0, Z+5	; 0x05
    3b70:	f6 81       	ldd	r31, Z+6	; 0x06
    3b72:	e0 2d       	mov	r30, r0
    3b74:	86 81       	ldd	r24, Z+6	; 0x06
    3b76:	97 81       	ldd	r25, Z+7	; 0x07
    3b78:	9f 87       	std	Y+15, r25	; 0x0f
    3b7a:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3b7c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b7e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b80:	82 81       	ldd	r24, Z+2	; 0x02
    3b82:	93 81       	ldd	r25, Z+3	; 0x03
    3b84:	9d 87       	std	Y+13, r25	; 0x0d
    3b86:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    3b88:	29 85       	ldd	r18, Y+9	; 0x09
    3b8a:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b8c:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b8e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b90:	28 17       	cp	r18, r24
    3b92:	39 07       	cpc	r19, r25
    3b94:	38 f4       	brcc	.+14     	; 0x3ba4 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3b96:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b98:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b9a:	90 93 b4 06 	sts	0x06B4, r25
    3b9e:	80 93 b3 06 	sts	0x06B3, r24
    3ba2:	f2 c0       	rjmp	.+484    	; 0x3d88 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3ba4:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ba6:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ba8:	82 85       	ldd	r24, Z+10	; 0x0a
    3baa:	93 85       	ldd	r25, Z+11	; 0x0b
    3bac:	9e 83       	std	Y+6, r25	; 0x06
    3bae:	8d 83       	std	Y+5, r24	; 0x05
    3bb0:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bb2:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bb4:	a4 81       	ldd	r26, Z+4	; 0x04
    3bb6:	b5 81       	ldd	r27, Z+5	; 0x05
    3bb8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bba:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bbc:	86 81       	ldd	r24, Z+6	; 0x06
    3bbe:	97 81       	ldd	r25, Z+7	; 0x07
    3bc0:	15 96       	adiw	r26, 0x05	; 5
    3bc2:	9c 93       	st	X, r25
    3bc4:	8e 93       	st	-X, r24
    3bc6:	14 97       	sbiw	r26, 0x04	; 4
    3bc8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bca:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bcc:	a6 81       	ldd	r26, Z+6	; 0x06
    3bce:	b7 81       	ldd	r27, Z+7	; 0x07
    3bd0:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bd2:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bd4:	84 81       	ldd	r24, Z+4	; 0x04
    3bd6:	95 81       	ldd	r25, Z+5	; 0x05
    3bd8:	13 96       	adiw	r26, 0x03	; 3
    3bda:	9c 93       	st	X, r25
    3bdc:	8e 93       	st	-X, r24
    3bde:	12 97       	sbiw	r26, 0x02	; 2
    3be0:	ed 81       	ldd	r30, Y+5	; 0x05
    3be2:	fe 81       	ldd	r31, Y+6	; 0x06
    3be4:	21 81       	ldd	r18, Z+1	; 0x01
    3be6:	32 81       	ldd	r19, Z+2	; 0x02
    3be8:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bea:	9f 85       	ldd	r25, Y+15	; 0x0f
    3bec:	02 96       	adiw	r24, 0x02	; 2
    3bee:	28 17       	cp	r18, r24
    3bf0:	39 07       	cpc	r19, r25
    3bf2:	41 f4       	brne	.+16     	; 0x3c04 <xTaskIncrementTick+0x146>
    3bf4:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bf6:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bf8:	86 81       	ldd	r24, Z+6	; 0x06
    3bfa:	97 81       	ldd	r25, Z+7	; 0x07
    3bfc:	ed 81       	ldd	r30, Y+5	; 0x05
    3bfe:	fe 81       	ldd	r31, Y+6	; 0x06
    3c00:	92 83       	std	Z+2, r25	; 0x02
    3c02:	81 83       	std	Z+1, r24	; 0x01
    3c04:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c06:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c08:	13 86       	std	Z+11, r1	; 0x0b
    3c0a:	12 86       	std	Z+10, r1	; 0x0a
    3c0c:	ed 81       	ldd	r30, Y+5	; 0x05
    3c0e:	fe 81       	ldd	r31, Y+6	; 0x06
    3c10:	80 81       	ld	r24, Z
    3c12:	81 50       	subi	r24, 0x01	; 1
    3c14:	ed 81       	ldd	r30, Y+5	; 0x05
    3c16:	fe 81       	ldd	r31, Y+6	; 0x06
    3c18:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3c1a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c1c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c1e:	84 89       	ldd	r24, Z+20	; 0x14
    3c20:	95 89       	ldd	r25, Z+21	; 0x15
    3c22:	00 97       	sbiw	r24, 0x00	; 0
    3c24:	d9 f1       	breq	.+118    	; 0x3c9c <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3c26:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c28:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c2a:	84 89       	ldd	r24, Z+20	; 0x14
    3c2c:	95 89       	ldd	r25, Z+21	; 0x15
    3c2e:	9c 83       	std	Y+4, r25	; 0x04
    3c30:	8b 83       	std	Y+3, r24	; 0x03
    3c32:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c34:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c36:	a6 85       	ldd	r26, Z+14	; 0x0e
    3c38:	b7 85       	ldd	r27, Z+15	; 0x0f
    3c3a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c3c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c3e:	80 89       	ldd	r24, Z+16	; 0x10
    3c40:	91 89       	ldd	r25, Z+17	; 0x11
    3c42:	15 96       	adiw	r26, 0x05	; 5
    3c44:	9c 93       	st	X, r25
    3c46:	8e 93       	st	-X, r24
    3c48:	14 97       	sbiw	r26, 0x04	; 4
    3c4a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c4c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c4e:	a0 89       	ldd	r26, Z+16	; 0x10
    3c50:	b1 89       	ldd	r27, Z+17	; 0x11
    3c52:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c54:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c56:	86 85       	ldd	r24, Z+14	; 0x0e
    3c58:	97 85       	ldd	r25, Z+15	; 0x0f
    3c5a:	13 96       	adiw	r26, 0x03	; 3
    3c5c:	9c 93       	st	X, r25
    3c5e:	8e 93       	st	-X, r24
    3c60:	12 97       	sbiw	r26, 0x02	; 2
    3c62:	eb 81       	ldd	r30, Y+3	; 0x03
    3c64:	fc 81       	ldd	r31, Y+4	; 0x04
    3c66:	21 81       	ldd	r18, Z+1	; 0x01
    3c68:	32 81       	ldd	r19, Z+2	; 0x02
    3c6a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c6c:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c6e:	0c 96       	adiw	r24, 0x0c	; 12
    3c70:	28 17       	cp	r18, r24
    3c72:	39 07       	cpc	r19, r25
    3c74:	41 f4       	brne	.+16     	; 0x3c86 <xTaskIncrementTick+0x1c8>
    3c76:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c78:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c7a:	80 89       	ldd	r24, Z+16	; 0x10
    3c7c:	91 89       	ldd	r25, Z+17	; 0x11
    3c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c80:	fc 81       	ldd	r31, Y+4	; 0x04
    3c82:	92 83       	std	Z+2, r25	; 0x02
    3c84:	81 83       	std	Z+1, r24	; 0x01
    3c86:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c88:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c8a:	15 8a       	std	Z+21, r1	; 0x15
    3c8c:	14 8a       	std	Z+20, r1	; 0x14
    3c8e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c90:	fc 81       	ldd	r31, Y+4	; 0x04
    3c92:	80 81       	ld	r24, Z
    3c94:	81 50       	subi	r24, 0x01	; 1
    3c96:	eb 81       	ldd	r30, Y+3	; 0x03
    3c98:	fc 81       	ldd	r31, Y+4	; 0x04
    3c9a:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3c9c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c9e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ca0:	96 89       	ldd	r25, Z+22	; 0x16
    3ca2:	80 91 ac 06 	lds	r24, 0x06AC
    3ca6:	89 17       	cp	r24, r25
    3ca8:	28 f4       	brcc	.+10     	; 0x3cb4 <xTaskIncrementTick+0x1f6>
    3caa:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cac:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cae:	86 89       	ldd	r24, Z+22	; 0x16
    3cb0:	80 93 ac 06 	sts	0x06AC, r24
    3cb4:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cb6:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cb8:	86 89       	ldd	r24, Z+22	; 0x16
    3cba:	28 2f       	mov	r18, r24
    3cbc:	30 e0       	ldi	r19, 0x00	; 0
    3cbe:	c9 01       	movw	r24, r18
    3cc0:	88 0f       	add	r24, r24
    3cc2:	99 1f       	adc	r25, r25
    3cc4:	88 0f       	add	r24, r24
    3cc6:	99 1f       	adc	r25, r25
    3cc8:	88 0f       	add	r24, r24
    3cca:	99 1f       	adc	r25, r25
    3ccc:	82 0f       	add	r24, r18
    3cce:	93 1f       	adc	r25, r19
    3cd0:	fc 01       	movw	r30, r24
    3cd2:	e8 54       	subi	r30, 0x48	; 72
    3cd4:	f9 4f       	sbci	r31, 0xF9	; 249
    3cd6:	81 81       	ldd	r24, Z+1	; 0x01
    3cd8:	92 81       	ldd	r25, Z+2	; 0x02
    3cda:	9a 83       	std	Y+2, r25	; 0x02
    3cdc:	89 83       	std	Y+1, r24	; 0x01
    3cde:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ce0:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ce2:	89 81       	ldd	r24, Y+1	; 0x01
    3ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce6:	95 83       	std	Z+5, r25	; 0x05
    3ce8:	84 83       	std	Z+4, r24	; 0x04
    3cea:	e9 81       	ldd	r30, Y+1	; 0x01
    3cec:	fa 81       	ldd	r31, Y+2	; 0x02
    3cee:	84 81       	ldd	r24, Z+4	; 0x04
    3cf0:	95 81       	ldd	r25, Z+5	; 0x05
    3cf2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cf4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cf6:	97 83       	std	Z+7, r25	; 0x07
    3cf8:	86 83       	std	Z+6, r24	; 0x06
    3cfa:	e9 81       	ldd	r30, Y+1	; 0x01
    3cfc:	fa 81       	ldd	r31, Y+2	; 0x02
    3cfe:	04 80       	ldd	r0, Z+4	; 0x04
    3d00:	f5 81       	ldd	r31, Z+5	; 0x05
    3d02:	e0 2d       	mov	r30, r0
    3d04:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d06:	9f 85       	ldd	r25, Y+15	; 0x0f
    3d08:	02 96       	adiw	r24, 0x02	; 2
    3d0a:	93 83       	std	Z+3, r25	; 0x03
    3d0c:	82 83       	std	Z+2, r24	; 0x02
    3d0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d10:	9f 85       	ldd	r25, Y+15	; 0x0f
    3d12:	02 96       	adiw	r24, 0x02	; 2
    3d14:	e9 81       	ldd	r30, Y+1	; 0x01
    3d16:	fa 81       	ldd	r31, Y+2	; 0x02
    3d18:	95 83       	std	Z+5, r25	; 0x05
    3d1a:	84 83       	std	Z+4, r24	; 0x04
    3d1c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d1e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d20:	86 89       	ldd	r24, Z+22	; 0x16
    3d22:	28 2f       	mov	r18, r24
    3d24:	30 e0       	ldi	r19, 0x00	; 0
    3d26:	c9 01       	movw	r24, r18
    3d28:	88 0f       	add	r24, r24
    3d2a:	99 1f       	adc	r25, r25
    3d2c:	88 0f       	add	r24, r24
    3d2e:	99 1f       	adc	r25, r25
    3d30:	88 0f       	add	r24, r24
    3d32:	99 1f       	adc	r25, r25
    3d34:	82 0f       	add	r24, r18
    3d36:	93 1f       	adc	r25, r19
    3d38:	88 54       	subi	r24, 0x48	; 72
    3d3a:	99 4f       	sbci	r25, 0xF9	; 249
    3d3c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d3e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d40:	93 87       	std	Z+11, r25	; 0x0b
    3d42:	82 87       	std	Z+10, r24	; 0x0a
    3d44:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d46:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d48:	86 89       	ldd	r24, Z+22	; 0x16
    3d4a:	28 2f       	mov	r18, r24
    3d4c:	30 e0       	ldi	r19, 0x00	; 0
    3d4e:	c9 01       	movw	r24, r18
    3d50:	88 0f       	add	r24, r24
    3d52:	99 1f       	adc	r25, r25
    3d54:	88 0f       	add	r24, r24
    3d56:	99 1f       	adc	r25, r25
    3d58:	88 0f       	add	r24, r24
    3d5a:	99 1f       	adc	r25, r25
    3d5c:	82 0f       	add	r24, r18
    3d5e:	93 1f       	adc	r25, r19
    3d60:	fc 01       	movw	r30, r24
    3d62:	e8 54       	subi	r30, 0x48	; 72
    3d64:	f9 4f       	sbci	r31, 0xF9	; 249
    3d66:	80 81       	ld	r24, Z
    3d68:	8f 5f       	subi	r24, 0xFF	; 255
    3d6a:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3d6c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d6e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d70:	96 89       	ldd	r25, Z+22	; 0x16
    3d72:	e0 91 a6 06 	lds	r30, 0x06A6
    3d76:	f0 91 a7 06 	lds	r31, 0x06A7
    3d7a:	86 89       	ldd	r24, Z+22	; 0x16
    3d7c:	98 17       	cp	r25, r24
    3d7e:	08 f4       	brcc	.+2      	; 0x3d82 <xTaskIncrementTick+0x2c4>
    3d80:	e4 ce       	rjmp	.-568    	; 0x3b4a <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    3d82:	81 e0       	ldi	r24, 0x01	; 1
    3d84:	8b 87       	std	Y+11, r24	; 0x0b
    3d86:	e1 ce       	rjmp	.-574    	; 0x3b4a <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3d88:	e0 91 a6 06 	lds	r30, 0x06A6
    3d8c:	f0 91 a7 06 	lds	r31, 0x06A7
    3d90:	86 89       	ldd	r24, Z+22	; 0x16
    3d92:	28 2f       	mov	r18, r24
    3d94:	30 e0       	ldi	r19, 0x00	; 0
    3d96:	c9 01       	movw	r24, r18
    3d98:	88 0f       	add	r24, r24
    3d9a:	99 1f       	adc	r25, r25
    3d9c:	88 0f       	add	r24, r24
    3d9e:	99 1f       	adc	r25, r25
    3da0:	88 0f       	add	r24, r24
    3da2:	99 1f       	adc	r25, r25
    3da4:	82 0f       	add	r24, r18
    3da6:	93 1f       	adc	r25, r19
    3da8:	fc 01       	movw	r30, r24
    3daa:	e8 54       	subi	r30, 0x48	; 72
    3dac:	f9 4f       	sbci	r31, 0xF9	; 249
    3dae:	80 81       	ld	r24, Z
    3db0:	82 30       	cpi	r24, 0x02	; 2
    3db2:	10 f0       	brcs	.+4      	; 0x3db8 <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    3db4:	81 e0       	ldi	r24, 0x01	; 1
    3db6:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    3db8:	80 91 b0 06 	lds	r24, 0x06B0
    3dbc:	88 23       	and	r24, r24
    3dbe:	61 f0       	breq	.+24     	; 0x3dd8 <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    3dc0:	81 e0       	ldi	r24, 0x01	; 1
    3dc2:	8b 87       	std	Y+11, r24	; 0x0b
    3dc4:	09 c0       	rjmp	.+18     	; 0x3dd8 <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    3dc6:	80 91 ae 06 	lds	r24, 0x06AE
    3dca:	90 91 af 06 	lds	r25, 0x06AF
    3dce:	01 96       	adiw	r24, 0x01	; 1
    3dd0:	90 93 af 06 	sts	0x06AF, r25
    3dd4:	80 93 ae 06 	sts	0x06AE, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    3dd8:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    3dda:	2f 96       	adiw	r28, 0x0f	; 15
    3ddc:	0f b6       	in	r0, 0x3f	; 63
    3dde:	f8 94       	cli
    3de0:	de bf       	out	0x3e, r29	; 62
    3de2:	0f be       	out	0x3f, r0	; 63
    3de4:	cd bf       	out	0x3d, r28	; 61
    3de6:	cf 91       	pop	r28
    3de8:	df 91       	pop	r29
    3dea:	08 95       	ret

00003dec <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3dec:	df 93       	push	r29
    3dee:	cf 93       	push	r28
    3df0:	00 d0       	rcall	.+0      	; 0x3df2 <vTaskSwitchContext+0x6>
    3df2:	0f 92       	push	r0
    3df4:	cd b7       	in	r28, 0x3d	; 61
    3df6:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3df8:	80 91 b7 06 	lds	r24, 0x06B7
    3dfc:	88 23       	and	r24, r24
    3dfe:	21 f0       	breq	.+8      	; 0x3e08 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    3e00:	81 e0       	ldi	r24, 0x01	; 1
    3e02:	80 93 b0 06 	sts	0x06B0, r24
    3e06:	59 c0       	rjmp	.+178    	; 0x3eba <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    3e08:	10 92 b0 06 	sts	0x06B0, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e0c:	80 91 ac 06 	lds	r24, 0x06AC
    3e10:	8b 83       	std	Y+3, r24	; 0x03
    3e12:	03 c0       	rjmp	.+6      	; 0x3e1a <vTaskSwitchContext+0x2e>
    3e14:	8b 81       	ldd	r24, Y+3	; 0x03
    3e16:	81 50       	subi	r24, 0x01	; 1
    3e18:	8b 83       	std	Y+3, r24	; 0x03
    3e1a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e1c:	28 2f       	mov	r18, r24
    3e1e:	30 e0       	ldi	r19, 0x00	; 0
    3e20:	c9 01       	movw	r24, r18
    3e22:	88 0f       	add	r24, r24
    3e24:	99 1f       	adc	r25, r25
    3e26:	88 0f       	add	r24, r24
    3e28:	99 1f       	adc	r25, r25
    3e2a:	88 0f       	add	r24, r24
    3e2c:	99 1f       	adc	r25, r25
    3e2e:	82 0f       	add	r24, r18
    3e30:	93 1f       	adc	r25, r19
    3e32:	fc 01       	movw	r30, r24
    3e34:	e8 54       	subi	r30, 0x48	; 72
    3e36:	f9 4f       	sbci	r31, 0xF9	; 249
    3e38:	80 81       	ld	r24, Z
    3e3a:	88 23       	and	r24, r24
    3e3c:	59 f3       	breq	.-42     	; 0x3e14 <vTaskSwitchContext+0x28>
    3e3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e40:	28 2f       	mov	r18, r24
    3e42:	30 e0       	ldi	r19, 0x00	; 0
    3e44:	c9 01       	movw	r24, r18
    3e46:	88 0f       	add	r24, r24
    3e48:	99 1f       	adc	r25, r25
    3e4a:	88 0f       	add	r24, r24
    3e4c:	99 1f       	adc	r25, r25
    3e4e:	88 0f       	add	r24, r24
    3e50:	99 1f       	adc	r25, r25
    3e52:	82 0f       	add	r24, r18
    3e54:	93 1f       	adc	r25, r19
    3e56:	88 54       	subi	r24, 0x48	; 72
    3e58:	99 4f       	sbci	r25, 0xF9	; 249
    3e5a:	9a 83       	std	Y+2, r25	; 0x02
    3e5c:	89 83       	std	Y+1, r24	; 0x01
    3e5e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e60:	fa 81       	ldd	r31, Y+2	; 0x02
    3e62:	01 80       	ldd	r0, Z+1	; 0x01
    3e64:	f2 81       	ldd	r31, Z+2	; 0x02
    3e66:	e0 2d       	mov	r30, r0
    3e68:	82 81       	ldd	r24, Z+2	; 0x02
    3e6a:	93 81       	ldd	r25, Z+3	; 0x03
    3e6c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e6e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e70:	92 83       	std	Z+2, r25	; 0x02
    3e72:	81 83       	std	Z+1, r24	; 0x01
    3e74:	e9 81       	ldd	r30, Y+1	; 0x01
    3e76:	fa 81       	ldd	r31, Y+2	; 0x02
    3e78:	21 81       	ldd	r18, Z+1	; 0x01
    3e7a:	32 81       	ldd	r19, Z+2	; 0x02
    3e7c:	89 81       	ldd	r24, Y+1	; 0x01
    3e7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e80:	03 96       	adiw	r24, 0x03	; 3
    3e82:	28 17       	cp	r18, r24
    3e84:	39 07       	cpc	r19, r25
    3e86:	59 f4       	brne	.+22     	; 0x3e9e <vTaskSwitchContext+0xb2>
    3e88:	e9 81       	ldd	r30, Y+1	; 0x01
    3e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e8c:	01 80       	ldd	r0, Z+1	; 0x01
    3e8e:	f2 81       	ldd	r31, Z+2	; 0x02
    3e90:	e0 2d       	mov	r30, r0
    3e92:	82 81       	ldd	r24, Z+2	; 0x02
    3e94:	93 81       	ldd	r25, Z+3	; 0x03
    3e96:	e9 81       	ldd	r30, Y+1	; 0x01
    3e98:	fa 81       	ldd	r31, Y+2	; 0x02
    3e9a:	92 83       	std	Z+2, r25	; 0x02
    3e9c:	81 83       	std	Z+1, r24	; 0x01
    3e9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3ea0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ea2:	01 80       	ldd	r0, Z+1	; 0x01
    3ea4:	f2 81       	ldd	r31, Z+2	; 0x02
    3ea6:	e0 2d       	mov	r30, r0
    3ea8:	86 81       	ldd	r24, Z+6	; 0x06
    3eaa:	97 81       	ldd	r25, Z+7	; 0x07
    3eac:	90 93 a7 06 	sts	0x06A7, r25
    3eb0:	80 93 a6 06 	sts	0x06A6, r24
    3eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    3eb6:	80 93 ac 06 	sts	0x06AC, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    3eba:	0f 90       	pop	r0
    3ebc:	0f 90       	pop	r0
    3ebe:	0f 90       	pop	r0
    3ec0:	cf 91       	pop	r28
    3ec2:	df 91       	pop	r29
    3ec4:	08 95       	ret

00003ec6 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    3ec6:	df 93       	push	r29
    3ec8:	cf 93       	push	r28
    3eca:	00 d0       	rcall	.+0      	; 0x3ecc <vTaskPlaceOnEventList+0x6>
    3ecc:	00 d0       	rcall	.+0      	; 0x3ece <vTaskPlaceOnEventList+0x8>
    3ece:	cd b7       	in	r28, 0x3d	; 61
    3ed0:	de b7       	in	r29, 0x3e	; 62
    3ed2:	9a 83       	std	Y+2, r25	; 0x02
    3ed4:	89 83       	std	Y+1, r24	; 0x01
    3ed6:	7c 83       	std	Y+4, r23	; 0x04
    3ed8:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3eda:	80 91 a6 06 	lds	r24, 0x06A6
    3ede:	90 91 a7 06 	lds	r25, 0x06A7
    3ee2:	9c 01       	movw	r18, r24
    3ee4:	24 5f       	subi	r18, 0xF4	; 244
    3ee6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ee8:	89 81       	ldd	r24, Y+1	; 0x01
    3eea:	9a 81       	ldd	r25, Y+2	; 0x02
    3eec:	b9 01       	movw	r22, r18
    3eee:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3ef2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ef6:	61 e0       	ldi	r22, 0x01	; 1
    3ef8:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>
}
    3efc:	0f 90       	pop	r0
    3efe:	0f 90       	pop	r0
    3f00:	0f 90       	pop	r0
    3f02:	0f 90       	pop	r0
    3f04:	cf 91       	pop	r28
    3f06:	df 91       	pop	r29
    3f08:	08 95       	ret

00003f0a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    3f0a:	df 93       	push	r29
    3f0c:	cf 93       	push	r28
    3f0e:	cd b7       	in	r28, 0x3d	; 61
    3f10:	de b7       	in	r29, 0x3e	; 62
    3f12:	28 97       	sbiw	r28, 0x08	; 8
    3f14:	0f b6       	in	r0, 0x3f	; 63
    3f16:	f8 94       	cli
    3f18:	de bf       	out	0x3e, r29	; 62
    3f1a:	0f be       	out	0x3f, r0	; 63
    3f1c:	cd bf       	out	0x3d, r28	; 61
    3f1e:	9c 83       	std	Y+4, r25	; 0x04
    3f20:	8b 83       	std	Y+3, r24	; 0x03
    3f22:	7e 83       	std	Y+6, r23	; 0x06
    3f24:	6d 83       	std	Y+5, r22	; 0x05
    3f26:	58 87       	std	Y+8, r21	; 0x08
    3f28:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3f2a:	e0 91 a6 06 	lds	r30, 0x06A6
    3f2e:	f0 91 a7 06 	lds	r31, 0x06A7
    3f32:	8d 81       	ldd	r24, Y+5	; 0x05
    3f34:	9e 81       	ldd	r25, Y+6	; 0x06
    3f36:	90 68       	ori	r25, 0x80	; 128
    3f38:	95 87       	std	Z+13, r25	; 0x0d
    3f3a:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3f3c:	eb 81       	ldd	r30, Y+3	; 0x03
    3f3e:	fc 81       	ldd	r31, Y+4	; 0x04
    3f40:	81 81       	ldd	r24, Z+1	; 0x01
    3f42:	92 81       	ldd	r25, Z+2	; 0x02
    3f44:	9a 83       	std	Y+2, r25	; 0x02
    3f46:	89 83       	std	Y+1, r24	; 0x01
    3f48:	e0 91 a6 06 	lds	r30, 0x06A6
    3f4c:	f0 91 a7 06 	lds	r31, 0x06A7
    3f50:	89 81       	ldd	r24, Y+1	; 0x01
    3f52:	9a 81       	ldd	r25, Y+2	; 0x02
    3f54:	97 87       	std	Z+15, r25	; 0x0f
    3f56:	86 87       	std	Z+14, r24	; 0x0e
    3f58:	a0 91 a6 06 	lds	r26, 0x06A6
    3f5c:	b0 91 a7 06 	lds	r27, 0x06A7
    3f60:	e9 81       	ldd	r30, Y+1	; 0x01
    3f62:	fa 81       	ldd	r31, Y+2	; 0x02
    3f64:	84 81       	ldd	r24, Z+4	; 0x04
    3f66:	95 81       	ldd	r25, Z+5	; 0x05
    3f68:	51 96       	adiw	r26, 0x11	; 17
    3f6a:	9c 93       	st	X, r25
    3f6c:	8e 93       	st	-X, r24
    3f6e:	50 97       	sbiw	r26, 0x10	; 16
    3f70:	e9 81       	ldd	r30, Y+1	; 0x01
    3f72:	fa 81       	ldd	r31, Y+2	; 0x02
    3f74:	04 80       	ldd	r0, Z+4	; 0x04
    3f76:	f5 81       	ldd	r31, Z+5	; 0x05
    3f78:	e0 2d       	mov	r30, r0
    3f7a:	80 91 a6 06 	lds	r24, 0x06A6
    3f7e:	90 91 a7 06 	lds	r25, 0x06A7
    3f82:	0c 96       	adiw	r24, 0x0c	; 12
    3f84:	93 83       	std	Z+3, r25	; 0x03
    3f86:	82 83       	std	Z+2, r24	; 0x02
    3f88:	80 91 a6 06 	lds	r24, 0x06A6
    3f8c:	90 91 a7 06 	lds	r25, 0x06A7
    3f90:	0c 96       	adiw	r24, 0x0c	; 12
    3f92:	e9 81       	ldd	r30, Y+1	; 0x01
    3f94:	fa 81       	ldd	r31, Y+2	; 0x02
    3f96:	95 83       	std	Z+5, r25	; 0x05
    3f98:	84 83       	std	Z+4, r24	; 0x04
    3f9a:	e0 91 a6 06 	lds	r30, 0x06A6
    3f9e:	f0 91 a7 06 	lds	r31, 0x06A7
    3fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    3fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    3fa6:	95 8b       	std	Z+21, r25	; 0x15
    3fa8:	84 8b       	std	Z+20, r24	; 0x14
    3faa:	eb 81       	ldd	r30, Y+3	; 0x03
    3fac:	fc 81       	ldd	r31, Y+4	; 0x04
    3fae:	80 81       	ld	r24, Z
    3fb0:	8f 5f       	subi	r24, 0xFF	; 255
    3fb2:	eb 81       	ldd	r30, Y+3	; 0x03
    3fb4:	fc 81       	ldd	r31, Y+4	; 0x04
    3fb6:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3fb8:	8f 81       	ldd	r24, Y+7	; 0x07
    3fba:	98 85       	ldd	r25, Y+8	; 0x08
    3fbc:	61 e0       	ldi	r22, 0x01	; 1
    3fbe:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>
}
    3fc2:	28 96       	adiw	r28, 0x08	; 8
    3fc4:	0f b6       	in	r0, 0x3f	; 63
    3fc6:	f8 94       	cli
    3fc8:	de bf       	out	0x3e, r29	; 62
    3fca:	0f be       	out	0x3f, r0	; 63
    3fcc:	cd bf       	out	0x3d, r28	; 61
    3fce:	cf 91       	pop	r28
    3fd0:	df 91       	pop	r29
    3fd2:	08 95       	ret

00003fd4 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    3fd4:	df 93       	push	r29
    3fd6:	cf 93       	push	r28
    3fd8:	cd b7       	in	r28, 0x3d	; 61
    3fda:	de b7       	in	r29, 0x3e	; 62
    3fdc:	27 97       	sbiw	r28, 0x07	; 7
    3fde:	0f b6       	in	r0, 0x3f	; 63
    3fe0:	f8 94       	cli
    3fe2:	de bf       	out	0x3e, r29	; 62
    3fe4:	0f be       	out	0x3f, r0	; 63
    3fe6:	cd bf       	out	0x3d, r28	; 61
    3fe8:	9c 83       	std	Y+4, r25	; 0x04
    3fea:	8b 83       	std	Y+3, r24	; 0x03
    3fec:	7e 83       	std	Y+6, r23	; 0x06
    3fee:	6d 83       	std	Y+5, r22	; 0x05
    3ff0:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3ff2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ff4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ff6:	81 81       	ldd	r24, Z+1	; 0x01
    3ff8:	92 81       	ldd	r25, Z+2	; 0x02
    3ffa:	9a 83       	std	Y+2, r25	; 0x02
    3ffc:	89 83       	std	Y+1, r24	; 0x01
    3ffe:	e0 91 a6 06 	lds	r30, 0x06A6
    4002:	f0 91 a7 06 	lds	r31, 0x06A7
    4006:	89 81       	ldd	r24, Y+1	; 0x01
    4008:	9a 81       	ldd	r25, Y+2	; 0x02
    400a:	97 87       	std	Z+15, r25	; 0x0f
    400c:	86 87       	std	Z+14, r24	; 0x0e
    400e:	a0 91 a6 06 	lds	r26, 0x06A6
    4012:	b0 91 a7 06 	lds	r27, 0x06A7
    4016:	e9 81       	ldd	r30, Y+1	; 0x01
    4018:	fa 81       	ldd	r31, Y+2	; 0x02
    401a:	84 81       	ldd	r24, Z+4	; 0x04
    401c:	95 81       	ldd	r25, Z+5	; 0x05
    401e:	51 96       	adiw	r26, 0x11	; 17
    4020:	9c 93       	st	X, r25
    4022:	8e 93       	st	-X, r24
    4024:	50 97       	sbiw	r26, 0x10	; 16
    4026:	e9 81       	ldd	r30, Y+1	; 0x01
    4028:	fa 81       	ldd	r31, Y+2	; 0x02
    402a:	04 80       	ldd	r0, Z+4	; 0x04
    402c:	f5 81       	ldd	r31, Z+5	; 0x05
    402e:	e0 2d       	mov	r30, r0
    4030:	80 91 a6 06 	lds	r24, 0x06A6
    4034:	90 91 a7 06 	lds	r25, 0x06A7
    4038:	0c 96       	adiw	r24, 0x0c	; 12
    403a:	93 83       	std	Z+3, r25	; 0x03
    403c:	82 83       	std	Z+2, r24	; 0x02
    403e:	80 91 a6 06 	lds	r24, 0x06A6
    4042:	90 91 a7 06 	lds	r25, 0x06A7
    4046:	0c 96       	adiw	r24, 0x0c	; 12
    4048:	e9 81       	ldd	r30, Y+1	; 0x01
    404a:	fa 81       	ldd	r31, Y+2	; 0x02
    404c:	95 83       	std	Z+5, r25	; 0x05
    404e:	84 83       	std	Z+4, r24	; 0x04
    4050:	e0 91 a6 06 	lds	r30, 0x06A6
    4054:	f0 91 a7 06 	lds	r31, 0x06A7
    4058:	8b 81       	ldd	r24, Y+3	; 0x03
    405a:	9c 81       	ldd	r25, Y+4	; 0x04
    405c:	95 8b       	std	Z+21, r25	; 0x15
    405e:	84 8b       	std	Z+20, r24	; 0x14
    4060:	eb 81       	ldd	r30, Y+3	; 0x03
    4062:	fc 81       	ldd	r31, Y+4	; 0x04
    4064:	80 81       	ld	r24, Z
    4066:	8f 5f       	subi	r24, 0xFF	; 255
    4068:	eb 81       	ldd	r30, Y+3	; 0x03
    406a:	fc 81       	ldd	r31, Y+4	; 0x04
    406c:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    406e:	8f 81       	ldd	r24, Y+7	; 0x07
    4070:	88 23       	and	r24, r24
    4072:	21 f0       	breq	.+8      	; 0x407c <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    4074:	8f ef       	ldi	r24, 0xFF	; 255
    4076:	9f ef       	ldi	r25, 0xFF	; 255
    4078:	9e 83       	std	Y+6, r25	; 0x06
    407a:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    407c:	8d 81       	ldd	r24, Y+5	; 0x05
    407e:	9e 81       	ldd	r25, Y+6	; 0x06
    4080:	6f 81       	ldd	r22, Y+7	; 0x07
    4082:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>
    }
    4086:	27 96       	adiw	r28, 0x07	; 7
    4088:	0f b6       	in	r0, 0x3f	; 63
    408a:	f8 94       	cli
    408c:	de bf       	out	0x3e, r29	; 62
    408e:	0f be       	out	0x3f, r0	; 63
    4090:	cd bf       	out	0x3d, r28	; 61
    4092:	cf 91       	pop	r28
    4094:	df 91       	pop	r29
    4096:	08 95       	ret

00004098 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4098:	df 93       	push	r29
    409a:	cf 93       	push	r28
    409c:	cd b7       	in	r28, 0x3d	; 61
    409e:	de b7       	in	r29, 0x3e	; 62
    40a0:	2d 97       	sbiw	r28, 0x0d	; 13
    40a2:	0f b6       	in	r0, 0x3f	; 63
    40a4:	f8 94       	cli
    40a6:	de bf       	out	0x3e, r29	; 62
    40a8:	0f be       	out	0x3f, r0	; 63
    40aa:	cd bf       	out	0x3d, r28	; 61
    40ac:	9d 87       	std	Y+13, r25	; 0x0d
    40ae:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    40b0:	ec 85       	ldd	r30, Y+12	; 0x0c
    40b2:	fd 85       	ldd	r31, Y+13	; 0x0d
    40b4:	05 80       	ldd	r0, Z+5	; 0x05
    40b6:	f6 81       	ldd	r31, Z+6	; 0x06
    40b8:	e0 2d       	mov	r30, r0
    40ba:	86 81       	ldd	r24, Z+6	; 0x06
    40bc:	97 81       	ldd	r25, Z+7	; 0x07
    40be:	9b 87       	std	Y+11, r25	; 0x0b
    40c0:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    40c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    40c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    40c6:	84 89       	ldd	r24, Z+20	; 0x14
    40c8:	95 89       	ldd	r25, Z+21	; 0x15
    40ca:	98 87       	std	Y+8, r25	; 0x08
    40cc:	8f 83       	std	Y+7, r24	; 0x07
    40ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    40d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    40d2:	a6 85       	ldd	r26, Z+14	; 0x0e
    40d4:	b7 85       	ldd	r27, Z+15	; 0x0f
    40d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    40d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    40da:	80 89       	ldd	r24, Z+16	; 0x10
    40dc:	91 89       	ldd	r25, Z+17	; 0x11
    40de:	15 96       	adiw	r26, 0x05	; 5
    40e0:	9c 93       	st	X, r25
    40e2:	8e 93       	st	-X, r24
    40e4:	14 97       	sbiw	r26, 0x04	; 4
    40e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    40e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    40ea:	a0 89       	ldd	r26, Z+16	; 0x10
    40ec:	b1 89       	ldd	r27, Z+17	; 0x11
    40ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    40f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    40f2:	86 85       	ldd	r24, Z+14	; 0x0e
    40f4:	97 85       	ldd	r25, Z+15	; 0x0f
    40f6:	13 96       	adiw	r26, 0x03	; 3
    40f8:	9c 93       	st	X, r25
    40fa:	8e 93       	st	-X, r24
    40fc:	12 97       	sbiw	r26, 0x02	; 2
    40fe:	ef 81       	ldd	r30, Y+7	; 0x07
    4100:	f8 85       	ldd	r31, Y+8	; 0x08
    4102:	21 81       	ldd	r18, Z+1	; 0x01
    4104:	32 81       	ldd	r19, Z+2	; 0x02
    4106:	8a 85       	ldd	r24, Y+10	; 0x0a
    4108:	9b 85       	ldd	r25, Y+11	; 0x0b
    410a:	0c 96       	adiw	r24, 0x0c	; 12
    410c:	28 17       	cp	r18, r24
    410e:	39 07       	cpc	r19, r25
    4110:	41 f4       	brne	.+16     	; 0x4122 <xTaskRemoveFromEventList+0x8a>
    4112:	ea 85       	ldd	r30, Y+10	; 0x0a
    4114:	fb 85       	ldd	r31, Y+11	; 0x0b
    4116:	80 89       	ldd	r24, Z+16	; 0x10
    4118:	91 89       	ldd	r25, Z+17	; 0x11
    411a:	ef 81       	ldd	r30, Y+7	; 0x07
    411c:	f8 85       	ldd	r31, Y+8	; 0x08
    411e:	92 83       	std	Z+2, r25	; 0x02
    4120:	81 83       	std	Z+1, r24	; 0x01
    4122:	ea 85       	ldd	r30, Y+10	; 0x0a
    4124:	fb 85       	ldd	r31, Y+11	; 0x0b
    4126:	15 8a       	std	Z+21, r1	; 0x15
    4128:	14 8a       	std	Z+20, r1	; 0x14
    412a:	ef 81       	ldd	r30, Y+7	; 0x07
    412c:	f8 85       	ldd	r31, Y+8	; 0x08
    412e:	80 81       	ld	r24, Z
    4130:	81 50       	subi	r24, 0x01	; 1
    4132:	ef 81       	ldd	r30, Y+7	; 0x07
    4134:	f8 85       	ldd	r31, Y+8	; 0x08
    4136:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4138:	80 91 b7 06 	lds	r24, 0x06B7
    413c:	88 23       	and	r24, r24
    413e:	09 f0       	breq	.+2      	; 0x4142 <xTaskRemoveFromEventList+0xaa>
    4140:	a4 c0       	rjmp	.+328    	; 0x428a <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4142:	ea 85       	ldd	r30, Y+10	; 0x0a
    4144:	fb 85       	ldd	r31, Y+11	; 0x0b
    4146:	82 85       	ldd	r24, Z+10	; 0x0a
    4148:	93 85       	ldd	r25, Z+11	; 0x0b
    414a:	9e 83       	std	Y+6, r25	; 0x06
    414c:	8d 83       	std	Y+5, r24	; 0x05
    414e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4150:	fb 85       	ldd	r31, Y+11	; 0x0b
    4152:	a4 81       	ldd	r26, Z+4	; 0x04
    4154:	b5 81       	ldd	r27, Z+5	; 0x05
    4156:	ea 85       	ldd	r30, Y+10	; 0x0a
    4158:	fb 85       	ldd	r31, Y+11	; 0x0b
    415a:	86 81       	ldd	r24, Z+6	; 0x06
    415c:	97 81       	ldd	r25, Z+7	; 0x07
    415e:	15 96       	adiw	r26, 0x05	; 5
    4160:	9c 93       	st	X, r25
    4162:	8e 93       	st	-X, r24
    4164:	14 97       	sbiw	r26, 0x04	; 4
    4166:	ea 85       	ldd	r30, Y+10	; 0x0a
    4168:	fb 85       	ldd	r31, Y+11	; 0x0b
    416a:	a6 81       	ldd	r26, Z+6	; 0x06
    416c:	b7 81       	ldd	r27, Z+7	; 0x07
    416e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4170:	fb 85       	ldd	r31, Y+11	; 0x0b
    4172:	84 81       	ldd	r24, Z+4	; 0x04
    4174:	95 81       	ldd	r25, Z+5	; 0x05
    4176:	13 96       	adiw	r26, 0x03	; 3
    4178:	9c 93       	st	X, r25
    417a:	8e 93       	st	-X, r24
    417c:	12 97       	sbiw	r26, 0x02	; 2
    417e:	ed 81       	ldd	r30, Y+5	; 0x05
    4180:	fe 81       	ldd	r31, Y+6	; 0x06
    4182:	21 81       	ldd	r18, Z+1	; 0x01
    4184:	32 81       	ldd	r19, Z+2	; 0x02
    4186:	8a 85       	ldd	r24, Y+10	; 0x0a
    4188:	9b 85       	ldd	r25, Y+11	; 0x0b
    418a:	02 96       	adiw	r24, 0x02	; 2
    418c:	28 17       	cp	r18, r24
    418e:	39 07       	cpc	r19, r25
    4190:	41 f4       	brne	.+16     	; 0x41a2 <xTaskRemoveFromEventList+0x10a>
    4192:	ea 85       	ldd	r30, Y+10	; 0x0a
    4194:	fb 85       	ldd	r31, Y+11	; 0x0b
    4196:	86 81       	ldd	r24, Z+6	; 0x06
    4198:	97 81       	ldd	r25, Z+7	; 0x07
    419a:	ed 81       	ldd	r30, Y+5	; 0x05
    419c:	fe 81       	ldd	r31, Y+6	; 0x06
    419e:	92 83       	std	Z+2, r25	; 0x02
    41a0:	81 83       	std	Z+1, r24	; 0x01
    41a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    41a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    41a6:	13 86       	std	Z+11, r1	; 0x0b
    41a8:	12 86       	std	Z+10, r1	; 0x0a
    41aa:	ed 81       	ldd	r30, Y+5	; 0x05
    41ac:	fe 81       	ldd	r31, Y+6	; 0x06
    41ae:	80 81       	ld	r24, Z
    41b0:	81 50       	subi	r24, 0x01	; 1
    41b2:	ed 81       	ldd	r30, Y+5	; 0x05
    41b4:	fe 81       	ldd	r31, Y+6	; 0x06
    41b6:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    41b8:	ea 85       	ldd	r30, Y+10	; 0x0a
    41ba:	fb 85       	ldd	r31, Y+11	; 0x0b
    41bc:	96 89       	ldd	r25, Z+22	; 0x16
    41be:	80 91 ac 06 	lds	r24, 0x06AC
    41c2:	89 17       	cp	r24, r25
    41c4:	28 f4       	brcc	.+10     	; 0x41d0 <xTaskRemoveFromEventList+0x138>
    41c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    41c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    41ca:	86 89       	ldd	r24, Z+22	; 0x16
    41cc:	80 93 ac 06 	sts	0x06AC, r24
    41d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    41d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    41d4:	86 89       	ldd	r24, Z+22	; 0x16
    41d6:	28 2f       	mov	r18, r24
    41d8:	30 e0       	ldi	r19, 0x00	; 0
    41da:	c9 01       	movw	r24, r18
    41dc:	88 0f       	add	r24, r24
    41de:	99 1f       	adc	r25, r25
    41e0:	88 0f       	add	r24, r24
    41e2:	99 1f       	adc	r25, r25
    41e4:	88 0f       	add	r24, r24
    41e6:	99 1f       	adc	r25, r25
    41e8:	82 0f       	add	r24, r18
    41ea:	93 1f       	adc	r25, r19
    41ec:	fc 01       	movw	r30, r24
    41ee:	e8 54       	subi	r30, 0x48	; 72
    41f0:	f9 4f       	sbci	r31, 0xF9	; 249
    41f2:	81 81       	ldd	r24, Z+1	; 0x01
    41f4:	92 81       	ldd	r25, Z+2	; 0x02
    41f6:	9c 83       	std	Y+4, r25	; 0x04
    41f8:	8b 83       	std	Y+3, r24	; 0x03
    41fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    41fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    41fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4200:	9c 81       	ldd	r25, Y+4	; 0x04
    4202:	95 83       	std	Z+5, r25	; 0x05
    4204:	84 83       	std	Z+4, r24	; 0x04
    4206:	eb 81       	ldd	r30, Y+3	; 0x03
    4208:	fc 81       	ldd	r31, Y+4	; 0x04
    420a:	84 81       	ldd	r24, Z+4	; 0x04
    420c:	95 81       	ldd	r25, Z+5	; 0x05
    420e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4210:	fb 85       	ldd	r31, Y+11	; 0x0b
    4212:	97 83       	std	Z+7, r25	; 0x07
    4214:	86 83       	std	Z+6, r24	; 0x06
    4216:	eb 81       	ldd	r30, Y+3	; 0x03
    4218:	fc 81       	ldd	r31, Y+4	; 0x04
    421a:	04 80       	ldd	r0, Z+4	; 0x04
    421c:	f5 81       	ldd	r31, Z+5	; 0x05
    421e:	e0 2d       	mov	r30, r0
    4220:	8a 85       	ldd	r24, Y+10	; 0x0a
    4222:	9b 85       	ldd	r25, Y+11	; 0x0b
    4224:	02 96       	adiw	r24, 0x02	; 2
    4226:	93 83       	std	Z+3, r25	; 0x03
    4228:	82 83       	std	Z+2, r24	; 0x02
    422a:	8a 85       	ldd	r24, Y+10	; 0x0a
    422c:	9b 85       	ldd	r25, Y+11	; 0x0b
    422e:	02 96       	adiw	r24, 0x02	; 2
    4230:	eb 81       	ldd	r30, Y+3	; 0x03
    4232:	fc 81       	ldd	r31, Y+4	; 0x04
    4234:	95 83       	std	Z+5, r25	; 0x05
    4236:	84 83       	std	Z+4, r24	; 0x04
    4238:	ea 85       	ldd	r30, Y+10	; 0x0a
    423a:	fb 85       	ldd	r31, Y+11	; 0x0b
    423c:	86 89       	ldd	r24, Z+22	; 0x16
    423e:	28 2f       	mov	r18, r24
    4240:	30 e0       	ldi	r19, 0x00	; 0
    4242:	c9 01       	movw	r24, r18
    4244:	88 0f       	add	r24, r24
    4246:	99 1f       	adc	r25, r25
    4248:	88 0f       	add	r24, r24
    424a:	99 1f       	adc	r25, r25
    424c:	88 0f       	add	r24, r24
    424e:	99 1f       	adc	r25, r25
    4250:	82 0f       	add	r24, r18
    4252:	93 1f       	adc	r25, r19
    4254:	88 54       	subi	r24, 0x48	; 72
    4256:	99 4f       	sbci	r25, 0xF9	; 249
    4258:	ea 85       	ldd	r30, Y+10	; 0x0a
    425a:	fb 85       	ldd	r31, Y+11	; 0x0b
    425c:	93 87       	std	Z+11, r25	; 0x0b
    425e:	82 87       	std	Z+10, r24	; 0x0a
    4260:	ea 85       	ldd	r30, Y+10	; 0x0a
    4262:	fb 85       	ldd	r31, Y+11	; 0x0b
    4264:	86 89       	ldd	r24, Z+22	; 0x16
    4266:	28 2f       	mov	r18, r24
    4268:	30 e0       	ldi	r19, 0x00	; 0
    426a:	c9 01       	movw	r24, r18
    426c:	88 0f       	add	r24, r24
    426e:	99 1f       	adc	r25, r25
    4270:	88 0f       	add	r24, r24
    4272:	99 1f       	adc	r25, r25
    4274:	88 0f       	add	r24, r24
    4276:	99 1f       	adc	r25, r25
    4278:	82 0f       	add	r24, r18
    427a:	93 1f       	adc	r25, r19
    427c:	fc 01       	movw	r30, r24
    427e:	e8 54       	subi	r30, 0x48	; 72
    4280:	f9 4f       	sbci	r31, 0xF9	; 249
    4282:	80 81       	ld	r24, Z
    4284:	8f 5f       	subi	r24, 0xFF	; 255
    4286:	80 83       	st	Z, r24
    4288:	30 c0       	rjmp	.+96     	; 0x42ea <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    428a:	80 91 f3 06 	lds	r24, 0x06F3
    428e:	90 91 f4 06 	lds	r25, 0x06F4
    4292:	9a 83       	std	Y+2, r25	; 0x02
    4294:	89 83       	std	Y+1, r24	; 0x01
    4296:	ea 85       	ldd	r30, Y+10	; 0x0a
    4298:	fb 85       	ldd	r31, Y+11	; 0x0b
    429a:	89 81       	ldd	r24, Y+1	; 0x01
    429c:	9a 81       	ldd	r25, Y+2	; 0x02
    429e:	97 87       	std	Z+15, r25	; 0x0f
    42a0:	86 87       	std	Z+14, r24	; 0x0e
    42a2:	e9 81       	ldd	r30, Y+1	; 0x01
    42a4:	fa 81       	ldd	r31, Y+2	; 0x02
    42a6:	84 81       	ldd	r24, Z+4	; 0x04
    42a8:	95 81       	ldd	r25, Z+5	; 0x05
    42aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    42ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    42ae:	91 8b       	std	Z+17, r25	; 0x11
    42b0:	80 8b       	std	Z+16, r24	; 0x10
    42b2:	e9 81       	ldd	r30, Y+1	; 0x01
    42b4:	fa 81       	ldd	r31, Y+2	; 0x02
    42b6:	04 80       	ldd	r0, Z+4	; 0x04
    42b8:	f5 81       	ldd	r31, Z+5	; 0x05
    42ba:	e0 2d       	mov	r30, r0
    42bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    42be:	9b 85       	ldd	r25, Y+11	; 0x0b
    42c0:	0c 96       	adiw	r24, 0x0c	; 12
    42c2:	93 83       	std	Z+3, r25	; 0x03
    42c4:	82 83       	std	Z+2, r24	; 0x02
    42c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    42c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    42ca:	0c 96       	adiw	r24, 0x0c	; 12
    42cc:	e9 81       	ldd	r30, Y+1	; 0x01
    42ce:	fa 81       	ldd	r31, Y+2	; 0x02
    42d0:	95 83       	std	Z+5, r25	; 0x05
    42d2:	84 83       	std	Z+4, r24	; 0x04
    42d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    42d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    42d8:	82 ef       	ldi	r24, 0xF2	; 242
    42da:	96 e0       	ldi	r25, 0x06	; 6
    42dc:	95 8b       	std	Z+21, r25	; 0x15
    42de:	84 8b       	std	Z+20, r24	; 0x14
    42e0:	80 91 f2 06 	lds	r24, 0x06F2
    42e4:	8f 5f       	subi	r24, 0xFF	; 255
    42e6:	80 93 f2 06 	sts	0x06F2, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    42ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    42ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    42ee:	96 89       	ldd	r25, Z+22	; 0x16
    42f0:	e0 91 a6 06 	lds	r30, 0x06A6
    42f4:	f0 91 a7 06 	lds	r31, 0x06A7
    42f8:	86 89       	ldd	r24, Z+22	; 0x16
    42fa:	89 17       	cp	r24, r25
    42fc:	30 f4       	brcc	.+12     	; 0x430a <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    42fe:	81 e0       	ldi	r24, 0x01	; 1
    4300:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4302:	81 e0       	ldi	r24, 0x01	; 1
    4304:	80 93 b0 06 	sts	0x06B0, r24
    4308:	01 c0       	rjmp	.+2      	; 0x430c <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    430a:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    430c:	89 85       	ldd	r24, Y+9	; 0x09
}
    430e:	2d 96       	adiw	r28, 0x0d	; 13
    4310:	0f b6       	in	r0, 0x3f	; 63
    4312:	f8 94       	cli
    4314:	de bf       	out	0x3e, r29	; 62
    4316:	0f be       	out	0x3f, r0	; 63
    4318:	cd bf       	out	0x3d, r28	; 61
    431a:	cf 91       	pop	r28
    431c:	df 91       	pop	r29
    431e:	08 95       	ret

00004320 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4320:	df 93       	push	r29
    4322:	cf 93       	push	r28
    4324:	cd b7       	in	r28, 0x3d	; 61
    4326:	de b7       	in	r29, 0x3e	; 62
    4328:	2c 97       	sbiw	r28, 0x0c	; 12
    432a:	0f b6       	in	r0, 0x3f	; 63
    432c:	f8 94       	cli
    432e:	de bf       	out	0x3e, r29	; 62
    4330:	0f be       	out	0x3f, r0	; 63
    4332:	cd bf       	out	0x3d, r28	; 61
    4334:	9a 87       	std	Y+10, r25	; 0x0a
    4336:	89 87       	std	Y+9, r24	; 0x09
    4338:	7c 87       	std	Y+12, r23	; 0x0c
    433a:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    433c:	8b 85       	ldd	r24, Y+11	; 0x0b
    433e:	9c 85       	ldd	r25, Y+12	; 0x0c
    4340:	90 68       	ori	r25, 0x80	; 128
    4342:	e9 85       	ldd	r30, Y+9	; 0x09
    4344:	fa 85       	ldd	r31, Y+10	; 0x0a
    4346:	91 83       	std	Z+1, r25	; 0x01
    4348:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    434a:	e9 85       	ldd	r30, Y+9	; 0x09
    434c:	fa 85       	ldd	r31, Y+10	; 0x0a
    434e:	86 81       	ldd	r24, Z+6	; 0x06
    4350:	97 81       	ldd	r25, Z+7	; 0x07
    4352:	98 87       	std	Y+8, r25	; 0x08
    4354:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    4356:	e9 85       	ldd	r30, Y+9	; 0x09
    4358:	fa 85       	ldd	r31, Y+10	; 0x0a
    435a:	80 85       	ldd	r24, Z+8	; 0x08
    435c:	91 85       	ldd	r25, Z+9	; 0x09
    435e:	9e 83       	std	Y+6, r25	; 0x06
    4360:	8d 83       	std	Y+5, r24	; 0x05
    4362:	e9 85       	ldd	r30, Y+9	; 0x09
    4364:	fa 85       	ldd	r31, Y+10	; 0x0a
    4366:	a2 81       	ldd	r26, Z+2	; 0x02
    4368:	b3 81       	ldd	r27, Z+3	; 0x03
    436a:	e9 85       	ldd	r30, Y+9	; 0x09
    436c:	fa 85       	ldd	r31, Y+10	; 0x0a
    436e:	84 81       	ldd	r24, Z+4	; 0x04
    4370:	95 81       	ldd	r25, Z+5	; 0x05
    4372:	15 96       	adiw	r26, 0x05	; 5
    4374:	9c 93       	st	X, r25
    4376:	8e 93       	st	-X, r24
    4378:	14 97       	sbiw	r26, 0x04	; 4
    437a:	e9 85       	ldd	r30, Y+9	; 0x09
    437c:	fa 85       	ldd	r31, Y+10	; 0x0a
    437e:	a4 81       	ldd	r26, Z+4	; 0x04
    4380:	b5 81       	ldd	r27, Z+5	; 0x05
    4382:	e9 85       	ldd	r30, Y+9	; 0x09
    4384:	fa 85       	ldd	r31, Y+10	; 0x0a
    4386:	82 81       	ldd	r24, Z+2	; 0x02
    4388:	93 81       	ldd	r25, Z+3	; 0x03
    438a:	13 96       	adiw	r26, 0x03	; 3
    438c:	9c 93       	st	X, r25
    438e:	8e 93       	st	-X, r24
    4390:	12 97       	sbiw	r26, 0x02	; 2
    4392:	ed 81       	ldd	r30, Y+5	; 0x05
    4394:	fe 81       	ldd	r31, Y+6	; 0x06
    4396:	21 81       	ldd	r18, Z+1	; 0x01
    4398:	32 81       	ldd	r19, Z+2	; 0x02
    439a:	89 85       	ldd	r24, Y+9	; 0x09
    439c:	9a 85       	ldd	r25, Y+10	; 0x0a
    439e:	28 17       	cp	r18, r24
    43a0:	39 07       	cpc	r19, r25
    43a2:	41 f4       	brne	.+16     	; 0x43b4 <vTaskRemoveFromUnorderedEventList+0x94>
    43a4:	e9 85       	ldd	r30, Y+9	; 0x09
    43a6:	fa 85       	ldd	r31, Y+10	; 0x0a
    43a8:	84 81       	ldd	r24, Z+4	; 0x04
    43aa:	95 81       	ldd	r25, Z+5	; 0x05
    43ac:	ed 81       	ldd	r30, Y+5	; 0x05
    43ae:	fe 81       	ldd	r31, Y+6	; 0x06
    43b0:	92 83       	std	Z+2, r25	; 0x02
    43b2:	81 83       	std	Z+1, r24	; 0x01
    43b4:	e9 85       	ldd	r30, Y+9	; 0x09
    43b6:	fa 85       	ldd	r31, Y+10	; 0x0a
    43b8:	11 86       	std	Z+9, r1	; 0x09
    43ba:	10 86       	std	Z+8, r1	; 0x08
    43bc:	ed 81       	ldd	r30, Y+5	; 0x05
    43be:	fe 81       	ldd	r31, Y+6	; 0x06
    43c0:	80 81       	ld	r24, Z
    43c2:	81 50       	subi	r24, 0x01	; 1
    43c4:	ed 81       	ldd	r30, Y+5	; 0x05
    43c6:	fe 81       	ldd	r31, Y+6	; 0x06
    43c8:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    43ca:	ef 81       	ldd	r30, Y+7	; 0x07
    43cc:	f8 85       	ldd	r31, Y+8	; 0x08
    43ce:	82 85       	ldd	r24, Z+10	; 0x0a
    43d0:	93 85       	ldd	r25, Z+11	; 0x0b
    43d2:	9c 83       	std	Y+4, r25	; 0x04
    43d4:	8b 83       	std	Y+3, r24	; 0x03
    43d6:	ef 81       	ldd	r30, Y+7	; 0x07
    43d8:	f8 85       	ldd	r31, Y+8	; 0x08
    43da:	a4 81       	ldd	r26, Z+4	; 0x04
    43dc:	b5 81       	ldd	r27, Z+5	; 0x05
    43de:	ef 81       	ldd	r30, Y+7	; 0x07
    43e0:	f8 85       	ldd	r31, Y+8	; 0x08
    43e2:	86 81       	ldd	r24, Z+6	; 0x06
    43e4:	97 81       	ldd	r25, Z+7	; 0x07
    43e6:	15 96       	adiw	r26, 0x05	; 5
    43e8:	9c 93       	st	X, r25
    43ea:	8e 93       	st	-X, r24
    43ec:	14 97       	sbiw	r26, 0x04	; 4
    43ee:	ef 81       	ldd	r30, Y+7	; 0x07
    43f0:	f8 85       	ldd	r31, Y+8	; 0x08
    43f2:	a6 81       	ldd	r26, Z+6	; 0x06
    43f4:	b7 81       	ldd	r27, Z+7	; 0x07
    43f6:	ef 81       	ldd	r30, Y+7	; 0x07
    43f8:	f8 85       	ldd	r31, Y+8	; 0x08
    43fa:	84 81       	ldd	r24, Z+4	; 0x04
    43fc:	95 81       	ldd	r25, Z+5	; 0x05
    43fe:	13 96       	adiw	r26, 0x03	; 3
    4400:	9c 93       	st	X, r25
    4402:	8e 93       	st	-X, r24
    4404:	12 97       	sbiw	r26, 0x02	; 2
    4406:	eb 81       	ldd	r30, Y+3	; 0x03
    4408:	fc 81       	ldd	r31, Y+4	; 0x04
    440a:	21 81       	ldd	r18, Z+1	; 0x01
    440c:	32 81       	ldd	r19, Z+2	; 0x02
    440e:	8f 81       	ldd	r24, Y+7	; 0x07
    4410:	98 85       	ldd	r25, Y+8	; 0x08
    4412:	02 96       	adiw	r24, 0x02	; 2
    4414:	28 17       	cp	r18, r24
    4416:	39 07       	cpc	r19, r25
    4418:	41 f4       	brne	.+16     	; 0x442a <vTaskRemoveFromUnorderedEventList+0x10a>
    441a:	ef 81       	ldd	r30, Y+7	; 0x07
    441c:	f8 85       	ldd	r31, Y+8	; 0x08
    441e:	86 81       	ldd	r24, Z+6	; 0x06
    4420:	97 81       	ldd	r25, Z+7	; 0x07
    4422:	eb 81       	ldd	r30, Y+3	; 0x03
    4424:	fc 81       	ldd	r31, Y+4	; 0x04
    4426:	92 83       	std	Z+2, r25	; 0x02
    4428:	81 83       	std	Z+1, r24	; 0x01
    442a:	ef 81       	ldd	r30, Y+7	; 0x07
    442c:	f8 85       	ldd	r31, Y+8	; 0x08
    442e:	13 86       	std	Z+11, r1	; 0x0b
    4430:	12 86       	std	Z+10, r1	; 0x0a
    4432:	eb 81       	ldd	r30, Y+3	; 0x03
    4434:	fc 81       	ldd	r31, Y+4	; 0x04
    4436:	80 81       	ld	r24, Z
    4438:	81 50       	subi	r24, 0x01	; 1
    443a:	eb 81       	ldd	r30, Y+3	; 0x03
    443c:	fc 81       	ldd	r31, Y+4	; 0x04
    443e:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4440:	ef 81       	ldd	r30, Y+7	; 0x07
    4442:	f8 85       	ldd	r31, Y+8	; 0x08
    4444:	96 89       	ldd	r25, Z+22	; 0x16
    4446:	80 91 ac 06 	lds	r24, 0x06AC
    444a:	89 17       	cp	r24, r25
    444c:	28 f4       	brcc	.+10     	; 0x4458 <vTaskRemoveFromUnorderedEventList+0x138>
    444e:	ef 81       	ldd	r30, Y+7	; 0x07
    4450:	f8 85       	ldd	r31, Y+8	; 0x08
    4452:	86 89       	ldd	r24, Z+22	; 0x16
    4454:	80 93 ac 06 	sts	0x06AC, r24
    4458:	ef 81       	ldd	r30, Y+7	; 0x07
    445a:	f8 85       	ldd	r31, Y+8	; 0x08
    445c:	86 89       	ldd	r24, Z+22	; 0x16
    445e:	28 2f       	mov	r18, r24
    4460:	30 e0       	ldi	r19, 0x00	; 0
    4462:	c9 01       	movw	r24, r18
    4464:	88 0f       	add	r24, r24
    4466:	99 1f       	adc	r25, r25
    4468:	88 0f       	add	r24, r24
    446a:	99 1f       	adc	r25, r25
    446c:	88 0f       	add	r24, r24
    446e:	99 1f       	adc	r25, r25
    4470:	82 0f       	add	r24, r18
    4472:	93 1f       	adc	r25, r19
    4474:	fc 01       	movw	r30, r24
    4476:	e8 54       	subi	r30, 0x48	; 72
    4478:	f9 4f       	sbci	r31, 0xF9	; 249
    447a:	81 81       	ldd	r24, Z+1	; 0x01
    447c:	92 81       	ldd	r25, Z+2	; 0x02
    447e:	9a 83       	std	Y+2, r25	; 0x02
    4480:	89 83       	std	Y+1, r24	; 0x01
    4482:	ef 81       	ldd	r30, Y+7	; 0x07
    4484:	f8 85       	ldd	r31, Y+8	; 0x08
    4486:	89 81       	ldd	r24, Y+1	; 0x01
    4488:	9a 81       	ldd	r25, Y+2	; 0x02
    448a:	95 83       	std	Z+5, r25	; 0x05
    448c:	84 83       	std	Z+4, r24	; 0x04
    448e:	e9 81       	ldd	r30, Y+1	; 0x01
    4490:	fa 81       	ldd	r31, Y+2	; 0x02
    4492:	84 81       	ldd	r24, Z+4	; 0x04
    4494:	95 81       	ldd	r25, Z+5	; 0x05
    4496:	ef 81       	ldd	r30, Y+7	; 0x07
    4498:	f8 85       	ldd	r31, Y+8	; 0x08
    449a:	97 83       	std	Z+7, r25	; 0x07
    449c:	86 83       	std	Z+6, r24	; 0x06
    449e:	e9 81       	ldd	r30, Y+1	; 0x01
    44a0:	fa 81       	ldd	r31, Y+2	; 0x02
    44a2:	04 80       	ldd	r0, Z+4	; 0x04
    44a4:	f5 81       	ldd	r31, Z+5	; 0x05
    44a6:	e0 2d       	mov	r30, r0
    44a8:	8f 81       	ldd	r24, Y+7	; 0x07
    44aa:	98 85       	ldd	r25, Y+8	; 0x08
    44ac:	02 96       	adiw	r24, 0x02	; 2
    44ae:	93 83       	std	Z+3, r25	; 0x03
    44b0:	82 83       	std	Z+2, r24	; 0x02
    44b2:	8f 81       	ldd	r24, Y+7	; 0x07
    44b4:	98 85       	ldd	r25, Y+8	; 0x08
    44b6:	02 96       	adiw	r24, 0x02	; 2
    44b8:	e9 81       	ldd	r30, Y+1	; 0x01
    44ba:	fa 81       	ldd	r31, Y+2	; 0x02
    44bc:	95 83       	std	Z+5, r25	; 0x05
    44be:	84 83       	std	Z+4, r24	; 0x04
    44c0:	ef 81       	ldd	r30, Y+7	; 0x07
    44c2:	f8 85       	ldd	r31, Y+8	; 0x08
    44c4:	86 89       	ldd	r24, Z+22	; 0x16
    44c6:	28 2f       	mov	r18, r24
    44c8:	30 e0       	ldi	r19, 0x00	; 0
    44ca:	c9 01       	movw	r24, r18
    44cc:	88 0f       	add	r24, r24
    44ce:	99 1f       	adc	r25, r25
    44d0:	88 0f       	add	r24, r24
    44d2:	99 1f       	adc	r25, r25
    44d4:	88 0f       	add	r24, r24
    44d6:	99 1f       	adc	r25, r25
    44d8:	82 0f       	add	r24, r18
    44da:	93 1f       	adc	r25, r19
    44dc:	88 54       	subi	r24, 0x48	; 72
    44de:	99 4f       	sbci	r25, 0xF9	; 249
    44e0:	ef 81       	ldd	r30, Y+7	; 0x07
    44e2:	f8 85       	ldd	r31, Y+8	; 0x08
    44e4:	93 87       	std	Z+11, r25	; 0x0b
    44e6:	82 87       	std	Z+10, r24	; 0x0a
    44e8:	ef 81       	ldd	r30, Y+7	; 0x07
    44ea:	f8 85       	ldd	r31, Y+8	; 0x08
    44ec:	86 89       	ldd	r24, Z+22	; 0x16
    44ee:	28 2f       	mov	r18, r24
    44f0:	30 e0       	ldi	r19, 0x00	; 0
    44f2:	c9 01       	movw	r24, r18
    44f4:	88 0f       	add	r24, r24
    44f6:	99 1f       	adc	r25, r25
    44f8:	88 0f       	add	r24, r24
    44fa:	99 1f       	adc	r25, r25
    44fc:	88 0f       	add	r24, r24
    44fe:	99 1f       	adc	r25, r25
    4500:	82 0f       	add	r24, r18
    4502:	93 1f       	adc	r25, r19
    4504:	fc 01       	movw	r30, r24
    4506:	e8 54       	subi	r30, 0x48	; 72
    4508:	f9 4f       	sbci	r31, 0xF9	; 249
    450a:	80 81       	ld	r24, Z
    450c:	8f 5f       	subi	r24, 0xFF	; 255
    450e:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4510:	ef 81       	ldd	r30, Y+7	; 0x07
    4512:	f8 85       	ldd	r31, Y+8	; 0x08
    4514:	96 89       	ldd	r25, Z+22	; 0x16
    4516:	e0 91 a6 06 	lds	r30, 0x06A6
    451a:	f0 91 a7 06 	lds	r31, 0x06A7
    451e:	86 89       	ldd	r24, Z+22	; 0x16
    4520:	89 17       	cp	r24, r25
    4522:	18 f4       	brcc	.+6      	; 0x452a <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4524:	81 e0       	ldi	r24, 0x01	; 1
    4526:	80 93 b0 06 	sts	0x06B0, r24
    }
}
    452a:	2c 96       	adiw	r28, 0x0c	; 12
    452c:	0f b6       	in	r0, 0x3f	; 63
    452e:	f8 94       	cli
    4530:	de bf       	out	0x3e, r29	; 62
    4532:	0f be       	out	0x3f, r0	; 63
    4534:	cd bf       	out	0x3d, r28	; 61
    4536:	cf 91       	pop	r28
    4538:	df 91       	pop	r29
    453a:	08 95       	ret

0000453c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    453c:	df 93       	push	r29
    453e:	cf 93       	push	r28
    4540:	00 d0       	rcall	.+0      	; 0x4542 <vTaskSetTimeOutState+0x6>
    4542:	cd b7       	in	r28, 0x3d	; 61
    4544:	de b7       	in	r29, 0x3e	; 62
    4546:	9a 83       	std	Y+2, r25	; 0x02
    4548:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    454a:	0f b6       	in	r0, 0x3f	; 63
    454c:	f8 94       	cli
    454e:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4550:	80 91 b1 06 	lds	r24, 0x06B1
    4554:	e9 81       	ldd	r30, Y+1	; 0x01
    4556:	fa 81       	ldd	r31, Y+2	; 0x02
    4558:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    455a:	80 91 aa 06 	lds	r24, 0x06AA
    455e:	90 91 ab 06 	lds	r25, 0x06AB
    4562:	e9 81       	ldd	r30, Y+1	; 0x01
    4564:	fa 81       	ldd	r31, Y+2	; 0x02
    4566:	92 83       	std	Z+2, r25	; 0x02
    4568:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    456a:	0f 90       	pop	r0
    456c:	0f be       	out	0x3f, r0	; 63
}
    456e:	0f 90       	pop	r0
    4570:	0f 90       	pop	r0
    4572:	cf 91       	pop	r28
    4574:	df 91       	pop	r29
    4576:	08 95       	ret

00004578 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4578:	df 93       	push	r29
    457a:	cf 93       	push	r28
    457c:	00 d0       	rcall	.+0      	; 0x457e <vTaskInternalSetTimeOutState+0x6>
    457e:	cd b7       	in	r28, 0x3d	; 61
    4580:	de b7       	in	r29, 0x3e	; 62
    4582:	9a 83       	std	Y+2, r25	; 0x02
    4584:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4586:	80 91 b1 06 	lds	r24, 0x06B1
    458a:	e9 81       	ldd	r30, Y+1	; 0x01
    458c:	fa 81       	ldd	r31, Y+2	; 0x02
    458e:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4590:	80 91 aa 06 	lds	r24, 0x06AA
    4594:	90 91 ab 06 	lds	r25, 0x06AB
    4598:	e9 81       	ldd	r30, Y+1	; 0x01
    459a:	fa 81       	ldd	r31, Y+2	; 0x02
    459c:	92 83       	std	Z+2, r25	; 0x02
    459e:	81 83       	std	Z+1, r24	; 0x01
}
    45a0:	0f 90       	pop	r0
    45a2:	0f 90       	pop	r0
    45a4:	cf 91       	pop	r28
    45a6:	df 91       	pop	r29
    45a8:	08 95       	ret

000045aa <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    45aa:	df 93       	push	r29
    45ac:	cf 93       	push	r28
    45ae:	cd b7       	in	r28, 0x3d	; 61
    45b0:	de b7       	in	r29, 0x3e	; 62
    45b2:	29 97       	sbiw	r28, 0x09	; 9
    45b4:	0f b6       	in	r0, 0x3f	; 63
    45b6:	f8 94       	cli
    45b8:	de bf       	out	0x3e, r29	; 62
    45ba:	0f be       	out	0x3f, r0	; 63
    45bc:	cd bf       	out	0x3d, r28	; 61
    45be:	9f 83       	std	Y+7, r25	; 0x07
    45c0:	8e 83       	std	Y+6, r24	; 0x06
    45c2:	79 87       	std	Y+9, r23	; 0x09
    45c4:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    45c6:	0f b6       	in	r0, 0x3f	; 63
    45c8:	f8 94       	cli
    45ca:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    45cc:	80 91 aa 06 	lds	r24, 0x06AA
    45d0:	90 91 ab 06 	lds	r25, 0x06AB
    45d4:	9c 83       	std	Y+4, r25	; 0x04
    45d6:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    45d8:	ee 81       	ldd	r30, Y+6	; 0x06
    45da:	ff 81       	ldd	r31, Y+7	; 0x07
    45dc:	21 81       	ldd	r18, Z+1	; 0x01
    45de:	32 81       	ldd	r19, Z+2	; 0x02
    45e0:	8b 81       	ldd	r24, Y+3	; 0x03
    45e2:	9c 81       	ldd	r25, Y+4	; 0x04
    45e4:	82 1b       	sub	r24, r18
    45e6:	93 0b       	sbc	r25, r19
    45e8:	9a 83       	std	Y+2, r25	; 0x02
    45ea:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    45ec:	ee 81       	ldd	r30, Y+6	; 0x06
    45ee:	ff 81       	ldd	r31, Y+7	; 0x07
    45f0:	90 81       	ld	r25, Z
    45f2:	80 91 b1 06 	lds	r24, 0x06B1
    45f6:	98 17       	cp	r25, r24
    45f8:	81 f0       	breq	.+32     	; 0x461a <xTaskCheckForTimeOut+0x70>
    45fa:	ee 81       	ldd	r30, Y+6	; 0x06
    45fc:	ff 81       	ldd	r31, Y+7	; 0x07
    45fe:	21 81       	ldd	r18, Z+1	; 0x01
    4600:	32 81       	ldd	r19, Z+2	; 0x02
    4602:	8b 81       	ldd	r24, Y+3	; 0x03
    4604:	9c 81       	ldd	r25, Y+4	; 0x04
    4606:	82 17       	cp	r24, r18
    4608:	93 07       	cpc	r25, r19
    460a:	38 f0       	brcs	.+14     	; 0x461a <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    460c:	81 e0       	ldi	r24, 0x01	; 1
    460e:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    4610:	e8 85       	ldd	r30, Y+8	; 0x08
    4612:	f9 85       	ldd	r31, Y+9	; 0x09
    4614:	11 82       	std	Z+1, r1	; 0x01
    4616:	10 82       	st	Z, r1
    4618:	23 c0       	rjmp	.+70     	; 0x4660 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    461a:	e8 85       	ldd	r30, Y+8	; 0x08
    461c:	f9 85       	ldd	r31, Y+9	; 0x09
    461e:	20 81       	ld	r18, Z
    4620:	31 81       	ldd	r19, Z+1	; 0x01
    4622:	89 81       	ldd	r24, Y+1	; 0x01
    4624:	9a 81       	ldd	r25, Y+2	; 0x02
    4626:	82 17       	cp	r24, r18
    4628:	93 07       	cpc	r25, r19
    462a:	a0 f4       	brcc	.+40     	; 0x4654 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    462c:	e8 85       	ldd	r30, Y+8	; 0x08
    462e:	f9 85       	ldd	r31, Y+9	; 0x09
    4630:	20 81       	ld	r18, Z
    4632:	31 81       	ldd	r19, Z+1	; 0x01
    4634:	89 81       	ldd	r24, Y+1	; 0x01
    4636:	9a 81       	ldd	r25, Y+2	; 0x02
    4638:	a9 01       	movw	r20, r18
    463a:	48 1b       	sub	r20, r24
    463c:	59 0b       	sbc	r21, r25
    463e:	ca 01       	movw	r24, r20
    4640:	e8 85       	ldd	r30, Y+8	; 0x08
    4642:	f9 85       	ldd	r31, Y+9	; 0x09
    4644:	91 83       	std	Z+1, r25	; 0x01
    4646:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    4648:	8e 81       	ldd	r24, Y+6	; 0x06
    464a:	9f 81       	ldd	r25, Y+7	; 0x07
    464c:	0e 94 bc 22 	call	0x4578	; 0x4578 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4650:	1d 82       	std	Y+5, r1	; 0x05
    4652:	06 c0       	rjmp	.+12     	; 0x4660 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4654:	e8 85       	ldd	r30, Y+8	; 0x08
    4656:	f9 85       	ldd	r31, Y+9	; 0x09
    4658:	11 82       	std	Z+1, r1	; 0x01
    465a:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    465c:	81 e0       	ldi	r24, 0x01	; 1
    465e:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    4660:	0f 90       	pop	r0
    4662:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4664:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4666:	29 96       	adiw	r28, 0x09	; 9
    4668:	0f b6       	in	r0, 0x3f	; 63
    466a:	f8 94       	cli
    466c:	de bf       	out	0x3e, r29	; 62
    466e:	0f be       	out	0x3f, r0	; 63
    4670:	cd bf       	out	0x3d, r28	; 61
    4672:	cf 91       	pop	r28
    4674:	df 91       	pop	r29
    4676:	08 95       	ret

00004678 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4678:	df 93       	push	r29
    467a:	cf 93       	push	r28
    467c:	cd b7       	in	r28, 0x3d	; 61
    467e:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    4680:	81 e0       	ldi	r24, 0x01	; 1
    4682:	80 93 b0 06 	sts	0x06B0, r24
}
    4686:	cf 91       	pop	r28
    4688:	df 91       	pop	r29
    468a:	08 95       	ret

0000468c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    468c:	df 93       	push	r29
    468e:	cf 93       	push	r28
    4690:	00 d0       	rcall	.+0      	; 0x4692 <prvIdleTask+0x6>
    4692:	cd b7       	in	r28, 0x3d	; 61
    4694:	de b7       	in	r29, 0x3e	; 62
    4696:	9a 83       	std	Y+2, r25	; 0x02
    4698:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    469a:	0e 94 93 23 	call	0x4726	; 0x4726 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    469e:	80 91 b8 06 	lds	r24, 0x06B8
    46a2:	82 30       	cpi	r24, 0x02	; 2
    46a4:	d0 f3       	brcs	.-12     	; 0x469a <prvIdleTask+0xe>
                {
                    taskYIELD();
    46a6:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    46aa:	f7 cf       	rjmp	.-18     	; 0x469a <prvIdleTask+0xe>

000046ac <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    46ac:	df 93       	push	r29
    46ae:	cf 93       	push	r28
    46b0:	0f 92       	push	r0
    46b2:	cd b7       	in	r28, 0x3d	; 61
    46b4:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    46b6:	19 82       	std	Y+1, r1	; 0x01
    46b8:	13 c0       	rjmp	.+38     	; 0x46e0 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    46ba:	89 81       	ldd	r24, Y+1	; 0x01
    46bc:	28 2f       	mov	r18, r24
    46be:	30 e0       	ldi	r19, 0x00	; 0
    46c0:	c9 01       	movw	r24, r18
    46c2:	88 0f       	add	r24, r24
    46c4:	99 1f       	adc	r25, r25
    46c6:	88 0f       	add	r24, r24
    46c8:	99 1f       	adc	r25, r25
    46ca:	88 0f       	add	r24, r24
    46cc:	99 1f       	adc	r25, r25
    46ce:	82 0f       	add	r24, r18
    46d0:	93 1f       	adc	r25, r19
    46d2:	88 54       	subi	r24, 0x48	; 72
    46d4:	99 4f       	sbci	r25, 0xF9	; 249
    46d6:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    46da:	89 81       	ldd	r24, Y+1	; 0x01
    46dc:	8f 5f       	subi	r24, 0xFF	; 255
    46de:	89 83       	std	Y+1, r24	; 0x01
    46e0:	89 81       	ldd	r24, Y+1	; 0x01
    46e2:	84 30       	cpi	r24, 0x04	; 4
    46e4:	50 f3       	brcs	.-44     	; 0x46ba <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    46e6:	8c ed       	ldi	r24, 0xDC	; 220
    46e8:	96 e0       	ldi	r25, 0x06	; 6
    46ea:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    46ee:	85 ee       	ldi	r24, 0xE5	; 229
    46f0:	96 e0       	ldi	r25, 0x06	; 6
    46f2:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    46f6:	82 ef       	ldi	r24, 0xF2	; 242
    46f8:	96 e0       	ldi	r25, 0x06	; 6
    46fa:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    46fe:	8b ef       	ldi	r24, 0xFB	; 251
    4700:	96 e0       	ldi	r25, 0x06	; 6
    4702:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4706:	8c ed       	ldi	r24, 0xDC	; 220
    4708:	96 e0       	ldi	r25, 0x06	; 6
    470a:	90 93 ef 06 	sts	0x06EF, r25
    470e:	80 93 ee 06 	sts	0x06EE, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4712:	85 ee       	ldi	r24, 0xE5	; 229
    4714:	96 e0       	ldi	r25, 0x06	; 6
    4716:	90 93 f1 06 	sts	0x06F1, r25
    471a:	80 93 f0 06 	sts	0x06F0, r24
}
    471e:	0f 90       	pop	r0
    4720:	cf 91       	pop	r28
    4722:	df 91       	pop	r29
    4724:	08 95       	ret

00004726 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4726:	df 93       	push	r29
    4728:	cf 93       	push	r28
    472a:	00 d0       	rcall	.+0      	; 0x472c <prvCheckTasksWaitingTermination+0x6>
    472c:	cd b7       	in	r28, 0x3d	; 61
    472e:	de b7       	in	r29, 0x3e	; 62
    4730:	20 c0       	rjmp	.+64     	; 0x4772 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    4732:	0f b6       	in	r0, 0x3f	; 63
    4734:	f8 94       	cli
    4736:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4738:	e0 91 00 07 	lds	r30, 0x0700
    473c:	f0 91 01 07 	lds	r31, 0x0701
    4740:	86 81       	ldd	r24, Z+6	; 0x06
    4742:	97 81       	ldd	r25, Z+7	; 0x07
    4744:	9a 83       	std	Y+2, r25	; 0x02
    4746:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4748:	89 81       	ldd	r24, Y+1	; 0x01
    474a:	9a 81       	ldd	r25, Y+2	; 0x02
    474c:	02 96       	adiw	r24, 0x02	; 2
    474e:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    4752:	80 91 a9 06 	lds	r24, 0x06A9
    4756:	81 50       	subi	r24, 0x01	; 1
    4758:	80 93 a9 06 	sts	0x06A9, r24
                    --uxDeletedTasksWaitingCleanUp;
    475c:	80 91 a8 06 	lds	r24, 0x06A8
    4760:	81 50       	subi	r24, 0x01	; 1
    4762:	80 93 a8 06 	sts	0x06A8, r24
                }
                taskEXIT_CRITICAL();
    4766:	0f 90       	pop	r0
    4768:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    476a:	89 81       	ldd	r24, Y+1	; 0x01
    476c:	9a 81       	ldd	r25, Y+2	; 0x02
    476e:	0e 94 c2 23 	call	0x4784	; 0x4784 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4772:	80 91 a8 06 	lds	r24, 0x06A8
    4776:	88 23       	and	r24, r24
    4778:	e1 f6       	brne	.-72     	; 0x4732 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    477a:	0f 90       	pop	r0
    477c:	0f 90       	pop	r0
    477e:	cf 91       	pop	r28
    4780:	df 91       	pop	r29
    4782:	08 95       	ret

00004784 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    4784:	df 93       	push	r29
    4786:	cf 93       	push	r28
    4788:	00 d0       	rcall	.+0      	; 0x478a <prvDeleteTCB+0x6>
    478a:	cd b7       	in	r28, 0x3d	; 61
    478c:	de b7       	in	r29, 0x3e	; 62
    478e:	9a 83       	std	Y+2, r25	; 0x02
    4790:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    4792:	e9 81       	ldd	r30, Y+1	; 0x01
    4794:	fa 81       	ldd	r31, Y+2	; 0x02
    4796:	87 89       	ldd	r24, Z+23	; 0x17
    4798:	90 8d       	ldd	r25, Z+24	; 0x18
    479a:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                vPortFree( pxTCB );
    479e:	89 81       	ldd	r24, Y+1	; 0x01
    47a0:	9a 81       	ldd	r25, Y+2	; 0x02
    47a2:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    47a6:	0f 90       	pop	r0
    47a8:	0f 90       	pop	r0
    47aa:	cf 91       	pop	r28
    47ac:	df 91       	pop	r29
    47ae:	08 95       	ret

000047b0 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    47b0:	df 93       	push	r29
    47b2:	cf 93       	push	r28
    47b4:	cd b7       	in	r28, 0x3d	; 61
    47b6:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    47b8:	e0 91 ee 06 	lds	r30, 0x06EE
    47bc:	f0 91 ef 06 	lds	r31, 0x06EF
    47c0:	80 81       	ld	r24, Z
    47c2:	88 23       	and	r24, r24
    47c4:	39 f4       	brne	.+14     	; 0x47d4 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    47c6:	8f ef       	ldi	r24, 0xFF	; 255
    47c8:	9f ef       	ldi	r25, 0xFF	; 255
    47ca:	90 93 b4 06 	sts	0x06B4, r25
    47ce:	80 93 b3 06 	sts	0x06B3, r24
    47d2:	0d c0       	rjmp	.+26     	; 0x47ee <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    47d4:	e0 91 ee 06 	lds	r30, 0x06EE
    47d8:	f0 91 ef 06 	lds	r31, 0x06EF
    47dc:	05 80       	ldd	r0, Z+5	; 0x05
    47de:	f6 81       	ldd	r31, Z+6	; 0x06
    47e0:	e0 2d       	mov	r30, r0
    47e2:	80 81       	ld	r24, Z
    47e4:	91 81       	ldd	r25, Z+1	; 0x01
    47e6:	90 93 b4 06 	sts	0x06B4, r25
    47ea:	80 93 b3 06 	sts	0x06B3, r24
    }
}
    47ee:	cf 91       	pop	r28
    47f0:	df 91       	pop	r29
    47f2:	08 95       	ret

000047f4 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    47f4:	df 93       	push	r29
    47f6:	cf 93       	push	r28
    47f8:	0f 92       	push	r0
    47fa:	cd b7       	in	r28, 0x3d	; 61
    47fc:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    47fe:	80 91 ad 06 	lds	r24, 0x06AD
    4802:	88 23       	and	r24, r24
    4804:	19 f4       	brne	.+6      	; 0x480c <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    4806:	81 e0       	ldi	r24, 0x01	; 1
    4808:	89 83       	std	Y+1, r24	; 0x01
    480a:	08 c0       	rjmp	.+16     	; 0x481c <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    480c:	80 91 b7 06 	lds	r24, 0x06B7
    4810:	88 23       	and	r24, r24
    4812:	19 f4       	brne	.+6      	; 0x481a <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    4814:	82 e0       	ldi	r24, 0x02	; 2
    4816:	89 83       	std	Y+1, r24	; 0x01
    4818:	01 c0       	rjmp	.+2      	; 0x481c <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    481a:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    481c:	89 81       	ldd	r24, Y+1	; 0x01
    }
    481e:	0f 90       	pop	r0
    4820:	cf 91       	pop	r28
    4822:	df 91       	pop	r29
    4824:	08 95       	ret

00004826 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4826:	df 93       	push	r29
    4828:	cf 93       	push	r28
    482a:	00 d0       	rcall	.+0      	; 0x482c <uxTaskResetEventItemValue+0x6>
    482c:	cd b7       	in	r28, 0x3d	; 61
    482e:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4830:	e0 91 a6 06 	lds	r30, 0x06A6
    4834:	f0 91 a7 06 	lds	r31, 0x06A7
    4838:	84 85       	ldd	r24, Z+12	; 0x0c
    483a:	95 85       	ldd	r25, Z+13	; 0x0d
    483c:	9a 83       	std	Y+2, r25	; 0x02
    483e:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4840:	a0 91 a6 06 	lds	r26, 0x06A6
    4844:	b0 91 a7 06 	lds	r27, 0x06A7
    4848:	e0 91 a6 06 	lds	r30, 0x06A6
    484c:	f0 91 a7 06 	lds	r31, 0x06A7
    4850:	86 89       	ldd	r24, Z+22	; 0x16
    4852:	28 2f       	mov	r18, r24
    4854:	30 e0       	ldi	r19, 0x00	; 0
    4856:	84 e0       	ldi	r24, 0x04	; 4
    4858:	90 e0       	ldi	r25, 0x00	; 0
    485a:	82 1b       	sub	r24, r18
    485c:	93 0b       	sbc	r25, r19
    485e:	1d 96       	adiw	r26, 0x0d	; 13
    4860:	9c 93       	st	X, r25
    4862:	8e 93       	st	-X, r24
    4864:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4866:	89 81       	ldd	r24, Y+1	; 0x01
    4868:	9a 81       	ldd	r25, Y+2	; 0x02
}
    486a:	0f 90       	pop	r0
    486c:	0f 90       	pop	r0
    486e:	cf 91       	pop	r28
    4870:	df 91       	pop	r29
    4872:	08 95       	ret

00004874 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    4874:	df 93       	push	r29
    4876:	cf 93       	push	r28
    4878:	cd b7       	in	r28, 0x3d	; 61
    487a:	de b7       	in	r29, 0x3e	; 62
    487c:	28 97       	sbiw	r28, 0x08	; 8
    487e:	0f b6       	in	r0, 0x3f	; 63
    4880:	f8 94       	cli
    4882:	de bf       	out	0x3e, r29	; 62
    4884:	0f be       	out	0x3f, r0	; 63
    4886:	cd bf       	out	0x3d, r28	; 61
    4888:	8d 83       	std	Y+5, r24	; 0x05
    488a:	6e 83       	std	Y+6, r22	; 0x06
    488c:	58 87       	std	Y+8, r21	; 0x08
    488e:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4890:	0f b6       	in	r0, 0x3f	; 63
    4892:	f8 94       	cli
    4894:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4896:	20 91 a6 06 	lds	r18, 0x06A6
    489a:	30 91 a7 06 	lds	r19, 0x06A7
    489e:	8d 81       	ldd	r24, Y+5	; 0x05
    48a0:	88 2f       	mov	r24, r24
    48a2:	90 e0       	ldi	r25, 0x00	; 0
    48a4:	88 0f       	add	r24, r24
    48a6:	99 1f       	adc	r25, r25
    48a8:	88 0f       	add	r24, r24
    48aa:	99 1f       	adc	r25, r25
    48ac:	82 0f       	add	r24, r18
    48ae:	93 1f       	adc	r25, r19
    48b0:	fc 01       	movw	r30, r24
    48b2:	b1 96       	adiw	r30, 0x21	; 33
    48b4:	80 81       	ld	r24, Z
    48b6:	91 81       	ldd	r25, Z+1	; 0x01
    48b8:	a2 81       	ldd	r26, Z+2	; 0x02
    48ba:	b3 81       	ldd	r27, Z+3	; 0x03
    48bc:	00 97       	sbiw	r24, 0x00	; 0
    48be:	a1 05       	cpc	r26, r1
    48c0:	b1 05       	cpc	r27, r1
    48c2:	c1 f4       	brne	.+48     	; 0x48f4 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    48c4:	20 91 a6 06 	lds	r18, 0x06A6
    48c8:	30 91 a7 06 	lds	r19, 0x06A7
    48cc:	8d 81       	ldd	r24, Y+5	; 0x05
    48ce:	88 2f       	mov	r24, r24
    48d0:	90 e0       	ldi	r25, 0x00	; 0
    48d2:	82 0f       	add	r24, r18
    48d4:	93 1f       	adc	r25, r19
    48d6:	fc 01       	movw	r30, r24
    48d8:	b5 96       	adiw	r30, 0x25	; 37
    48da:	81 e0       	ldi	r24, 0x01	; 1
    48dc:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    48de:	8f 81       	ldd	r24, Y+7	; 0x07
    48e0:	98 85       	ldd	r25, Y+8	; 0x08
    48e2:	00 97       	sbiw	r24, 0x00	; 0
    48e4:	39 f0       	breq	.+14     	; 0x48f4 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    48e6:	8f 81       	ldd	r24, Y+7	; 0x07
    48e8:	98 85       	ldd	r25, Y+8	; 0x08
    48ea:	61 e0       	ldi	r22, 0x01	; 1
    48ec:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    48f0:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    48f4:	0f 90       	pop	r0
    48f6:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    48f8:	0f b6       	in	r0, 0x3f	; 63
    48fa:	f8 94       	cli
    48fc:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    48fe:	20 91 a6 06 	lds	r18, 0x06A6
    4902:	30 91 a7 06 	lds	r19, 0x06A7
    4906:	8d 81       	ldd	r24, Y+5	; 0x05
    4908:	88 2f       	mov	r24, r24
    490a:	90 e0       	ldi	r25, 0x00	; 0
    490c:	88 0f       	add	r24, r24
    490e:	99 1f       	adc	r25, r25
    4910:	88 0f       	add	r24, r24
    4912:	99 1f       	adc	r25, r25
    4914:	82 0f       	add	r24, r18
    4916:	93 1f       	adc	r25, r19
    4918:	fc 01       	movw	r30, r24
    491a:	b1 96       	adiw	r30, 0x21	; 33
    491c:	80 81       	ld	r24, Z
    491e:	91 81       	ldd	r25, Z+1	; 0x01
    4920:	a2 81       	ldd	r26, Z+2	; 0x02
    4922:	b3 81       	ldd	r27, Z+3	; 0x03
    4924:	89 83       	std	Y+1, r24	; 0x01
    4926:	9a 83       	std	Y+2, r25	; 0x02
    4928:	ab 83       	std	Y+3, r26	; 0x03
    492a:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    492c:	89 81       	ldd	r24, Y+1	; 0x01
    492e:	9a 81       	ldd	r25, Y+2	; 0x02
    4930:	ab 81       	ldd	r26, Y+3	; 0x03
    4932:	bc 81       	ldd	r27, Y+4	; 0x04
    4934:	00 97       	sbiw	r24, 0x00	; 0
    4936:	a1 05       	cpc	r26, r1
    4938:	b1 05       	cpc	r27, r1
    493a:	a9 f1       	breq	.+106    	; 0x49a6 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    493c:	8e 81       	ldd	r24, Y+6	; 0x06
    493e:	88 23       	and	r24, r24
    4940:	a1 f0       	breq	.+40     	; 0x496a <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4942:	20 91 a6 06 	lds	r18, 0x06A6
    4946:	30 91 a7 06 	lds	r19, 0x06A7
    494a:	8d 81       	ldd	r24, Y+5	; 0x05
    494c:	88 2f       	mov	r24, r24
    494e:	90 e0       	ldi	r25, 0x00	; 0
    4950:	88 0f       	add	r24, r24
    4952:	99 1f       	adc	r25, r25
    4954:	88 0f       	add	r24, r24
    4956:	99 1f       	adc	r25, r25
    4958:	82 0f       	add	r24, r18
    495a:	93 1f       	adc	r25, r19
    495c:	fc 01       	movw	r30, r24
    495e:	b1 96       	adiw	r30, 0x21	; 33
    4960:	10 82       	st	Z, r1
    4962:	11 82       	std	Z+1, r1	; 0x01
    4964:	12 82       	std	Z+2, r1	; 0x02
    4966:	13 82       	std	Z+3, r1	; 0x03
    4968:	1e c0       	rjmp	.+60     	; 0x49a6 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    496a:	e0 91 a6 06 	lds	r30, 0x06A6
    496e:	f0 91 a7 06 	lds	r31, 0x06A7
    4972:	8d 81       	ldd	r24, Y+5	; 0x05
    4974:	68 2f       	mov	r22, r24
    4976:	70 e0       	ldi	r23, 0x00	; 0
    4978:	89 81       	ldd	r24, Y+1	; 0x01
    497a:	9a 81       	ldd	r25, Y+2	; 0x02
    497c:	ab 81       	ldd	r26, Y+3	; 0x03
    497e:	bc 81       	ldd	r27, Y+4	; 0x04
    4980:	9c 01       	movw	r18, r24
    4982:	ad 01       	movw	r20, r26
    4984:	21 50       	subi	r18, 0x01	; 1
    4986:	30 40       	sbci	r19, 0x00	; 0
    4988:	40 40       	sbci	r20, 0x00	; 0
    498a:	50 40       	sbci	r21, 0x00	; 0
    498c:	cb 01       	movw	r24, r22
    498e:	88 0f       	add	r24, r24
    4990:	99 1f       	adc	r25, r25
    4992:	88 0f       	add	r24, r24
    4994:	99 1f       	adc	r25, r25
    4996:	8e 0f       	add	r24, r30
    4998:	9f 1f       	adc	r25, r31
    499a:	fc 01       	movw	r30, r24
    499c:	b1 96       	adiw	r30, 0x21	; 33
    499e:	20 83       	st	Z, r18
    49a0:	31 83       	std	Z+1, r19	; 0x01
    49a2:	42 83       	std	Z+2, r20	; 0x02
    49a4:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    49a6:	20 91 a6 06 	lds	r18, 0x06A6
    49aa:	30 91 a7 06 	lds	r19, 0x06A7
    49ae:	8d 81       	ldd	r24, Y+5	; 0x05
    49b0:	88 2f       	mov	r24, r24
    49b2:	90 e0       	ldi	r25, 0x00	; 0
    49b4:	82 0f       	add	r24, r18
    49b6:	93 1f       	adc	r25, r19
    49b8:	fc 01       	movw	r30, r24
    49ba:	b5 96       	adiw	r30, 0x25	; 37
    49bc:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    49be:	0f 90       	pop	r0
    49c0:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    49c2:	89 81       	ldd	r24, Y+1	; 0x01
    49c4:	9a 81       	ldd	r25, Y+2	; 0x02
    49c6:	ab 81       	ldd	r26, Y+3	; 0x03
    49c8:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    49ca:	bc 01       	movw	r22, r24
    49cc:	cd 01       	movw	r24, r26
    49ce:	28 96       	adiw	r28, 0x08	; 8
    49d0:	0f b6       	in	r0, 0x3f	; 63
    49d2:	f8 94       	cli
    49d4:	de bf       	out	0x3e, r29	; 62
    49d6:	0f be       	out	0x3f, r0	; 63
    49d8:	cd bf       	out	0x3d, r28	; 61
    49da:	cf 91       	pop	r28
    49dc:	df 91       	pop	r29
    49de:	08 95       	ret

000049e0 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    49e0:	cf 92       	push	r12
    49e2:	df 92       	push	r13
    49e4:	ef 92       	push	r14
    49e6:	ff 92       	push	r15
    49e8:	0f 93       	push	r16
    49ea:	1f 93       	push	r17
    49ec:	df 93       	push	r29
    49ee:	cf 93       	push	r28
    49f0:	cd b7       	in	r28, 0x3d	; 61
    49f2:	de b7       	in	r29, 0x3e	; 62
    49f4:	2e 97       	sbiw	r28, 0x0e	; 14
    49f6:	0f b6       	in	r0, 0x3f	; 63
    49f8:	f8 94       	cli
    49fa:	de bf       	out	0x3e, r29	; 62
    49fc:	0f be       	out	0x3f, r0	; 63
    49fe:	cd bf       	out	0x3d, r28	; 61
    4a00:	8a 83       	std	Y+2, r24	; 0x02
    4a02:	4b 83       	std	Y+3, r20	; 0x03
    4a04:	5c 83       	std	Y+4, r21	; 0x04
    4a06:	6d 83       	std	Y+5, r22	; 0x05
    4a08:	7e 83       	std	Y+6, r23	; 0x06
    4a0a:	0f 83       	std	Y+7, r16	; 0x07
    4a0c:	18 87       	std	Y+8, r17	; 0x08
    4a0e:	29 87       	std	Y+9, r18	; 0x09
    4a10:	3a 87       	std	Y+10, r19	; 0x0a
    4a12:	fc 86       	std	Y+12, r15	; 0x0c
    4a14:	eb 86       	std	Y+11, r14	; 0x0b
    4a16:	de 86       	std	Y+14, r13	; 0x0e
    4a18:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4a1a:	0f b6       	in	r0, 0x3f	; 63
    4a1c:	f8 94       	cli
    4a1e:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4a20:	20 91 a6 06 	lds	r18, 0x06A6
    4a24:	30 91 a7 06 	lds	r19, 0x06A7
    4a28:	8a 81       	ldd	r24, Y+2	; 0x02
    4a2a:	88 2f       	mov	r24, r24
    4a2c:	90 e0       	ldi	r25, 0x00	; 0
    4a2e:	82 0f       	add	r24, r18
    4a30:	93 1f       	adc	r25, r19
    4a32:	fc 01       	movw	r30, r24
    4a34:	b5 96       	adiw	r30, 0x25	; 37
    4a36:	80 81       	ld	r24, Z
    4a38:	82 30       	cpi	r24, 0x02	; 2
    4a3a:	09 f4       	brne	.+2      	; 0x4a3e <xTaskGenericNotifyWait+0x5e>
    4a3c:	47 c0       	rjmp	.+142    	; 0x4acc <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    4a3e:	60 91 a6 06 	lds	r22, 0x06A6
    4a42:	70 91 a7 06 	lds	r23, 0x06A7
    4a46:	8a 81       	ldd	r24, Y+2	; 0x02
    4a48:	08 2f       	mov	r16, r24
    4a4a:	10 e0       	ldi	r17, 0x00	; 0
    4a4c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a4e:	88 2f       	mov	r24, r24
    4a50:	90 e0       	ldi	r25, 0x00	; 0
    4a52:	88 0f       	add	r24, r24
    4a54:	99 1f       	adc	r25, r25
    4a56:	88 0f       	add	r24, r24
    4a58:	99 1f       	adc	r25, r25
    4a5a:	86 0f       	add	r24, r22
    4a5c:	97 1f       	adc	r25, r23
    4a5e:	fc 01       	movw	r30, r24
    4a60:	b1 96       	adiw	r30, 0x21	; 33
    4a62:	20 81       	ld	r18, Z
    4a64:	31 81       	ldd	r19, Z+1	; 0x01
    4a66:	42 81       	ldd	r20, Z+2	; 0x02
    4a68:	53 81       	ldd	r21, Z+3	; 0x03
    4a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a6e:	ad 81       	ldd	r26, Y+5	; 0x05
    4a70:	be 81       	ldd	r27, Y+6	; 0x06
    4a72:	80 95       	com	r24
    4a74:	90 95       	com	r25
    4a76:	a0 95       	com	r26
    4a78:	b0 95       	com	r27
    4a7a:	28 23       	and	r18, r24
    4a7c:	39 23       	and	r19, r25
    4a7e:	4a 23       	and	r20, r26
    4a80:	5b 23       	and	r21, r27
    4a82:	c8 01       	movw	r24, r16
    4a84:	88 0f       	add	r24, r24
    4a86:	99 1f       	adc	r25, r25
    4a88:	88 0f       	add	r24, r24
    4a8a:	99 1f       	adc	r25, r25
    4a8c:	86 0f       	add	r24, r22
    4a8e:	97 1f       	adc	r25, r23
    4a90:	fc 01       	movw	r30, r24
    4a92:	b1 96       	adiw	r30, 0x21	; 33
    4a94:	20 83       	st	Z, r18
    4a96:	31 83       	std	Z+1, r19	; 0x01
    4a98:	42 83       	std	Z+2, r20	; 0x02
    4a9a:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4a9c:	20 91 a6 06 	lds	r18, 0x06A6
    4aa0:	30 91 a7 06 	lds	r19, 0x06A7
    4aa4:	8a 81       	ldd	r24, Y+2	; 0x02
    4aa6:	88 2f       	mov	r24, r24
    4aa8:	90 e0       	ldi	r25, 0x00	; 0
    4aaa:	82 0f       	add	r24, r18
    4aac:	93 1f       	adc	r25, r19
    4aae:	fc 01       	movw	r30, r24
    4ab0:	b5 96       	adiw	r30, 0x25	; 37
    4ab2:	81 e0       	ldi	r24, 0x01	; 1
    4ab4:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4ab6:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ab8:	9e 85       	ldd	r25, Y+14	; 0x0e
    4aba:	00 97       	sbiw	r24, 0x00	; 0
    4abc:	39 f0       	breq	.+14     	; 0x4acc <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4abe:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ac0:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ac2:	61 e0       	ldi	r22, 0x01	; 1
    4ac4:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4ac8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4acc:	0f 90       	pop	r0
    4ace:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4ad0:	0f b6       	in	r0, 0x3f	; 63
    4ad2:	f8 94       	cli
    4ad4:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4ad6:	8b 85       	ldd	r24, Y+11	; 0x0b
    4ad8:	9c 85       	ldd	r25, Y+12	; 0x0c
    4ada:	00 97       	sbiw	r24, 0x00	; 0
    4adc:	c9 f0       	breq	.+50     	; 0x4b10 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4ade:	20 91 a6 06 	lds	r18, 0x06A6
    4ae2:	30 91 a7 06 	lds	r19, 0x06A7
    4ae6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ae8:	88 2f       	mov	r24, r24
    4aea:	90 e0       	ldi	r25, 0x00	; 0
    4aec:	88 0f       	add	r24, r24
    4aee:	99 1f       	adc	r25, r25
    4af0:	88 0f       	add	r24, r24
    4af2:	99 1f       	adc	r25, r25
    4af4:	82 0f       	add	r24, r18
    4af6:	93 1f       	adc	r25, r19
    4af8:	fc 01       	movw	r30, r24
    4afa:	b1 96       	adiw	r30, 0x21	; 33
    4afc:	80 81       	ld	r24, Z
    4afe:	91 81       	ldd	r25, Z+1	; 0x01
    4b00:	a2 81       	ldd	r26, Z+2	; 0x02
    4b02:	b3 81       	ldd	r27, Z+3	; 0x03
    4b04:	eb 85       	ldd	r30, Y+11	; 0x0b
    4b06:	fc 85       	ldd	r31, Y+12	; 0x0c
    4b08:	80 83       	st	Z, r24
    4b0a:	91 83       	std	Z+1, r25	; 0x01
    4b0c:	a2 83       	std	Z+2, r26	; 0x02
    4b0e:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4b10:	20 91 a6 06 	lds	r18, 0x06A6
    4b14:	30 91 a7 06 	lds	r19, 0x06A7
    4b18:	8a 81       	ldd	r24, Y+2	; 0x02
    4b1a:	88 2f       	mov	r24, r24
    4b1c:	90 e0       	ldi	r25, 0x00	; 0
    4b1e:	82 0f       	add	r24, r18
    4b20:	93 1f       	adc	r25, r19
    4b22:	fc 01       	movw	r30, r24
    4b24:	b5 96       	adiw	r30, 0x25	; 37
    4b26:	80 81       	ld	r24, Z
    4b28:	82 30       	cpi	r24, 0x02	; 2
    4b2a:	11 f0       	breq	.+4      	; 0x4b30 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    4b2c:	19 82       	std	Y+1, r1	; 0x01
    4b2e:	31 c0       	rjmp	.+98     	; 0x4b92 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4b30:	60 91 a6 06 	lds	r22, 0x06A6
    4b34:	70 91 a7 06 	lds	r23, 0x06A7
    4b38:	8a 81       	ldd	r24, Y+2	; 0x02
    4b3a:	08 2f       	mov	r16, r24
    4b3c:	10 e0       	ldi	r17, 0x00	; 0
    4b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b40:	88 2f       	mov	r24, r24
    4b42:	90 e0       	ldi	r25, 0x00	; 0
    4b44:	88 0f       	add	r24, r24
    4b46:	99 1f       	adc	r25, r25
    4b48:	88 0f       	add	r24, r24
    4b4a:	99 1f       	adc	r25, r25
    4b4c:	86 0f       	add	r24, r22
    4b4e:	97 1f       	adc	r25, r23
    4b50:	fc 01       	movw	r30, r24
    4b52:	b1 96       	adiw	r30, 0x21	; 33
    4b54:	20 81       	ld	r18, Z
    4b56:	31 81       	ldd	r19, Z+1	; 0x01
    4b58:	42 81       	ldd	r20, Z+2	; 0x02
    4b5a:	53 81       	ldd	r21, Z+3	; 0x03
    4b5c:	8f 81       	ldd	r24, Y+7	; 0x07
    4b5e:	98 85       	ldd	r25, Y+8	; 0x08
    4b60:	a9 85       	ldd	r26, Y+9	; 0x09
    4b62:	ba 85       	ldd	r27, Y+10	; 0x0a
    4b64:	80 95       	com	r24
    4b66:	90 95       	com	r25
    4b68:	a0 95       	com	r26
    4b6a:	b0 95       	com	r27
    4b6c:	28 23       	and	r18, r24
    4b6e:	39 23       	and	r19, r25
    4b70:	4a 23       	and	r20, r26
    4b72:	5b 23       	and	r21, r27
    4b74:	c8 01       	movw	r24, r16
    4b76:	88 0f       	add	r24, r24
    4b78:	99 1f       	adc	r25, r25
    4b7a:	88 0f       	add	r24, r24
    4b7c:	99 1f       	adc	r25, r25
    4b7e:	86 0f       	add	r24, r22
    4b80:	97 1f       	adc	r25, r23
    4b82:	fc 01       	movw	r30, r24
    4b84:	b1 96       	adiw	r30, 0x21	; 33
    4b86:	20 83       	st	Z, r18
    4b88:	31 83       	std	Z+1, r19	; 0x01
    4b8a:	42 83       	std	Z+2, r20	; 0x02
    4b8c:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    4b8e:	81 e0       	ldi	r24, 0x01	; 1
    4b90:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4b92:	20 91 a6 06 	lds	r18, 0x06A6
    4b96:	30 91 a7 06 	lds	r19, 0x06A7
    4b9a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b9c:	88 2f       	mov	r24, r24
    4b9e:	90 e0       	ldi	r25, 0x00	; 0
    4ba0:	82 0f       	add	r24, r18
    4ba2:	93 1f       	adc	r25, r19
    4ba4:	fc 01       	movw	r30, r24
    4ba6:	b5 96       	adiw	r30, 0x25	; 37
    4ba8:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4baa:	0f 90       	pop	r0
    4bac:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4bae:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4bb0:	2e 96       	adiw	r28, 0x0e	; 14
    4bb2:	0f b6       	in	r0, 0x3f	; 63
    4bb4:	f8 94       	cli
    4bb6:	de bf       	out	0x3e, r29	; 62
    4bb8:	0f be       	out	0x3f, r0	; 63
    4bba:	cd bf       	out	0x3d, r28	; 61
    4bbc:	cf 91       	pop	r28
    4bbe:	df 91       	pop	r29
    4bc0:	1f 91       	pop	r17
    4bc2:	0f 91       	pop	r16
    4bc4:	ff 90       	pop	r15
    4bc6:	ef 90       	pop	r14
    4bc8:	df 90       	pop	r13
    4bca:	cf 90       	pop	r12
    4bcc:	08 95       	ret

00004bce <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    4bce:	ef 92       	push	r14
    4bd0:	ff 92       	push	r15
    4bd2:	0f 93       	push	r16
    4bd4:	1f 93       	push	r17
    4bd6:	df 93       	push	r29
    4bd8:	cf 93       	push	r28
    4bda:	cd b7       	in	r28, 0x3d	; 61
    4bdc:	de b7       	in	r29, 0x3e	; 62
    4bde:	64 97       	sbiw	r28, 0x14	; 20
    4be0:	0f b6       	in	r0, 0x3f	; 63
    4be2:	f8 94       	cli
    4be4:	de bf       	out	0x3e, r29	; 62
    4be6:	0f be       	out	0x3f, r0	; 63
    4be8:	cd bf       	out	0x3d, r28	; 61
    4bea:	9a 87       	std	Y+10, r25	; 0x0a
    4bec:	89 87       	std	Y+9, r24	; 0x09
    4bee:	6b 87       	std	Y+11, r22	; 0x0b
    4bf0:	2c 87       	std	Y+12, r18	; 0x0c
    4bf2:	3d 87       	std	Y+13, r19	; 0x0d
    4bf4:	4e 87       	std	Y+14, r20	; 0x0e
    4bf6:	5f 87       	std	Y+15, r21	; 0x0f
    4bf8:	08 8b       	std	Y+16, r16	; 0x10
    4bfa:	fa 8a       	std	Y+18, r15	; 0x12
    4bfc:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    4bfe:	81 e0       	ldi	r24, 0x01	; 1
    4c00:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    4c02:	89 85       	ldd	r24, Y+9	; 0x09
    4c04:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c06:	98 87       	std	Y+8, r25	; 0x08
    4c08:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    4c0a:	0f b6       	in	r0, 0x3f	; 63
    4c0c:	f8 94       	cli
    4c0e:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    4c10:	89 89       	ldd	r24, Y+17	; 0x11
    4c12:	9a 89       	ldd	r25, Y+18	; 0x12
    4c14:	00 97       	sbiw	r24, 0x00	; 0
    4c16:	b9 f0       	breq	.+46     	; 0x4c46 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4c18:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c1a:	88 2f       	mov	r24, r24
    4c1c:	90 e0       	ldi	r25, 0x00	; 0
    4c1e:	2f 81       	ldd	r18, Y+7	; 0x07
    4c20:	38 85       	ldd	r19, Y+8	; 0x08
    4c22:	88 0f       	add	r24, r24
    4c24:	99 1f       	adc	r25, r25
    4c26:	88 0f       	add	r24, r24
    4c28:	99 1f       	adc	r25, r25
    4c2a:	82 0f       	add	r24, r18
    4c2c:	93 1f       	adc	r25, r19
    4c2e:	fc 01       	movw	r30, r24
    4c30:	b1 96       	adiw	r30, 0x21	; 33
    4c32:	80 81       	ld	r24, Z
    4c34:	91 81       	ldd	r25, Z+1	; 0x01
    4c36:	a2 81       	ldd	r26, Z+2	; 0x02
    4c38:	b3 81       	ldd	r27, Z+3	; 0x03
    4c3a:	e9 89       	ldd	r30, Y+17	; 0x11
    4c3c:	fa 89       	ldd	r31, Y+18	; 0x12
    4c3e:	80 83       	st	Z, r24
    4c40:	91 83       	std	Z+1, r25	; 0x01
    4c42:	a2 83       	std	Z+2, r26	; 0x02
    4c44:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4c46:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c48:	28 2f       	mov	r18, r24
    4c4a:	30 e0       	ldi	r19, 0x00	; 0
    4c4c:	8f 81       	ldd	r24, Y+7	; 0x07
    4c4e:	98 85       	ldd	r25, Y+8	; 0x08
    4c50:	82 0f       	add	r24, r18
    4c52:	93 1f       	adc	r25, r19
    4c54:	fc 01       	movw	r30, r24
    4c56:	b5 96       	adiw	r30, 0x25	; 37
    4c58:	80 81       	ld	r24, Z
    4c5a:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4c5c:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c5e:	28 2f       	mov	r18, r24
    4c60:	30 e0       	ldi	r19, 0x00	; 0
    4c62:	8f 81       	ldd	r24, Y+7	; 0x07
    4c64:	98 85       	ldd	r25, Y+8	; 0x08
    4c66:	82 0f       	add	r24, r18
    4c68:	93 1f       	adc	r25, r19
    4c6a:	fc 01       	movw	r30, r24
    4c6c:	b5 96       	adiw	r30, 0x25	; 37
    4c6e:	82 e0       	ldi	r24, 0x02	; 2
    4c70:	80 83       	st	Z, r24

            switch( eAction )
    4c72:	88 89       	ldd	r24, Y+16	; 0x10
    4c74:	28 2f       	mov	r18, r24
    4c76:	30 e0       	ldi	r19, 0x00	; 0
    4c78:	3c 8b       	std	Y+20, r19	; 0x14
    4c7a:	2b 8b       	std	Y+19, r18	; 0x13
    4c7c:	8b 89       	ldd	r24, Y+19	; 0x13
    4c7e:	9c 89       	ldd	r25, Y+20	; 0x14
    4c80:	82 30       	cpi	r24, 0x02	; 2
    4c82:	91 05       	cpc	r25, r1
    4c84:	09 f4       	brne	.+2      	; 0x4c88 <xTaskGenericNotify+0xba>
    4c86:	46 c0       	rjmp	.+140    	; 0x4d14 <xTaskGenericNotify+0x146>
    4c88:	2b 89       	ldd	r18, Y+19	; 0x13
    4c8a:	3c 89       	ldd	r19, Y+20	; 0x14
    4c8c:	23 30       	cpi	r18, 0x03	; 3
    4c8e:	31 05       	cpc	r19, r1
    4c90:	34 f4       	brge	.+12     	; 0x4c9e <xTaskGenericNotify+0xd0>
    4c92:	8b 89       	ldd	r24, Y+19	; 0x13
    4c94:	9c 89       	ldd	r25, Y+20	; 0x14
    4c96:	81 30       	cpi	r24, 0x01	; 1
    4c98:	91 05       	cpc	r25, r1
    4c9a:	71 f0       	breq	.+28     	; 0x4cb8 <xTaskGenericNotify+0xea>
    4c9c:	93 c0       	rjmp	.+294    	; 0x4dc4 <xTaskGenericNotify+0x1f6>
    4c9e:	2b 89       	ldd	r18, Y+19	; 0x13
    4ca0:	3c 89       	ldd	r19, Y+20	; 0x14
    4ca2:	23 30       	cpi	r18, 0x03	; 3
    4ca4:	31 05       	cpc	r19, r1
    4ca6:	09 f4       	brne	.+2      	; 0x4caa <xTaskGenericNotify+0xdc>
    4ca8:	5d c0       	rjmp	.+186    	; 0x4d64 <xTaskGenericNotify+0x196>
    4caa:	8b 89       	ldd	r24, Y+19	; 0x13
    4cac:	9c 89       	ldd	r25, Y+20	; 0x14
    4cae:	84 30       	cpi	r24, 0x04	; 4
    4cb0:	91 05       	cpc	r25, r1
    4cb2:	09 f4       	brne	.+2      	; 0x4cb6 <xTaskGenericNotify+0xe8>
    4cb4:	6d c0       	rjmp	.+218    	; 0x4d90 <xTaskGenericNotify+0x1c2>
    4cb6:	86 c0       	rjmp	.+268    	; 0x4dc4 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4cb8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cba:	08 2f       	mov	r16, r24
    4cbc:	10 e0       	ldi	r17, 0x00	; 0
    4cbe:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cc0:	88 2f       	mov	r24, r24
    4cc2:	90 e0       	ldi	r25, 0x00	; 0
    4cc4:	2f 81       	ldd	r18, Y+7	; 0x07
    4cc6:	38 85       	ldd	r19, Y+8	; 0x08
    4cc8:	88 0f       	add	r24, r24
    4cca:	99 1f       	adc	r25, r25
    4ccc:	88 0f       	add	r24, r24
    4cce:	99 1f       	adc	r25, r25
    4cd0:	82 0f       	add	r24, r18
    4cd2:	93 1f       	adc	r25, r19
    4cd4:	fc 01       	movw	r30, r24
    4cd6:	b1 96       	adiw	r30, 0x21	; 33
    4cd8:	20 81       	ld	r18, Z
    4cda:	31 81       	ldd	r19, Z+1	; 0x01
    4cdc:	42 81       	ldd	r20, Z+2	; 0x02
    4cde:	53 81       	ldd	r21, Z+3	; 0x03
    4ce0:	8c 85       	ldd	r24, Y+12	; 0x0c
    4ce2:	9d 85       	ldd	r25, Y+13	; 0x0d
    4ce4:	ae 85       	ldd	r26, Y+14	; 0x0e
    4ce6:	bf 85       	ldd	r27, Y+15	; 0x0f
    4ce8:	ba 01       	movw	r22, r20
    4cea:	a9 01       	movw	r20, r18
    4cec:	48 2b       	or	r20, r24
    4cee:	59 2b       	or	r21, r25
    4cf0:	6a 2b       	or	r22, r26
    4cf2:	7b 2b       	or	r23, r27
    4cf4:	2f 81       	ldd	r18, Y+7	; 0x07
    4cf6:	38 85       	ldd	r19, Y+8	; 0x08
    4cf8:	c8 01       	movw	r24, r16
    4cfa:	88 0f       	add	r24, r24
    4cfc:	99 1f       	adc	r25, r25
    4cfe:	88 0f       	add	r24, r24
    4d00:	99 1f       	adc	r25, r25
    4d02:	82 0f       	add	r24, r18
    4d04:	93 1f       	adc	r25, r19
    4d06:	fc 01       	movw	r30, r24
    4d08:	b1 96       	adiw	r30, 0x21	; 33
    4d0a:	40 83       	st	Z, r20
    4d0c:	51 83       	std	Z+1, r21	; 0x01
    4d0e:	62 83       	std	Z+2, r22	; 0x02
    4d10:	73 83       	std	Z+3, r23	; 0x03
    4d12:	58 c0       	rjmp	.+176    	; 0x4dc4 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4d14:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d16:	08 2f       	mov	r16, r24
    4d18:	10 e0       	ldi	r17, 0x00	; 0
    4d1a:	2f 81       	ldd	r18, Y+7	; 0x07
    4d1c:	38 85       	ldd	r19, Y+8	; 0x08
    4d1e:	c8 01       	movw	r24, r16
    4d20:	88 0f       	add	r24, r24
    4d22:	99 1f       	adc	r25, r25
    4d24:	88 0f       	add	r24, r24
    4d26:	99 1f       	adc	r25, r25
    4d28:	82 0f       	add	r24, r18
    4d2a:	93 1f       	adc	r25, r19
    4d2c:	fc 01       	movw	r30, r24
    4d2e:	b1 96       	adiw	r30, 0x21	; 33
    4d30:	80 81       	ld	r24, Z
    4d32:	91 81       	ldd	r25, Z+1	; 0x01
    4d34:	a2 81       	ldd	r26, Z+2	; 0x02
    4d36:	b3 81       	ldd	r27, Z+3	; 0x03
    4d38:	ac 01       	movw	r20, r24
    4d3a:	bd 01       	movw	r22, r26
    4d3c:	4f 5f       	subi	r20, 0xFF	; 255
    4d3e:	5f 4f       	sbci	r21, 0xFF	; 255
    4d40:	6f 4f       	sbci	r22, 0xFF	; 255
    4d42:	7f 4f       	sbci	r23, 0xFF	; 255
    4d44:	2f 81       	ldd	r18, Y+7	; 0x07
    4d46:	38 85       	ldd	r19, Y+8	; 0x08
    4d48:	c8 01       	movw	r24, r16
    4d4a:	88 0f       	add	r24, r24
    4d4c:	99 1f       	adc	r25, r25
    4d4e:	88 0f       	add	r24, r24
    4d50:	99 1f       	adc	r25, r25
    4d52:	82 0f       	add	r24, r18
    4d54:	93 1f       	adc	r25, r19
    4d56:	fc 01       	movw	r30, r24
    4d58:	b1 96       	adiw	r30, 0x21	; 33
    4d5a:	40 83       	st	Z, r20
    4d5c:	51 83       	std	Z+1, r21	; 0x01
    4d5e:	62 83       	std	Z+2, r22	; 0x02
    4d60:	73 83       	std	Z+3, r23	; 0x03
    4d62:	30 c0       	rjmp	.+96     	; 0x4dc4 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4d64:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d66:	88 2f       	mov	r24, r24
    4d68:	90 e0       	ldi	r25, 0x00	; 0
    4d6a:	2f 81       	ldd	r18, Y+7	; 0x07
    4d6c:	38 85       	ldd	r19, Y+8	; 0x08
    4d6e:	88 0f       	add	r24, r24
    4d70:	99 1f       	adc	r25, r25
    4d72:	88 0f       	add	r24, r24
    4d74:	99 1f       	adc	r25, r25
    4d76:	82 0f       	add	r24, r18
    4d78:	93 1f       	adc	r25, r19
    4d7a:	fc 01       	movw	r30, r24
    4d7c:	b1 96       	adiw	r30, 0x21	; 33
    4d7e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d80:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d82:	ae 85       	ldd	r26, Y+14	; 0x0e
    4d84:	bf 85       	ldd	r27, Y+15	; 0x0f
    4d86:	80 83       	st	Z, r24
    4d88:	91 83       	std	Z+1, r25	; 0x01
    4d8a:	a2 83       	std	Z+2, r26	; 0x02
    4d8c:	b3 83       	std	Z+3, r27	; 0x03
    4d8e:	1a c0       	rjmp	.+52     	; 0x4dc4 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4d90:	8d 81       	ldd	r24, Y+5	; 0x05
    4d92:	82 30       	cpi	r24, 0x02	; 2
    4d94:	b1 f0       	breq	.+44     	; 0x4dc2 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4d96:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d98:	88 2f       	mov	r24, r24
    4d9a:	90 e0       	ldi	r25, 0x00	; 0
    4d9c:	2f 81       	ldd	r18, Y+7	; 0x07
    4d9e:	38 85       	ldd	r19, Y+8	; 0x08
    4da0:	88 0f       	add	r24, r24
    4da2:	99 1f       	adc	r25, r25
    4da4:	88 0f       	add	r24, r24
    4da6:	99 1f       	adc	r25, r25
    4da8:	82 0f       	add	r24, r18
    4daa:	93 1f       	adc	r25, r19
    4dac:	fc 01       	movw	r30, r24
    4dae:	b1 96       	adiw	r30, 0x21	; 33
    4db0:	8c 85       	ldd	r24, Y+12	; 0x0c
    4db2:	9d 85       	ldd	r25, Y+13	; 0x0d
    4db4:	ae 85       	ldd	r26, Y+14	; 0x0e
    4db6:	bf 85       	ldd	r27, Y+15	; 0x0f
    4db8:	80 83       	st	Z, r24
    4dba:	91 83       	std	Z+1, r25	; 0x01
    4dbc:	a2 83       	std	Z+2, r26	; 0x02
    4dbe:	b3 83       	std	Z+3, r27	; 0x03
    4dc0:	01 c0       	rjmp	.+2      	; 0x4dc4 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4dc2:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4dc4:	8d 81       	ldd	r24, Y+5	; 0x05
    4dc6:	81 30       	cpi	r24, 0x01	; 1
    4dc8:	09 f0       	breq	.+2      	; 0x4dcc <xTaskGenericNotify+0x1fe>
    4dca:	af c0       	rjmp	.+350    	; 0x4f2a <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4dcc:	ef 81       	ldd	r30, Y+7	; 0x07
    4dce:	f8 85       	ldd	r31, Y+8	; 0x08
    4dd0:	82 85       	ldd	r24, Z+10	; 0x0a
    4dd2:	93 85       	ldd	r25, Z+11	; 0x0b
    4dd4:	9c 83       	std	Y+4, r25	; 0x04
    4dd6:	8b 83       	std	Y+3, r24	; 0x03
    4dd8:	ef 81       	ldd	r30, Y+7	; 0x07
    4dda:	f8 85       	ldd	r31, Y+8	; 0x08
    4ddc:	a4 81       	ldd	r26, Z+4	; 0x04
    4dde:	b5 81       	ldd	r27, Z+5	; 0x05
    4de0:	ef 81       	ldd	r30, Y+7	; 0x07
    4de2:	f8 85       	ldd	r31, Y+8	; 0x08
    4de4:	86 81       	ldd	r24, Z+6	; 0x06
    4de6:	97 81       	ldd	r25, Z+7	; 0x07
    4de8:	15 96       	adiw	r26, 0x05	; 5
    4dea:	9c 93       	st	X, r25
    4dec:	8e 93       	st	-X, r24
    4dee:	14 97       	sbiw	r26, 0x04	; 4
    4df0:	ef 81       	ldd	r30, Y+7	; 0x07
    4df2:	f8 85       	ldd	r31, Y+8	; 0x08
    4df4:	a6 81       	ldd	r26, Z+6	; 0x06
    4df6:	b7 81       	ldd	r27, Z+7	; 0x07
    4df8:	ef 81       	ldd	r30, Y+7	; 0x07
    4dfa:	f8 85       	ldd	r31, Y+8	; 0x08
    4dfc:	84 81       	ldd	r24, Z+4	; 0x04
    4dfe:	95 81       	ldd	r25, Z+5	; 0x05
    4e00:	13 96       	adiw	r26, 0x03	; 3
    4e02:	9c 93       	st	X, r25
    4e04:	8e 93       	st	-X, r24
    4e06:	12 97       	sbiw	r26, 0x02	; 2
    4e08:	eb 81       	ldd	r30, Y+3	; 0x03
    4e0a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e0c:	21 81       	ldd	r18, Z+1	; 0x01
    4e0e:	32 81       	ldd	r19, Z+2	; 0x02
    4e10:	8f 81       	ldd	r24, Y+7	; 0x07
    4e12:	98 85       	ldd	r25, Y+8	; 0x08
    4e14:	02 96       	adiw	r24, 0x02	; 2
    4e16:	28 17       	cp	r18, r24
    4e18:	39 07       	cpc	r19, r25
    4e1a:	41 f4       	brne	.+16     	; 0x4e2c <xTaskGenericNotify+0x25e>
    4e1c:	ef 81       	ldd	r30, Y+7	; 0x07
    4e1e:	f8 85       	ldd	r31, Y+8	; 0x08
    4e20:	86 81       	ldd	r24, Z+6	; 0x06
    4e22:	97 81       	ldd	r25, Z+7	; 0x07
    4e24:	eb 81       	ldd	r30, Y+3	; 0x03
    4e26:	fc 81       	ldd	r31, Y+4	; 0x04
    4e28:	92 83       	std	Z+2, r25	; 0x02
    4e2a:	81 83       	std	Z+1, r24	; 0x01
    4e2c:	ef 81       	ldd	r30, Y+7	; 0x07
    4e2e:	f8 85       	ldd	r31, Y+8	; 0x08
    4e30:	13 86       	std	Z+11, r1	; 0x0b
    4e32:	12 86       	std	Z+10, r1	; 0x0a
    4e34:	eb 81       	ldd	r30, Y+3	; 0x03
    4e36:	fc 81       	ldd	r31, Y+4	; 0x04
    4e38:	80 81       	ld	r24, Z
    4e3a:	81 50       	subi	r24, 0x01	; 1
    4e3c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e3e:	fc 81       	ldd	r31, Y+4	; 0x04
    4e40:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    4e42:	ef 81       	ldd	r30, Y+7	; 0x07
    4e44:	f8 85       	ldd	r31, Y+8	; 0x08
    4e46:	96 89       	ldd	r25, Z+22	; 0x16
    4e48:	80 91 ac 06 	lds	r24, 0x06AC
    4e4c:	89 17       	cp	r24, r25
    4e4e:	28 f4       	brcc	.+10     	; 0x4e5a <xTaskGenericNotify+0x28c>
    4e50:	ef 81       	ldd	r30, Y+7	; 0x07
    4e52:	f8 85       	ldd	r31, Y+8	; 0x08
    4e54:	86 89       	ldd	r24, Z+22	; 0x16
    4e56:	80 93 ac 06 	sts	0x06AC, r24
    4e5a:	ef 81       	ldd	r30, Y+7	; 0x07
    4e5c:	f8 85       	ldd	r31, Y+8	; 0x08
    4e5e:	86 89       	ldd	r24, Z+22	; 0x16
    4e60:	28 2f       	mov	r18, r24
    4e62:	30 e0       	ldi	r19, 0x00	; 0
    4e64:	c9 01       	movw	r24, r18
    4e66:	88 0f       	add	r24, r24
    4e68:	99 1f       	adc	r25, r25
    4e6a:	88 0f       	add	r24, r24
    4e6c:	99 1f       	adc	r25, r25
    4e6e:	88 0f       	add	r24, r24
    4e70:	99 1f       	adc	r25, r25
    4e72:	82 0f       	add	r24, r18
    4e74:	93 1f       	adc	r25, r19
    4e76:	fc 01       	movw	r30, r24
    4e78:	e8 54       	subi	r30, 0x48	; 72
    4e7a:	f9 4f       	sbci	r31, 0xF9	; 249
    4e7c:	81 81       	ldd	r24, Z+1	; 0x01
    4e7e:	92 81       	ldd	r25, Z+2	; 0x02
    4e80:	9a 83       	std	Y+2, r25	; 0x02
    4e82:	89 83       	std	Y+1, r24	; 0x01
    4e84:	ef 81       	ldd	r30, Y+7	; 0x07
    4e86:	f8 85       	ldd	r31, Y+8	; 0x08
    4e88:	89 81       	ldd	r24, Y+1	; 0x01
    4e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e8c:	95 83       	std	Z+5, r25	; 0x05
    4e8e:	84 83       	std	Z+4, r24	; 0x04
    4e90:	e9 81       	ldd	r30, Y+1	; 0x01
    4e92:	fa 81       	ldd	r31, Y+2	; 0x02
    4e94:	84 81       	ldd	r24, Z+4	; 0x04
    4e96:	95 81       	ldd	r25, Z+5	; 0x05
    4e98:	ef 81       	ldd	r30, Y+7	; 0x07
    4e9a:	f8 85       	ldd	r31, Y+8	; 0x08
    4e9c:	97 83       	std	Z+7, r25	; 0x07
    4e9e:	86 83       	std	Z+6, r24	; 0x06
    4ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ea4:	04 80       	ldd	r0, Z+4	; 0x04
    4ea6:	f5 81       	ldd	r31, Z+5	; 0x05
    4ea8:	e0 2d       	mov	r30, r0
    4eaa:	8f 81       	ldd	r24, Y+7	; 0x07
    4eac:	98 85       	ldd	r25, Y+8	; 0x08
    4eae:	02 96       	adiw	r24, 0x02	; 2
    4eb0:	93 83       	std	Z+3, r25	; 0x03
    4eb2:	82 83       	std	Z+2, r24	; 0x02
    4eb4:	8f 81       	ldd	r24, Y+7	; 0x07
    4eb6:	98 85       	ldd	r25, Y+8	; 0x08
    4eb8:	02 96       	adiw	r24, 0x02	; 2
    4eba:	e9 81       	ldd	r30, Y+1	; 0x01
    4ebc:	fa 81       	ldd	r31, Y+2	; 0x02
    4ebe:	95 83       	std	Z+5, r25	; 0x05
    4ec0:	84 83       	std	Z+4, r24	; 0x04
    4ec2:	ef 81       	ldd	r30, Y+7	; 0x07
    4ec4:	f8 85       	ldd	r31, Y+8	; 0x08
    4ec6:	86 89       	ldd	r24, Z+22	; 0x16
    4ec8:	28 2f       	mov	r18, r24
    4eca:	30 e0       	ldi	r19, 0x00	; 0
    4ecc:	c9 01       	movw	r24, r18
    4ece:	88 0f       	add	r24, r24
    4ed0:	99 1f       	adc	r25, r25
    4ed2:	88 0f       	add	r24, r24
    4ed4:	99 1f       	adc	r25, r25
    4ed6:	88 0f       	add	r24, r24
    4ed8:	99 1f       	adc	r25, r25
    4eda:	82 0f       	add	r24, r18
    4edc:	93 1f       	adc	r25, r19
    4ede:	88 54       	subi	r24, 0x48	; 72
    4ee0:	99 4f       	sbci	r25, 0xF9	; 249
    4ee2:	ef 81       	ldd	r30, Y+7	; 0x07
    4ee4:	f8 85       	ldd	r31, Y+8	; 0x08
    4ee6:	93 87       	std	Z+11, r25	; 0x0b
    4ee8:	82 87       	std	Z+10, r24	; 0x0a
    4eea:	ef 81       	ldd	r30, Y+7	; 0x07
    4eec:	f8 85       	ldd	r31, Y+8	; 0x08
    4eee:	86 89       	ldd	r24, Z+22	; 0x16
    4ef0:	28 2f       	mov	r18, r24
    4ef2:	30 e0       	ldi	r19, 0x00	; 0
    4ef4:	c9 01       	movw	r24, r18
    4ef6:	88 0f       	add	r24, r24
    4ef8:	99 1f       	adc	r25, r25
    4efa:	88 0f       	add	r24, r24
    4efc:	99 1f       	adc	r25, r25
    4efe:	88 0f       	add	r24, r24
    4f00:	99 1f       	adc	r25, r25
    4f02:	82 0f       	add	r24, r18
    4f04:	93 1f       	adc	r25, r19
    4f06:	fc 01       	movw	r30, r24
    4f08:	e8 54       	subi	r30, 0x48	; 72
    4f0a:	f9 4f       	sbci	r31, 0xF9	; 249
    4f0c:	80 81       	ld	r24, Z
    4f0e:	8f 5f       	subi	r24, 0xFF	; 255
    4f10:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f12:	ef 81       	ldd	r30, Y+7	; 0x07
    4f14:	f8 85       	ldd	r31, Y+8	; 0x08
    4f16:	96 89       	ldd	r25, Z+22	; 0x16
    4f18:	e0 91 a6 06 	lds	r30, 0x06A6
    4f1c:	f0 91 a7 06 	lds	r31, 0x06A7
    4f20:	86 89       	ldd	r24, Z+22	; 0x16
    4f22:	89 17       	cp	r24, r25
    4f24:	10 f4       	brcc	.+4      	; 0x4f2a <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    4f26:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4f2a:	0f 90       	pop	r0
    4f2c:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4f2e:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    4f30:	64 96       	adiw	r28, 0x14	; 20
    4f32:	0f b6       	in	r0, 0x3f	; 63
    4f34:	f8 94       	cli
    4f36:	de bf       	out	0x3e, r29	; 62
    4f38:	0f be       	out	0x3f, r0	; 63
    4f3a:	cd bf       	out	0x3d, r28	; 61
    4f3c:	cf 91       	pop	r28
    4f3e:	df 91       	pop	r29
    4f40:	1f 91       	pop	r17
    4f42:	0f 91       	pop	r16
    4f44:	ff 90       	pop	r15
    4f46:	ef 90       	pop	r14
    4f48:	08 95       	ret

00004f4a <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    4f4a:	cf 92       	push	r12
    4f4c:	df 92       	push	r13
    4f4e:	ef 92       	push	r14
    4f50:	ff 92       	push	r15
    4f52:	0f 93       	push	r16
    4f54:	1f 93       	push	r17
    4f56:	df 93       	push	r29
    4f58:	cf 93       	push	r28
    4f5a:	cd b7       	in	r28, 0x3d	; 61
    4f5c:	de b7       	in	r29, 0x3e	; 62
    4f5e:	69 97       	sbiw	r28, 0x19	; 25
    4f60:	0f b6       	in	r0, 0x3f	; 63
    4f62:	f8 94       	cli
    4f64:	de bf       	out	0x3e, r29	; 62
    4f66:	0f be       	out	0x3f, r0	; 63
    4f68:	cd bf       	out	0x3d, r28	; 61
    4f6a:	9d 87       	std	Y+13, r25	; 0x0d
    4f6c:	8c 87       	std	Y+12, r24	; 0x0c
    4f6e:	6e 87       	std	Y+14, r22	; 0x0e
    4f70:	2f 87       	std	Y+15, r18	; 0x0f
    4f72:	38 8b       	std	Y+16, r19	; 0x10
    4f74:	49 8b       	std	Y+17, r20	; 0x11
    4f76:	5a 8b       	std	Y+18, r21	; 0x12
    4f78:	0b 8b       	std	Y+19, r16	; 0x13
    4f7a:	fd 8a       	std	Y+21, r15	; 0x15
    4f7c:	ec 8a       	std	Y+20, r14	; 0x14
    4f7e:	df 8a       	std	Y+23, r13	; 0x17
    4f80:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    4f82:	81 e0       	ldi	r24, 0x01	; 1
    4f84:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4f86:	8c 85       	ldd	r24, Y+12	; 0x0c
    4f88:	9d 85       	ldd	r25, Y+13	; 0x0d
    4f8a:	9b 87       	std	Y+11, r25	; 0x0b
    4f8c:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f8e:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    4f90:	8c 89       	ldd	r24, Y+20	; 0x14
    4f92:	9d 89       	ldd	r25, Y+21	; 0x15
    4f94:	00 97       	sbiw	r24, 0x00	; 0
    4f96:	b9 f0       	breq	.+46     	; 0x4fc6 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4f98:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f9a:	88 2f       	mov	r24, r24
    4f9c:	90 e0       	ldi	r25, 0x00	; 0
    4f9e:	2a 85       	ldd	r18, Y+10	; 0x0a
    4fa0:	3b 85       	ldd	r19, Y+11	; 0x0b
    4fa2:	88 0f       	add	r24, r24
    4fa4:	99 1f       	adc	r25, r25
    4fa6:	88 0f       	add	r24, r24
    4fa8:	99 1f       	adc	r25, r25
    4faa:	82 0f       	add	r24, r18
    4fac:	93 1f       	adc	r25, r19
    4fae:	fc 01       	movw	r30, r24
    4fb0:	b1 96       	adiw	r30, 0x21	; 33
    4fb2:	80 81       	ld	r24, Z
    4fb4:	91 81       	ldd	r25, Z+1	; 0x01
    4fb6:	a2 81       	ldd	r26, Z+2	; 0x02
    4fb8:	b3 81       	ldd	r27, Z+3	; 0x03
    4fba:	ec 89       	ldd	r30, Y+20	; 0x14
    4fbc:	fd 89       	ldd	r31, Y+21	; 0x15
    4fbe:	80 83       	st	Z, r24
    4fc0:	91 83       	std	Z+1, r25	; 0x01
    4fc2:	a2 83       	std	Z+2, r26	; 0x02
    4fc4:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4fc6:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fc8:	28 2f       	mov	r18, r24
    4fca:	30 e0       	ldi	r19, 0x00	; 0
    4fcc:	8a 85       	ldd	r24, Y+10	; 0x0a
    4fce:	9b 85       	ldd	r25, Y+11	; 0x0b
    4fd0:	82 0f       	add	r24, r18
    4fd2:	93 1f       	adc	r25, r19
    4fd4:	fc 01       	movw	r30, r24
    4fd6:	b5 96       	adiw	r30, 0x25	; 37
    4fd8:	80 81       	ld	r24, Z
    4fda:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4fdc:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fde:	28 2f       	mov	r18, r24
    4fe0:	30 e0       	ldi	r19, 0x00	; 0
    4fe2:	8a 85       	ldd	r24, Y+10	; 0x0a
    4fe4:	9b 85       	ldd	r25, Y+11	; 0x0b
    4fe6:	82 0f       	add	r24, r18
    4fe8:	93 1f       	adc	r25, r19
    4fea:	fc 01       	movw	r30, r24
    4fec:	b5 96       	adiw	r30, 0x25	; 37
    4fee:	82 e0       	ldi	r24, 0x02	; 2
    4ff0:	80 83       	st	Z, r24

            switch( eAction )
    4ff2:	8b 89       	ldd	r24, Y+19	; 0x13
    4ff4:	28 2f       	mov	r18, r24
    4ff6:	30 e0       	ldi	r19, 0x00	; 0
    4ff8:	39 8f       	std	Y+25, r19	; 0x19
    4ffa:	28 8f       	std	Y+24, r18	; 0x18
    4ffc:	88 8d       	ldd	r24, Y+24	; 0x18
    4ffe:	99 8d       	ldd	r25, Y+25	; 0x19
    5000:	82 30       	cpi	r24, 0x02	; 2
    5002:	91 05       	cpc	r25, r1
    5004:	09 f4       	brne	.+2      	; 0x5008 <xTaskGenericNotifyFromISR+0xbe>
    5006:	46 c0       	rjmp	.+140    	; 0x5094 <xTaskGenericNotifyFromISR+0x14a>
    5008:	28 8d       	ldd	r18, Y+24	; 0x18
    500a:	39 8d       	ldd	r19, Y+25	; 0x19
    500c:	23 30       	cpi	r18, 0x03	; 3
    500e:	31 05       	cpc	r19, r1
    5010:	34 f4       	brge	.+12     	; 0x501e <xTaskGenericNotifyFromISR+0xd4>
    5012:	88 8d       	ldd	r24, Y+24	; 0x18
    5014:	99 8d       	ldd	r25, Y+25	; 0x19
    5016:	81 30       	cpi	r24, 0x01	; 1
    5018:	91 05       	cpc	r25, r1
    501a:	71 f0       	breq	.+28     	; 0x5038 <xTaskGenericNotifyFromISR+0xee>
    501c:	93 c0       	rjmp	.+294    	; 0x5144 <xTaskGenericNotifyFromISR+0x1fa>
    501e:	28 8d       	ldd	r18, Y+24	; 0x18
    5020:	39 8d       	ldd	r19, Y+25	; 0x19
    5022:	23 30       	cpi	r18, 0x03	; 3
    5024:	31 05       	cpc	r19, r1
    5026:	09 f4       	brne	.+2      	; 0x502a <xTaskGenericNotifyFromISR+0xe0>
    5028:	5d c0       	rjmp	.+186    	; 0x50e4 <xTaskGenericNotifyFromISR+0x19a>
    502a:	88 8d       	ldd	r24, Y+24	; 0x18
    502c:	99 8d       	ldd	r25, Y+25	; 0x19
    502e:	84 30       	cpi	r24, 0x04	; 4
    5030:	91 05       	cpc	r25, r1
    5032:	09 f4       	brne	.+2      	; 0x5036 <xTaskGenericNotifyFromISR+0xec>
    5034:	6d c0       	rjmp	.+218    	; 0x5110 <xTaskGenericNotifyFromISR+0x1c6>
    5036:	86 c0       	rjmp	.+268    	; 0x5144 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    5038:	8e 85       	ldd	r24, Y+14	; 0x0e
    503a:	08 2f       	mov	r16, r24
    503c:	10 e0       	ldi	r17, 0x00	; 0
    503e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5040:	88 2f       	mov	r24, r24
    5042:	90 e0       	ldi	r25, 0x00	; 0
    5044:	2a 85       	ldd	r18, Y+10	; 0x0a
    5046:	3b 85       	ldd	r19, Y+11	; 0x0b
    5048:	88 0f       	add	r24, r24
    504a:	99 1f       	adc	r25, r25
    504c:	88 0f       	add	r24, r24
    504e:	99 1f       	adc	r25, r25
    5050:	82 0f       	add	r24, r18
    5052:	93 1f       	adc	r25, r19
    5054:	fc 01       	movw	r30, r24
    5056:	b1 96       	adiw	r30, 0x21	; 33
    5058:	20 81       	ld	r18, Z
    505a:	31 81       	ldd	r19, Z+1	; 0x01
    505c:	42 81       	ldd	r20, Z+2	; 0x02
    505e:	53 81       	ldd	r21, Z+3	; 0x03
    5060:	8f 85       	ldd	r24, Y+15	; 0x0f
    5062:	98 89       	ldd	r25, Y+16	; 0x10
    5064:	a9 89       	ldd	r26, Y+17	; 0x11
    5066:	ba 89       	ldd	r27, Y+18	; 0x12
    5068:	ba 01       	movw	r22, r20
    506a:	a9 01       	movw	r20, r18
    506c:	48 2b       	or	r20, r24
    506e:	59 2b       	or	r21, r25
    5070:	6a 2b       	or	r22, r26
    5072:	7b 2b       	or	r23, r27
    5074:	2a 85       	ldd	r18, Y+10	; 0x0a
    5076:	3b 85       	ldd	r19, Y+11	; 0x0b
    5078:	c8 01       	movw	r24, r16
    507a:	88 0f       	add	r24, r24
    507c:	99 1f       	adc	r25, r25
    507e:	88 0f       	add	r24, r24
    5080:	99 1f       	adc	r25, r25
    5082:	82 0f       	add	r24, r18
    5084:	93 1f       	adc	r25, r19
    5086:	fc 01       	movw	r30, r24
    5088:	b1 96       	adiw	r30, 0x21	; 33
    508a:	40 83       	st	Z, r20
    508c:	51 83       	std	Z+1, r21	; 0x01
    508e:	62 83       	std	Z+2, r22	; 0x02
    5090:	73 83       	std	Z+3, r23	; 0x03
    5092:	58 c0       	rjmp	.+176    	; 0x5144 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5094:	8e 85       	ldd	r24, Y+14	; 0x0e
    5096:	08 2f       	mov	r16, r24
    5098:	10 e0       	ldi	r17, 0x00	; 0
    509a:	2a 85       	ldd	r18, Y+10	; 0x0a
    509c:	3b 85       	ldd	r19, Y+11	; 0x0b
    509e:	c8 01       	movw	r24, r16
    50a0:	88 0f       	add	r24, r24
    50a2:	99 1f       	adc	r25, r25
    50a4:	88 0f       	add	r24, r24
    50a6:	99 1f       	adc	r25, r25
    50a8:	82 0f       	add	r24, r18
    50aa:	93 1f       	adc	r25, r19
    50ac:	fc 01       	movw	r30, r24
    50ae:	b1 96       	adiw	r30, 0x21	; 33
    50b0:	80 81       	ld	r24, Z
    50b2:	91 81       	ldd	r25, Z+1	; 0x01
    50b4:	a2 81       	ldd	r26, Z+2	; 0x02
    50b6:	b3 81       	ldd	r27, Z+3	; 0x03
    50b8:	ac 01       	movw	r20, r24
    50ba:	bd 01       	movw	r22, r26
    50bc:	4f 5f       	subi	r20, 0xFF	; 255
    50be:	5f 4f       	sbci	r21, 0xFF	; 255
    50c0:	6f 4f       	sbci	r22, 0xFF	; 255
    50c2:	7f 4f       	sbci	r23, 0xFF	; 255
    50c4:	2a 85       	ldd	r18, Y+10	; 0x0a
    50c6:	3b 85       	ldd	r19, Y+11	; 0x0b
    50c8:	c8 01       	movw	r24, r16
    50ca:	88 0f       	add	r24, r24
    50cc:	99 1f       	adc	r25, r25
    50ce:	88 0f       	add	r24, r24
    50d0:	99 1f       	adc	r25, r25
    50d2:	82 0f       	add	r24, r18
    50d4:	93 1f       	adc	r25, r19
    50d6:	fc 01       	movw	r30, r24
    50d8:	b1 96       	adiw	r30, 0x21	; 33
    50da:	40 83       	st	Z, r20
    50dc:	51 83       	std	Z+1, r21	; 0x01
    50de:	62 83       	std	Z+2, r22	; 0x02
    50e0:	73 83       	std	Z+3, r23	; 0x03
    50e2:	30 c0       	rjmp	.+96     	; 0x5144 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    50e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    50e6:	88 2f       	mov	r24, r24
    50e8:	90 e0       	ldi	r25, 0x00	; 0
    50ea:	2a 85       	ldd	r18, Y+10	; 0x0a
    50ec:	3b 85       	ldd	r19, Y+11	; 0x0b
    50ee:	88 0f       	add	r24, r24
    50f0:	99 1f       	adc	r25, r25
    50f2:	88 0f       	add	r24, r24
    50f4:	99 1f       	adc	r25, r25
    50f6:	82 0f       	add	r24, r18
    50f8:	93 1f       	adc	r25, r19
    50fa:	fc 01       	movw	r30, r24
    50fc:	b1 96       	adiw	r30, 0x21	; 33
    50fe:	8f 85       	ldd	r24, Y+15	; 0x0f
    5100:	98 89       	ldd	r25, Y+16	; 0x10
    5102:	a9 89       	ldd	r26, Y+17	; 0x11
    5104:	ba 89       	ldd	r27, Y+18	; 0x12
    5106:	80 83       	st	Z, r24
    5108:	91 83       	std	Z+1, r25	; 0x01
    510a:	a2 83       	std	Z+2, r26	; 0x02
    510c:	b3 83       	std	Z+3, r27	; 0x03
    510e:	1a c0       	rjmp	.+52     	; 0x5144 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5110:	89 85       	ldd	r24, Y+9	; 0x09
    5112:	82 30       	cpi	r24, 0x02	; 2
    5114:	b1 f0       	breq	.+44     	; 0x5142 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5116:	8e 85       	ldd	r24, Y+14	; 0x0e
    5118:	88 2f       	mov	r24, r24
    511a:	90 e0       	ldi	r25, 0x00	; 0
    511c:	2a 85       	ldd	r18, Y+10	; 0x0a
    511e:	3b 85       	ldd	r19, Y+11	; 0x0b
    5120:	88 0f       	add	r24, r24
    5122:	99 1f       	adc	r25, r25
    5124:	88 0f       	add	r24, r24
    5126:	99 1f       	adc	r25, r25
    5128:	82 0f       	add	r24, r18
    512a:	93 1f       	adc	r25, r19
    512c:	fc 01       	movw	r30, r24
    512e:	b1 96       	adiw	r30, 0x21	; 33
    5130:	8f 85       	ldd	r24, Y+15	; 0x0f
    5132:	98 89       	ldd	r25, Y+16	; 0x10
    5134:	a9 89       	ldd	r26, Y+17	; 0x11
    5136:	ba 89       	ldd	r27, Y+18	; 0x12
    5138:	80 83       	st	Z, r24
    513a:	91 83       	std	Z+1, r25	; 0x01
    513c:	a2 83       	std	Z+2, r26	; 0x02
    513e:	b3 83       	std	Z+3, r27	; 0x03
    5140:	01 c0       	rjmp	.+2      	; 0x5144 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    5142:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5144:	89 85       	ldd	r24, Y+9	; 0x09
    5146:	81 30       	cpi	r24, 0x01	; 1
    5148:	09 f0       	breq	.+2      	; 0x514c <xTaskGenericNotifyFromISR+0x202>
    514a:	ee c0       	rjmp	.+476    	; 0x5328 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    514c:	80 91 b7 06 	lds	r24, 0x06B7
    5150:	88 23       	and	r24, r24
    5152:	09 f0       	breq	.+2      	; 0x5156 <xTaskGenericNotifyFromISR+0x20c>
    5154:	a4 c0       	rjmp	.+328    	; 0x529e <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5156:	ea 85       	ldd	r30, Y+10	; 0x0a
    5158:	fb 85       	ldd	r31, Y+11	; 0x0b
    515a:	82 85       	ldd	r24, Z+10	; 0x0a
    515c:	93 85       	ldd	r25, Z+11	; 0x0b
    515e:	9e 83       	std	Y+6, r25	; 0x06
    5160:	8d 83       	std	Y+5, r24	; 0x05
    5162:	ea 85       	ldd	r30, Y+10	; 0x0a
    5164:	fb 85       	ldd	r31, Y+11	; 0x0b
    5166:	a4 81       	ldd	r26, Z+4	; 0x04
    5168:	b5 81       	ldd	r27, Z+5	; 0x05
    516a:	ea 85       	ldd	r30, Y+10	; 0x0a
    516c:	fb 85       	ldd	r31, Y+11	; 0x0b
    516e:	86 81       	ldd	r24, Z+6	; 0x06
    5170:	97 81       	ldd	r25, Z+7	; 0x07
    5172:	15 96       	adiw	r26, 0x05	; 5
    5174:	9c 93       	st	X, r25
    5176:	8e 93       	st	-X, r24
    5178:	14 97       	sbiw	r26, 0x04	; 4
    517a:	ea 85       	ldd	r30, Y+10	; 0x0a
    517c:	fb 85       	ldd	r31, Y+11	; 0x0b
    517e:	a6 81       	ldd	r26, Z+6	; 0x06
    5180:	b7 81       	ldd	r27, Z+7	; 0x07
    5182:	ea 85       	ldd	r30, Y+10	; 0x0a
    5184:	fb 85       	ldd	r31, Y+11	; 0x0b
    5186:	84 81       	ldd	r24, Z+4	; 0x04
    5188:	95 81       	ldd	r25, Z+5	; 0x05
    518a:	13 96       	adiw	r26, 0x03	; 3
    518c:	9c 93       	st	X, r25
    518e:	8e 93       	st	-X, r24
    5190:	12 97       	sbiw	r26, 0x02	; 2
    5192:	ed 81       	ldd	r30, Y+5	; 0x05
    5194:	fe 81       	ldd	r31, Y+6	; 0x06
    5196:	21 81       	ldd	r18, Z+1	; 0x01
    5198:	32 81       	ldd	r19, Z+2	; 0x02
    519a:	8a 85       	ldd	r24, Y+10	; 0x0a
    519c:	9b 85       	ldd	r25, Y+11	; 0x0b
    519e:	02 96       	adiw	r24, 0x02	; 2
    51a0:	28 17       	cp	r18, r24
    51a2:	39 07       	cpc	r19, r25
    51a4:	41 f4       	brne	.+16     	; 0x51b6 <xTaskGenericNotifyFromISR+0x26c>
    51a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    51a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    51aa:	86 81       	ldd	r24, Z+6	; 0x06
    51ac:	97 81       	ldd	r25, Z+7	; 0x07
    51ae:	ed 81       	ldd	r30, Y+5	; 0x05
    51b0:	fe 81       	ldd	r31, Y+6	; 0x06
    51b2:	92 83       	std	Z+2, r25	; 0x02
    51b4:	81 83       	std	Z+1, r24	; 0x01
    51b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    51b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    51ba:	13 86       	std	Z+11, r1	; 0x0b
    51bc:	12 86       	std	Z+10, r1	; 0x0a
    51be:	ed 81       	ldd	r30, Y+5	; 0x05
    51c0:	fe 81       	ldd	r31, Y+6	; 0x06
    51c2:	80 81       	ld	r24, Z
    51c4:	81 50       	subi	r24, 0x01	; 1
    51c6:	ed 81       	ldd	r30, Y+5	; 0x05
    51c8:	fe 81       	ldd	r31, Y+6	; 0x06
    51ca:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    51cc:	ea 85       	ldd	r30, Y+10	; 0x0a
    51ce:	fb 85       	ldd	r31, Y+11	; 0x0b
    51d0:	96 89       	ldd	r25, Z+22	; 0x16
    51d2:	80 91 ac 06 	lds	r24, 0x06AC
    51d6:	89 17       	cp	r24, r25
    51d8:	28 f4       	brcc	.+10     	; 0x51e4 <xTaskGenericNotifyFromISR+0x29a>
    51da:	ea 85       	ldd	r30, Y+10	; 0x0a
    51dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    51de:	86 89       	ldd	r24, Z+22	; 0x16
    51e0:	80 93 ac 06 	sts	0x06AC, r24
    51e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    51e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    51e8:	86 89       	ldd	r24, Z+22	; 0x16
    51ea:	28 2f       	mov	r18, r24
    51ec:	30 e0       	ldi	r19, 0x00	; 0
    51ee:	c9 01       	movw	r24, r18
    51f0:	88 0f       	add	r24, r24
    51f2:	99 1f       	adc	r25, r25
    51f4:	88 0f       	add	r24, r24
    51f6:	99 1f       	adc	r25, r25
    51f8:	88 0f       	add	r24, r24
    51fa:	99 1f       	adc	r25, r25
    51fc:	82 0f       	add	r24, r18
    51fe:	93 1f       	adc	r25, r19
    5200:	fc 01       	movw	r30, r24
    5202:	e8 54       	subi	r30, 0x48	; 72
    5204:	f9 4f       	sbci	r31, 0xF9	; 249
    5206:	81 81       	ldd	r24, Z+1	; 0x01
    5208:	92 81       	ldd	r25, Z+2	; 0x02
    520a:	9c 83       	std	Y+4, r25	; 0x04
    520c:	8b 83       	std	Y+3, r24	; 0x03
    520e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5210:	fb 85       	ldd	r31, Y+11	; 0x0b
    5212:	8b 81       	ldd	r24, Y+3	; 0x03
    5214:	9c 81       	ldd	r25, Y+4	; 0x04
    5216:	95 83       	std	Z+5, r25	; 0x05
    5218:	84 83       	std	Z+4, r24	; 0x04
    521a:	eb 81       	ldd	r30, Y+3	; 0x03
    521c:	fc 81       	ldd	r31, Y+4	; 0x04
    521e:	84 81       	ldd	r24, Z+4	; 0x04
    5220:	95 81       	ldd	r25, Z+5	; 0x05
    5222:	ea 85       	ldd	r30, Y+10	; 0x0a
    5224:	fb 85       	ldd	r31, Y+11	; 0x0b
    5226:	97 83       	std	Z+7, r25	; 0x07
    5228:	86 83       	std	Z+6, r24	; 0x06
    522a:	eb 81       	ldd	r30, Y+3	; 0x03
    522c:	fc 81       	ldd	r31, Y+4	; 0x04
    522e:	04 80       	ldd	r0, Z+4	; 0x04
    5230:	f5 81       	ldd	r31, Z+5	; 0x05
    5232:	e0 2d       	mov	r30, r0
    5234:	8a 85       	ldd	r24, Y+10	; 0x0a
    5236:	9b 85       	ldd	r25, Y+11	; 0x0b
    5238:	02 96       	adiw	r24, 0x02	; 2
    523a:	93 83       	std	Z+3, r25	; 0x03
    523c:	82 83       	std	Z+2, r24	; 0x02
    523e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5240:	9b 85       	ldd	r25, Y+11	; 0x0b
    5242:	02 96       	adiw	r24, 0x02	; 2
    5244:	eb 81       	ldd	r30, Y+3	; 0x03
    5246:	fc 81       	ldd	r31, Y+4	; 0x04
    5248:	95 83       	std	Z+5, r25	; 0x05
    524a:	84 83       	std	Z+4, r24	; 0x04
    524c:	ea 85       	ldd	r30, Y+10	; 0x0a
    524e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5250:	86 89       	ldd	r24, Z+22	; 0x16
    5252:	28 2f       	mov	r18, r24
    5254:	30 e0       	ldi	r19, 0x00	; 0
    5256:	c9 01       	movw	r24, r18
    5258:	88 0f       	add	r24, r24
    525a:	99 1f       	adc	r25, r25
    525c:	88 0f       	add	r24, r24
    525e:	99 1f       	adc	r25, r25
    5260:	88 0f       	add	r24, r24
    5262:	99 1f       	adc	r25, r25
    5264:	82 0f       	add	r24, r18
    5266:	93 1f       	adc	r25, r19
    5268:	88 54       	subi	r24, 0x48	; 72
    526a:	99 4f       	sbci	r25, 0xF9	; 249
    526c:	ea 85       	ldd	r30, Y+10	; 0x0a
    526e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5270:	93 87       	std	Z+11, r25	; 0x0b
    5272:	82 87       	std	Z+10, r24	; 0x0a
    5274:	ea 85       	ldd	r30, Y+10	; 0x0a
    5276:	fb 85       	ldd	r31, Y+11	; 0x0b
    5278:	86 89       	ldd	r24, Z+22	; 0x16
    527a:	28 2f       	mov	r18, r24
    527c:	30 e0       	ldi	r19, 0x00	; 0
    527e:	c9 01       	movw	r24, r18
    5280:	88 0f       	add	r24, r24
    5282:	99 1f       	adc	r25, r25
    5284:	88 0f       	add	r24, r24
    5286:	99 1f       	adc	r25, r25
    5288:	88 0f       	add	r24, r24
    528a:	99 1f       	adc	r25, r25
    528c:	82 0f       	add	r24, r18
    528e:	93 1f       	adc	r25, r19
    5290:	fc 01       	movw	r30, r24
    5292:	e8 54       	subi	r30, 0x48	; 72
    5294:	f9 4f       	sbci	r31, 0xF9	; 249
    5296:	80 81       	ld	r24, Z
    5298:	8f 5f       	subi	r24, 0xFF	; 255
    529a:	80 83       	st	Z, r24
    529c:	30 c0       	rjmp	.+96     	; 0x52fe <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    529e:	80 91 f3 06 	lds	r24, 0x06F3
    52a2:	90 91 f4 06 	lds	r25, 0x06F4
    52a6:	9a 83       	std	Y+2, r25	; 0x02
    52a8:	89 83       	std	Y+1, r24	; 0x01
    52aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    52ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    52ae:	89 81       	ldd	r24, Y+1	; 0x01
    52b0:	9a 81       	ldd	r25, Y+2	; 0x02
    52b2:	97 87       	std	Z+15, r25	; 0x0f
    52b4:	86 87       	std	Z+14, r24	; 0x0e
    52b6:	e9 81       	ldd	r30, Y+1	; 0x01
    52b8:	fa 81       	ldd	r31, Y+2	; 0x02
    52ba:	84 81       	ldd	r24, Z+4	; 0x04
    52bc:	95 81       	ldd	r25, Z+5	; 0x05
    52be:	ea 85       	ldd	r30, Y+10	; 0x0a
    52c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    52c2:	91 8b       	std	Z+17, r25	; 0x11
    52c4:	80 8b       	std	Z+16, r24	; 0x10
    52c6:	e9 81       	ldd	r30, Y+1	; 0x01
    52c8:	fa 81       	ldd	r31, Y+2	; 0x02
    52ca:	04 80       	ldd	r0, Z+4	; 0x04
    52cc:	f5 81       	ldd	r31, Z+5	; 0x05
    52ce:	e0 2d       	mov	r30, r0
    52d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    52d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    52d4:	0c 96       	adiw	r24, 0x0c	; 12
    52d6:	93 83       	std	Z+3, r25	; 0x03
    52d8:	82 83       	std	Z+2, r24	; 0x02
    52da:	8a 85       	ldd	r24, Y+10	; 0x0a
    52dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    52de:	0c 96       	adiw	r24, 0x0c	; 12
    52e0:	e9 81       	ldd	r30, Y+1	; 0x01
    52e2:	fa 81       	ldd	r31, Y+2	; 0x02
    52e4:	95 83       	std	Z+5, r25	; 0x05
    52e6:	84 83       	std	Z+4, r24	; 0x04
    52e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    52ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    52ec:	82 ef       	ldi	r24, 0xF2	; 242
    52ee:	96 e0       	ldi	r25, 0x06	; 6
    52f0:	95 8b       	std	Z+21, r25	; 0x15
    52f2:	84 8b       	std	Z+20, r24	; 0x14
    52f4:	80 91 f2 06 	lds	r24, 0x06F2
    52f8:	8f 5f       	subi	r24, 0xFF	; 255
    52fa:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    52fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    5300:	fb 85       	ldd	r31, Y+11	; 0x0b
    5302:	96 89       	ldd	r25, Z+22	; 0x16
    5304:	e0 91 a6 06 	lds	r30, 0x06A6
    5308:	f0 91 a7 06 	lds	r31, 0x06A7
    530c:	86 89       	ldd	r24, Z+22	; 0x16
    530e:	89 17       	cp	r24, r25
    5310:	58 f4       	brcc	.+22     	; 0x5328 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5312:	8e 89       	ldd	r24, Y+22	; 0x16
    5314:	9f 89       	ldd	r25, Y+23	; 0x17
    5316:	00 97       	sbiw	r24, 0x00	; 0
    5318:	21 f0       	breq	.+8      	; 0x5322 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    531a:	ee 89       	ldd	r30, Y+22	; 0x16
    531c:	ff 89       	ldd	r31, Y+23	; 0x17
    531e:	81 e0       	ldi	r24, 0x01	; 1
    5320:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5322:	81 e0       	ldi	r24, 0x01	; 1
    5324:	80 93 b0 06 	sts	0x06B0, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    5328:	88 85       	ldd	r24, Y+8	; 0x08
    }
    532a:	69 96       	adiw	r28, 0x19	; 25
    532c:	0f b6       	in	r0, 0x3f	; 63
    532e:	f8 94       	cli
    5330:	de bf       	out	0x3e, r29	; 62
    5332:	0f be       	out	0x3f, r0	; 63
    5334:	cd bf       	out	0x3d, r28	; 61
    5336:	cf 91       	pop	r28
    5338:	df 91       	pop	r29
    533a:	1f 91       	pop	r17
    533c:	0f 91       	pop	r16
    533e:	ff 90       	pop	r15
    5340:	ef 90       	pop	r14
    5342:	df 90       	pop	r13
    5344:	cf 90       	pop	r12
    5346:	08 95       	ret

00005348 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    5348:	0f 93       	push	r16
    534a:	1f 93       	push	r17
    534c:	df 93       	push	r29
    534e:	cf 93       	push	r28
    5350:	cd b7       	in	r28, 0x3d	; 61
    5352:	de b7       	in	r29, 0x3e	; 62
    5354:	2f 97       	sbiw	r28, 0x0f	; 15
    5356:	0f b6       	in	r0, 0x3f	; 63
    5358:	f8 94       	cli
    535a:	de bf       	out	0x3e, r29	; 62
    535c:	0f be       	out	0x3f, r0	; 63
    535e:	cd bf       	out	0x3d, r28	; 61
    5360:	9c 87       	std	Y+12, r25	; 0x0c
    5362:	8b 87       	std	Y+11, r24	; 0x0b
    5364:	6d 87       	std	Y+13, r22	; 0x0d
    5366:	5f 87       	std	Y+15, r21	; 0x0f
    5368:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    536a:	8b 85       	ldd	r24, Y+11	; 0x0b
    536c:	9c 85       	ldd	r25, Y+12	; 0x0c
    536e:	9a 87       	std	Y+10, r25	; 0x0a
    5370:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5372:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5374:	8d 85       	ldd	r24, Y+13	; 0x0d
    5376:	28 2f       	mov	r18, r24
    5378:	30 e0       	ldi	r19, 0x00	; 0
    537a:	89 85       	ldd	r24, Y+9	; 0x09
    537c:	9a 85       	ldd	r25, Y+10	; 0x0a
    537e:	82 0f       	add	r24, r18
    5380:	93 1f       	adc	r25, r19
    5382:	fc 01       	movw	r30, r24
    5384:	b5 96       	adiw	r30, 0x25	; 37
    5386:	80 81       	ld	r24, Z
    5388:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    538a:	8d 85       	ldd	r24, Y+13	; 0x0d
    538c:	28 2f       	mov	r18, r24
    538e:	30 e0       	ldi	r19, 0x00	; 0
    5390:	89 85       	ldd	r24, Y+9	; 0x09
    5392:	9a 85       	ldd	r25, Y+10	; 0x0a
    5394:	82 0f       	add	r24, r18
    5396:	93 1f       	adc	r25, r19
    5398:	fc 01       	movw	r30, r24
    539a:	b5 96       	adiw	r30, 0x25	; 37
    539c:	82 e0       	ldi	r24, 0x02	; 2
    539e:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    53a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    53a2:	08 2f       	mov	r16, r24
    53a4:	10 e0       	ldi	r17, 0x00	; 0
    53a6:	29 85       	ldd	r18, Y+9	; 0x09
    53a8:	3a 85       	ldd	r19, Y+10	; 0x0a
    53aa:	c8 01       	movw	r24, r16
    53ac:	88 0f       	add	r24, r24
    53ae:	99 1f       	adc	r25, r25
    53b0:	88 0f       	add	r24, r24
    53b2:	99 1f       	adc	r25, r25
    53b4:	82 0f       	add	r24, r18
    53b6:	93 1f       	adc	r25, r19
    53b8:	fc 01       	movw	r30, r24
    53ba:	b1 96       	adiw	r30, 0x21	; 33
    53bc:	80 81       	ld	r24, Z
    53be:	91 81       	ldd	r25, Z+1	; 0x01
    53c0:	a2 81       	ldd	r26, Z+2	; 0x02
    53c2:	b3 81       	ldd	r27, Z+3	; 0x03
    53c4:	ac 01       	movw	r20, r24
    53c6:	bd 01       	movw	r22, r26
    53c8:	4f 5f       	subi	r20, 0xFF	; 255
    53ca:	5f 4f       	sbci	r21, 0xFF	; 255
    53cc:	6f 4f       	sbci	r22, 0xFF	; 255
    53ce:	7f 4f       	sbci	r23, 0xFF	; 255
    53d0:	29 85       	ldd	r18, Y+9	; 0x09
    53d2:	3a 85       	ldd	r19, Y+10	; 0x0a
    53d4:	c8 01       	movw	r24, r16
    53d6:	88 0f       	add	r24, r24
    53d8:	99 1f       	adc	r25, r25
    53da:	88 0f       	add	r24, r24
    53dc:	99 1f       	adc	r25, r25
    53de:	82 0f       	add	r24, r18
    53e0:	93 1f       	adc	r25, r19
    53e2:	fc 01       	movw	r30, r24
    53e4:	b1 96       	adiw	r30, 0x21	; 33
    53e6:	40 83       	st	Z, r20
    53e8:	51 83       	std	Z+1, r21	; 0x01
    53ea:	62 83       	std	Z+2, r22	; 0x02
    53ec:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    53ee:	88 85       	ldd	r24, Y+8	; 0x08
    53f0:	81 30       	cpi	r24, 0x01	; 1
    53f2:	09 f0       	breq	.+2      	; 0x53f6 <vTaskGenericNotifyGiveFromISR+0xae>
    53f4:	ee c0       	rjmp	.+476    	; 0x55d2 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    53f6:	80 91 b7 06 	lds	r24, 0x06B7
    53fa:	88 23       	and	r24, r24
    53fc:	09 f0       	breq	.+2      	; 0x5400 <vTaskGenericNotifyGiveFromISR+0xb8>
    53fe:	a4 c0       	rjmp	.+328    	; 0x5548 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5400:	e9 85       	ldd	r30, Y+9	; 0x09
    5402:	fa 85       	ldd	r31, Y+10	; 0x0a
    5404:	82 85       	ldd	r24, Z+10	; 0x0a
    5406:	93 85       	ldd	r25, Z+11	; 0x0b
    5408:	9e 83       	std	Y+6, r25	; 0x06
    540a:	8d 83       	std	Y+5, r24	; 0x05
    540c:	e9 85       	ldd	r30, Y+9	; 0x09
    540e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5410:	a4 81       	ldd	r26, Z+4	; 0x04
    5412:	b5 81       	ldd	r27, Z+5	; 0x05
    5414:	e9 85       	ldd	r30, Y+9	; 0x09
    5416:	fa 85       	ldd	r31, Y+10	; 0x0a
    5418:	86 81       	ldd	r24, Z+6	; 0x06
    541a:	97 81       	ldd	r25, Z+7	; 0x07
    541c:	15 96       	adiw	r26, 0x05	; 5
    541e:	9c 93       	st	X, r25
    5420:	8e 93       	st	-X, r24
    5422:	14 97       	sbiw	r26, 0x04	; 4
    5424:	e9 85       	ldd	r30, Y+9	; 0x09
    5426:	fa 85       	ldd	r31, Y+10	; 0x0a
    5428:	a6 81       	ldd	r26, Z+6	; 0x06
    542a:	b7 81       	ldd	r27, Z+7	; 0x07
    542c:	e9 85       	ldd	r30, Y+9	; 0x09
    542e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5430:	84 81       	ldd	r24, Z+4	; 0x04
    5432:	95 81       	ldd	r25, Z+5	; 0x05
    5434:	13 96       	adiw	r26, 0x03	; 3
    5436:	9c 93       	st	X, r25
    5438:	8e 93       	st	-X, r24
    543a:	12 97       	sbiw	r26, 0x02	; 2
    543c:	ed 81       	ldd	r30, Y+5	; 0x05
    543e:	fe 81       	ldd	r31, Y+6	; 0x06
    5440:	21 81       	ldd	r18, Z+1	; 0x01
    5442:	32 81       	ldd	r19, Z+2	; 0x02
    5444:	89 85       	ldd	r24, Y+9	; 0x09
    5446:	9a 85       	ldd	r25, Y+10	; 0x0a
    5448:	02 96       	adiw	r24, 0x02	; 2
    544a:	28 17       	cp	r18, r24
    544c:	39 07       	cpc	r19, r25
    544e:	41 f4       	brne	.+16     	; 0x5460 <vTaskGenericNotifyGiveFromISR+0x118>
    5450:	e9 85       	ldd	r30, Y+9	; 0x09
    5452:	fa 85       	ldd	r31, Y+10	; 0x0a
    5454:	86 81       	ldd	r24, Z+6	; 0x06
    5456:	97 81       	ldd	r25, Z+7	; 0x07
    5458:	ed 81       	ldd	r30, Y+5	; 0x05
    545a:	fe 81       	ldd	r31, Y+6	; 0x06
    545c:	92 83       	std	Z+2, r25	; 0x02
    545e:	81 83       	std	Z+1, r24	; 0x01
    5460:	e9 85       	ldd	r30, Y+9	; 0x09
    5462:	fa 85       	ldd	r31, Y+10	; 0x0a
    5464:	13 86       	std	Z+11, r1	; 0x0b
    5466:	12 86       	std	Z+10, r1	; 0x0a
    5468:	ed 81       	ldd	r30, Y+5	; 0x05
    546a:	fe 81       	ldd	r31, Y+6	; 0x06
    546c:	80 81       	ld	r24, Z
    546e:	81 50       	subi	r24, 0x01	; 1
    5470:	ed 81       	ldd	r30, Y+5	; 0x05
    5472:	fe 81       	ldd	r31, Y+6	; 0x06
    5474:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5476:	e9 85       	ldd	r30, Y+9	; 0x09
    5478:	fa 85       	ldd	r31, Y+10	; 0x0a
    547a:	96 89       	ldd	r25, Z+22	; 0x16
    547c:	80 91 ac 06 	lds	r24, 0x06AC
    5480:	89 17       	cp	r24, r25
    5482:	28 f4       	brcc	.+10     	; 0x548e <vTaskGenericNotifyGiveFromISR+0x146>
    5484:	e9 85       	ldd	r30, Y+9	; 0x09
    5486:	fa 85       	ldd	r31, Y+10	; 0x0a
    5488:	86 89       	ldd	r24, Z+22	; 0x16
    548a:	80 93 ac 06 	sts	0x06AC, r24
    548e:	e9 85       	ldd	r30, Y+9	; 0x09
    5490:	fa 85       	ldd	r31, Y+10	; 0x0a
    5492:	86 89       	ldd	r24, Z+22	; 0x16
    5494:	28 2f       	mov	r18, r24
    5496:	30 e0       	ldi	r19, 0x00	; 0
    5498:	c9 01       	movw	r24, r18
    549a:	88 0f       	add	r24, r24
    549c:	99 1f       	adc	r25, r25
    549e:	88 0f       	add	r24, r24
    54a0:	99 1f       	adc	r25, r25
    54a2:	88 0f       	add	r24, r24
    54a4:	99 1f       	adc	r25, r25
    54a6:	82 0f       	add	r24, r18
    54a8:	93 1f       	adc	r25, r19
    54aa:	fc 01       	movw	r30, r24
    54ac:	e8 54       	subi	r30, 0x48	; 72
    54ae:	f9 4f       	sbci	r31, 0xF9	; 249
    54b0:	81 81       	ldd	r24, Z+1	; 0x01
    54b2:	92 81       	ldd	r25, Z+2	; 0x02
    54b4:	9c 83       	std	Y+4, r25	; 0x04
    54b6:	8b 83       	std	Y+3, r24	; 0x03
    54b8:	e9 85       	ldd	r30, Y+9	; 0x09
    54ba:	fa 85       	ldd	r31, Y+10	; 0x0a
    54bc:	8b 81       	ldd	r24, Y+3	; 0x03
    54be:	9c 81       	ldd	r25, Y+4	; 0x04
    54c0:	95 83       	std	Z+5, r25	; 0x05
    54c2:	84 83       	std	Z+4, r24	; 0x04
    54c4:	eb 81       	ldd	r30, Y+3	; 0x03
    54c6:	fc 81       	ldd	r31, Y+4	; 0x04
    54c8:	84 81       	ldd	r24, Z+4	; 0x04
    54ca:	95 81       	ldd	r25, Z+5	; 0x05
    54cc:	e9 85       	ldd	r30, Y+9	; 0x09
    54ce:	fa 85       	ldd	r31, Y+10	; 0x0a
    54d0:	97 83       	std	Z+7, r25	; 0x07
    54d2:	86 83       	std	Z+6, r24	; 0x06
    54d4:	eb 81       	ldd	r30, Y+3	; 0x03
    54d6:	fc 81       	ldd	r31, Y+4	; 0x04
    54d8:	04 80       	ldd	r0, Z+4	; 0x04
    54da:	f5 81       	ldd	r31, Z+5	; 0x05
    54dc:	e0 2d       	mov	r30, r0
    54de:	89 85       	ldd	r24, Y+9	; 0x09
    54e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    54e2:	02 96       	adiw	r24, 0x02	; 2
    54e4:	93 83       	std	Z+3, r25	; 0x03
    54e6:	82 83       	std	Z+2, r24	; 0x02
    54e8:	89 85       	ldd	r24, Y+9	; 0x09
    54ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    54ec:	02 96       	adiw	r24, 0x02	; 2
    54ee:	eb 81       	ldd	r30, Y+3	; 0x03
    54f0:	fc 81       	ldd	r31, Y+4	; 0x04
    54f2:	95 83       	std	Z+5, r25	; 0x05
    54f4:	84 83       	std	Z+4, r24	; 0x04
    54f6:	e9 85       	ldd	r30, Y+9	; 0x09
    54f8:	fa 85       	ldd	r31, Y+10	; 0x0a
    54fa:	86 89       	ldd	r24, Z+22	; 0x16
    54fc:	28 2f       	mov	r18, r24
    54fe:	30 e0       	ldi	r19, 0x00	; 0
    5500:	c9 01       	movw	r24, r18
    5502:	88 0f       	add	r24, r24
    5504:	99 1f       	adc	r25, r25
    5506:	88 0f       	add	r24, r24
    5508:	99 1f       	adc	r25, r25
    550a:	88 0f       	add	r24, r24
    550c:	99 1f       	adc	r25, r25
    550e:	82 0f       	add	r24, r18
    5510:	93 1f       	adc	r25, r19
    5512:	88 54       	subi	r24, 0x48	; 72
    5514:	99 4f       	sbci	r25, 0xF9	; 249
    5516:	e9 85       	ldd	r30, Y+9	; 0x09
    5518:	fa 85       	ldd	r31, Y+10	; 0x0a
    551a:	93 87       	std	Z+11, r25	; 0x0b
    551c:	82 87       	std	Z+10, r24	; 0x0a
    551e:	e9 85       	ldd	r30, Y+9	; 0x09
    5520:	fa 85       	ldd	r31, Y+10	; 0x0a
    5522:	86 89       	ldd	r24, Z+22	; 0x16
    5524:	28 2f       	mov	r18, r24
    5526:	30 e0       	ldi	r19, 0x00	; 0
    5528:	c9 01       	movw	r24, r18
    552a:	88 0f       	add	r24, r24
    552c:	99 1f       	adc	r25, r25
    552e:	88 0f       	add	r24, r24
    5530:	99 1f       	adc	r25, r25
    5532:	88 0f       	add	r24, r24
    5534:	99 1f       	adc	r25, r25
    5536:	82 0f       	add	r24, r18
    5538:	93 1f       	adc	r25, r19
    553a:	fc 01       	movw	r30, r24
    553c:	e8 54       	subi	r30, 0x48	; 72
    553e:	f9 4f       	sbci	r31, 0xF9	; 249
    5540:	80 81       	ld	r24, Z
    5542:	8f 5f       	subi	r24, 0xFF	; 255
    5544:	80 83       	st	Z, r24
    5546:	30 c0       	rjmp	.+96     	; 0x55a8 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5548:	80 91 f3 06 	lds	r24, 0x06F3
    554c:	90 91 f4 06 	lds	r25, 0x06F4
    5550:	9a 83       	std	Y+2, r25	; 0x02
    5552:	89 83       	std	Y+1, r24	; 0x01
    5554:	e9 85       	ldd	r30, Y+9	; 0x09
    5556:	fa 85       	ldd	r31, Y+10	; 0x0a
    5558:	89 81       	ldd	r24, Y+1	; 0x01
    555a:	9a 81       	ldd	r25, Y+2	; 0x02
    555c:	97 87       	std	Z+15, r25	; 0x0f
    555e:	86 87       	std	Z+14, r24	; 0x0e
    5560:	e9 81       	ldd	r30, Y+1	; 0x01
    5562:	fa 81       	ldd	r31, Y+2	; 0x02
    5564:	84 81       	ldd	r24, Z+4	; 0x04
    5566:	95 81       	ldd	r25, Z+5	; 0x05
    5568:	e9 85       	ldd	r30, Y+9	; 0x09
    556a:	fa 85       	ldd	r31, Y+10	; 0x0a
    556c:	91 8b       	std	Z+17, r25	; 0x11
    556e:	80 8b       	std	Z+16, r24	; 0x10
    5570:	e9 81       	ldd	r30, Y+1	; 0x01
    5572:	fa 81       	ldd	r31, Y+2	; 0x02
    5574:	04 80       	ldd	r0, Z+4	; 0x04
    5576:	f5 81       	ldd	r31, Z+5	; 0x05
    5578:	e0 2d       	mov	r30, r0
    557a:	89 85       	ldd	r24, Y+9	; 0x09
    557c:	9a 85       	ldd	r25, Y+10	; 0x0a
    557e:	0c 96       	adiw	r24, 0x0c	; 12
    5580:	93 83       	std	Z+3, r25	; 0x03
    5582:	82 83       	std	Z+2, r24	; 0x02
    5584:	89 85       	ldd	r24, Y+9	; 0x09
    5586:	9a 85       	ldd	r25, Y+10	; 0x0a
    5588:	0c 96       	adiw	r24, 0x0c	; 12
    558a:	e9 81       	ldd	r30, Y+1	; 0x01
    558c:	fa 81       	ldd	r31, Y+2	; 0x02
    558e:	95 83       	std	Z+5, r25	; 0x05
    5590:	84 83       	std	Z+4, r24	; 0x04
    5592:	e9 85       	ldd	r30, Y+9	; 0x09
    5594:	fa 85       	ldd	r31, Y+10	; 0x0a
    5596:	82 ef       	ldi	r24, 0xF2	; 242
    5598:	96 e0       	ldi	r25, 0x06	; 6
    559a:	95 8b       	std	Z+21, r25	; 0x15
    559c:	84 8b       	std	Z+20, r24	; 0x14
    559e:	80 91 f2 06 	lds	r24, 0x06F2
    55a2:	8f 5f       	subi	r24, 0xFF	; 255
    55a4:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    55a8:	e9 85       	ldd	r30, Y+9	; 0x09
    55aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    55ac:	96 89       	ldd	r25, Z+22	; 0x16
    55ae:	e0 91 a6 06 	lds	r30, 0x06A6
    55b2:	f0 91 a7 06 	lds	r31, 0x06A7
    55b6:	86 89       	ldd	r24, Z+22	; 0x16
    55b8:	89 17       	cp	r24, r25
    55ba:	58 f4       	brcc	.+22     	; 0x55d2 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    55bc:	8e 85       	ldd	r24, Y+14	; 0x0e
    55be:	9f 85       	ldd	r25, Y+15	; 0x0f
    55c0:	00 97       	sbiw	r24, 0x00	; 0
    55c2:	21 f0       	breq	.+8      	; 0x55cc <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    55c4:	ee 85       	ldd	r30, Y+14	; 0x0e
    55c6:	ff 85       	ldd	r31, Y+15	; 0x0f
    55c8:	81 e0       	ldi	r24, 0x01	; 1
    55ca:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    55cc:	81 e0       	ldi	r24, 0x01	; 1
    55ce:	80 93 b0 06 	sts	0x06B0, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    55d2:	2f 96       	adiw	r28, 0x0f	; 15
    55d4:	0f b6       	in	r0, 0x3f	; 63
    55d6:	f8 94       	cli
    55d8:	de bf       	out	0x3e, r29	; 62
    55da:	0f be       	out	0x3f, r0	; 63
    55dc:	cd bf       	out	0x3d, r28	; 61
    55de:	cf 91       	pop	r28
    55e0:	df 91       	pop	r29
    55e2:	1f 91       	pop	r17
    55e4:	0f 91       	pop	r16
    55e6:	08 95       	ret

000055e8 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    55e8:	df 93       	push	r29
    55ea:	cf 93       	push	r28
    55ec:	cd b7       	in	r28, 0x3d	; 61
    55ee:	de b7       	in	r29, 0x3e	; 62
    55f0:	28 97       	sbiw	r28, 0x08	; 8
    55f2:	0f b6       	in	r0, 0x3f	; 63
    55f4:	f8 94       	cli
    55f6:	de bf       	out	0x3e, r29	; 62
    55f8:	0f be       	out	0x3f, r0	; 63
    55fa:	cd bf       	out	0x3d, r28	; 61
    55fc:	9d 83       	std	Y+5, r25	; 0x05
    55fe:	8c 83       	std	Y+4, r24	; 0x04
    5600:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5602:	8c 81       	ldd	r24, Y+4	; 0x04
    5604:	9d 81       	ldd	r25, Y+5	; 0x05
    5606:	00 97       	sbiw	r24, 0x00	; 0
    5608:	39 f4       	brne	.+14     	; 0x5618 <xTaskGenericNotifyStateClear+0x30>
    560a:	80 91 a6 06 	lds	r24, 0x06A6
    560e:	90 91 a7 06 	lds	r25, 0x06A7
    5612:	98 87       	std	Y+8, r25	; 0x08
    5614:	8f 83       	std	Y+7, r24	; 0x07
    5616:	04 c0       	rjmp	.+8      	; 0x5620 <xTaskGenericNotifyStateClear+0x38>
    5618:	8c 81       	ldd	r24, Y+4	; 0x04
    561a:	9d 81       	ldd	r25, Y+5	; 0x05
    561c:	98 87       	std	Y+8, r25	; 0x08
    561e:	8f 83       	std	Y+7, r24	; 0x07
    5620:	8f 81       	ldd	r24, Y+7	; 0x07
    5622:	98 85       	ldd	r25, Y+8	; 0x08
    5624:	9b 83       	std	Y+3, r25	; 0x03
    5626:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5628:	0f b6       	in	r0, 0x3f	; 63
    562a:	f8 94       	cli
    562c:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    562e:	8e 81       	ldd	r24, Y+6	; 0x06
    5630:	28 2f       	mov	r18, r24
    5632:	30 e0       	ldi	r19, 0x00	; 0
    5634:	8a 81       	ldd	r24, Y+2	; 0x02
    5636:	9b 81       	ldd	r25, Y+3	; 0x03
    5638:	82 0f       	add	r24, r18
    563a:	93 1f       	adc	r25, r19
    563c:	fc 01       	movw	r30, r24
    563e:	b5 96       	adiw	r30, 0x25	; 37
    5640:	80 81       	ld	r24, Z
    5642:	82 30       	cpi	r24, 0x02	; 2
    5644:	69 f4       	brne	.+26     	; 0x5660 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5646:	8e 81       	ldd	r24, Y+6	; 0x06
    5648:	28 2f       	mov	r18, r24
    564a:	30 e0       	ldi	r19, 0x00	; 0
    564c:	8a 81       	ldd	r24, Y+2	; 0x02
    564e:	9b 81       	ldd	r25, Y+3	; 0x03
    5650:	82 0f       	add	r24, r18
    5652:	93 1f       	adc	r25, r19
    5654:	fc 01       	movw	r30, r24
    5656:	b5 96       	adiw	r30, 0x25	; 37
    5658:	10 82       	st	Z, r1
                xReturn = pdPASS;
    565a:	81 e0       	ldi	r24, 0x01	; 1
    565c:	89 83       	std	Y+1, r24	; 0x01
    565e:	01 c0       	rjmp	.+2      	; 0x5662 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    5660:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5662:	0f 90       	pop	r0
    5664:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5666:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5668:	28 96       	adiw	r28, 0x08	; 8
    566a:	0f b6       	in	r0, 0x3f	; 63
    566c:	f8 94       	cli
    566e:	de bf       	out	0x3e, r29	; 62
    5670:	0f be       	out	0x3f, r0	; 63
    5672:	cd bf       	out	0x3d, r28	; 61
    5674:	cf 91       	pop	r28
    5676:	df 91       	pop	r29
    5678:	08 95       	ret

0000567a <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    567a:	0f 93       	push	r16
    567c:	1f 93       	push	r17
    567e:	df 93       	push	r29
    5680:	cf 93       	push	r28
    5682:	cd b7       	in	r28, 0x3d	; 61
    5684:	de b7       	in	r29, 0x3e	; 62
    5686:	2f 97       	sbiw	r28, 0x0f	; 15
    5688:	0f b6       	in	r0, 0x3f	; 63
    568a:	f8 94       	cli
    568c:	de bf       	out	0x3e, r29	; 62
    568e:	0f be       	out	0x3f, r0	; 63
    5690:	cd bf       	out	0x3d, r28	; 61
    5692:	98 87       	std	Y+8, r25	; 0x08
    5694:	8f 83       	std	Y+7, r24	; 0x07
    5696:	69 87       	std	Y+9, r22	; 0x09
    5698:	2a 87       	std	Y+10, r18	; 0x0a
    569a:	3b 87       	std	Y+11, r19	; 0x0b
    569c:	4c 87       	std	Y+12, r20	; 0x0c
    569e:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    56a0:	8f 81       	ldd	r24, Y+7	; 0x07
    56a2:	98 85       	ldd	r25, Y+8	; 0x08
    56a4:	00 97       	sbiw	r24, 0x00	; 0
    56a6:	39 f4       	brne	.+14     	; 0x56b6 <ulTaskGenericNotifyValueClear+0x3c>
    56a8:	80 91 a6 06 	lds	r24, 0x06A6
    56ac:	90 91 a7 06 	lds	r25, 0x06A7
    56b0:	9f 87       	std	Y+15, r25	; 0x0f
    56b2:	8e 87       	std	Y+14, r24	; 0x0e
    56b4:	04 c0       	rjmp	.+8      	; 0x56be <ulTaskGenericNotifyValueClear+0x44>
    56b6:	8f 81       	ldd	r24, Y+7	; 0x07
    56b8:	98 85       	ldd	r25, Y+8	; 0x08
    56ba:	9f 87       	std	Y+15, r25	; 0x0f
    56bc:	8e 87       	std	Y+14, r24	; 0x0e
    56be:	8e 85       	ldd	r24, Y+14	; 0x0e
    56c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    56c2:	9e 83       	std	Y+6, r25	; 0x06
    56c4:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    56c6:	0f b6       	in	r0, 0x3f	; 63
    56c8:	f8 94       	cli
    56ca:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    56cc:	89 85       	ldd	r24, Y+9	; 0x09
    56ce:	88 2f       	mov	r24, r24
    56d0:	90 e0       	ldi	r25, 0x00	; 0
    56d2:	2d 81       	ldd	r18, Y+5	; 0x05
    56d4:	3e 81       	ldd	r19, Y+6	; 0x06
    56d6:	88 0f       	add	r24, r24
    56d8:	99 1f       	adc	r25, r25
    56da:	88 0f       	add	r24, r24
    56dc:	99 1f       	adc	r25, r25
    56de:	82 0f       	add	r24, r18
    56e0:	93 1f       	adc	r25, r19
    56e2:	fc 01       	movw	r30, r24
    56e4:	b1 96       	adiw	r30, 0x21	; 33
    56e6:	80 81       	ld	r24, Z
    56e8:	91 81       	ldd	r25, Z+1	; 0x01
    56ea:	a2 81       	ldd	r26, Z+2	; 0x02
    56ec:	b3 81       	ldd	r27, Z+3	; 0x03
    56ee:	89 83       	std	Y+1, r24	; 0x01
    56f0:	9a 83       	std	Y+2, r25	; 0x02
    56f2:	ab 83       	std	Y+3, r26	; 0x03
    56f4:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    56f6:	89 85       	ldd	r24, Y+9	; 0x09
    56f8:	08 2f       	mov	r16, r24
    56fa:	10 e0       	ldi	r17, 0x00	; 0
    56fc:	89 85       	ldd	r24, Y+9	; 0x09
    56fe:	88 2f       	mov	r24, r24
    5700:	90 e0       	ldi	r25, 0x00	; 0
    5702:	2d 81       	ldd	r18, Y+5	; 0x05
    5704:	3e 81       	ldd	r19, Y+6	; 0x06
    5706:	88 0f       	add	r24, r24
    5708:	99 1f       	adc	r25, r25
    570a:	88 0f       	add	r24, r24
    570c:	99 1f       	adc	r25, r25
    570e:	82 0f       	add	r24, r18
    5710:	93 1f       	adc	r25, r19
    5712:	fc 01       	movw	r30, r24
    5714:	b1 96       	adiw	r30, 0x21	; 33
    5716:	20 81       	ld	r18, Z
    5718:	31 81       	ldd	r19, Z+1	; 0x01
    571a:	42 81       	ldd	r20, Z+2	; 0x02
    571c:	53 81       	ldd	r21, Z+3	; 0x03
    571e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5720:	9b 85       	ldd	r25, Y+11	; 0x0b
    5722:	ac 85       	ldd	r26, Y+12	; 0x0c
    5724:	bd 85       	ldd	r27, Y+13	; 0x0d
    5726:	80 95       	com	r24
    5728:	90 95       	com	r25
    572a:	a0 95       	com	r26
    572c:	b0 95       	com	r27
    572e:	ba 01       	movw	r22, r20
    5730:	a9 01       	movw	r20, r18
    5732:	48 23       	and	r20, r24
    5734:	59 23       	and	r21, r25
    5736:	6a 23       	and	r22, r26
    5738:	7b 23       	and	r23, r27
    573a:	2d 81       	ldd	r18, Y+5	; 0x05
    573c:	3e 81       	ldd	r19, Y+6	; 0x06
    573e:	c8 01       	movw	r24, r16
    5740:	88 0f       	add	r24, r24
    5742:	99 1f       	adc	r25, r25
    5744:	88 0f       	add	r24, r24
    5746:	99 1f       	adc	r25, r25
    5748:	82 0f       	add	r24, r18
    574a:	93 1f       	adc	r25, r19
    574c:	fc 01       	movw	r30, r24
    574e:	b1 96       	adiw	r30, 0x21	; 33
    5750:	40 83       	st	Z, r20
    5752:	51 83       	std	Z+1, r21	; 0x01
    5754:	62 83       	std	Z+2, r22	; 0x02
    5756:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5758:	0f 90       	pop	r0
    575a:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    575c:	89 81       	ldd	r24, Y+1	; 0x01
    575e:	9a 81       	ldd	r25, Y+2	; 0x02
    5760:	ab 81       	ldd	r26, Y+3	; 0x03
    5762:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5764:	bc 01       	movw	r22, r24
    5766:	cd 01       	movw	r24, r26
    5768:	2f 96       	adiw	r28, 0x0f	; 15
    576a:	0f b6       	in	r0, 0x3f	; 63
    576c:	f8 94       	cli
    576e:	de bf       	out	0x3e, r29	; 62
    5770:	0f be       	out	0x3f, r0	; 63
    5772:	cd bf       	out	0x3d, r28	; 61
    5774:	cf 91       	pop	r28
    5776:	df 91       	pop	r29
    5778:	1f 91       	pop	r17
    577a:	0f 91       	pop	r16
    577c:	08 95       	ret

0000577e <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    577e:	df 93       	push	r29
    5780:	cf 93       	push	r28
    5782:	cd b7       	in	r28, 0x3d	; 61
    5784:	de b7       	in	r29, 0x3e	; 62
    5786:	27 97       	sbiw	r28, 0x07	; 7
    5788:	0f b6       	in	r0, 0x3f	; 63
    578a:	f8 94       	cli
    578c:	de bf       	out	0x3e, r29	; 62
    578e:	0f be       	out	0x3f, r0	; 63
    5790:	cd bf       	out	0x3d, r28	; 61
    5792:	9e 83       	std	Y+6, r25	; 0x06
    5794:	8d 83       	std	Y+5, r24	; 0x05
    5796:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5798:	80 91 aa 06 	lds	r24, 0x06AA
    579c:	90 91 ab 06 	lds	r25, 0x06AB
    57a0:	9a 83       	std	Y+2, r25	; 0x02
    57a2:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    57a4:	80 91 a6 06 	lds	r24, 0x06A6
    57a8:	90 91 a7 06 	lds	r25, 0x06A7
    57ac:	02 96       	adiw	r24, 0x02	; 2
    57ae:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    57b2:	29 81       	ldd	r18, Y+1	; 0x01
    57b4:	3a 81       	ldd	r19, Y+2	; 0x02
    57b6:	8d 81       	ldd	r24, Y+5	; 0x05
    57b8:	9e 81       	ldd	r25, Y+6	; 0x06
    57ba:	82 0f       	add	r24, r18
    57bc:	93 1f       	adc	r25, r19
    57be:	9c 83       	std	Y+4, r25	; 0x04
    57c0:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    57c2:	e0 91 a6 06 	lds	r30, 0x06A6
    57c6:	f0 91 a7 06 	lds	r31, 0x06A7
    57ca:	8b 81       	ldd	r24, Y+3	; 0x03
    57cc:	9c 81       	ldd	r25, Y+4	; 0x04
    57ce:	93 83       	std	Z+3, r25	; 0x03
    57d0:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    57d2:	2b 81       	ldd	r18, Y+3	; 0x03
    57d4:	3c 81       	ldd	r19, Y+4	; 0x04
    57d6:	89 81       	ldd	r24, Y+1	; 0x01
    57d8:	9a 81       	ldd	r25, Y+2	; 0x02
    57da:	28 17       	cp	r18, r24
    57dc:	39 07       	cpc	r19, r25
    57de:	70 f4       	brcc	.+28     	; 0x57fc <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    57e0:	80 91 f0 06 	lds	r24, 0x06F0
    57e4:	90 91 f1 06 	lds	r25, 0x06F1
    57e8:	20 91 a6 06 	lds	r18, 0x06A6
    57ec:	30 91 a7 06 	lds	r19, 0x06A7
    57f0:	2e 5f       	subi	r18, 0xFE	; 254
    57f2:	3f 4f       	sbci	r19, 0xFF	; 255
    57f4:	b9 01       	movw	r22, r18
    57f6:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <vListInsert>
    57fa:	1e c0       	rjmp	.+60     	; 0x5838 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    57fc:	40 91 ee 06 	lds	r20, 0x06EE
    5800:	50 91 ef 06 	lds	r21, 0x06EF
    5804:	80 91 a6 06 	lds	r24, 0x06A6
    5808:	90 91 a7 06 	lds	r25, 0x06A7
    580c:	9c 01       	movw	r18, r24
    580e:	2e 5f       	subi	r18, 0xFE	; 254
    5810:	3f 4f       	sbci	r19, 0xFF	; 255
    5812:	ca 01       	movw	r24, r20
    5814:	b9 01       	movw	r22, r18
    5816:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    581a:	20 91 b3 06 	lds	r18, 0x06B3
    581e:	30 91 b4 06 	lds	r19, 0x06B4
    5822:	8b 81       	ldd	r24, Y+3	; 0x03
    5824:	9c 81       	ldd	r25, Y+4	; 0x04
    5826:	82 17       	cp	r24, r18
    5828:	93 07       	cpc	r25, r19
    582a:	30 f4       	brcc	.+12     	; 0x5838 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    582c:	8b 81       	ldd	r24, Y+3	; 0x03
    582e:	9c 81       	ldd	r25, Y+4	; 0x04
    5830:	90 93 b4 06 	sts	0x06B4, r25
    5834:	80 93 b3 06 	sts	0x06B3, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    5838:	27 96       	adiw	r28, 0x07	; 7
    583a:	0f b6       	in	r0, 0x3f	; 63
    583c:	f8 94       	cli
    583e:	de bf       	out	0x3e, r29	; 62
    5840:	0f be       	out	0x3f, r0	; 63
    5842:	cd bf       	out	0x3d, r28	; 61
    5844:	cf 91       	pop	r28
    5846:	df 91       	pop	r29
    5848:	08 95       	ret

0000584a <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    584a:	ef 92       	push	r14
    584c:	ff 92       	push	r15
    584e:	0f 93       	push	r16
    5850:	df 93       	push	r29
    5852:	cf 93       	push	r28
    5854:	0f 92       	push	r0
    5856:	cd b7       	in	r28, 0x3d	; 61
    5858:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    585a:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    585c:	0e 94 e4 30 	call	0x61c8	; 0x61c8 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    5860:	80 91 04 07 	lds	r24, 0x0704
    5864:	90 91 05 07 	lds	r25, 0x0705
    5868:	00 97       	sbiw	r24, 0x00	; 0
    586a:	81 f0       	breq	.+32     	; 0x588c <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    586c:	86 e7       	ldi	r24, 0x76	; 118
    586e:	9e e2       	ldi	r25, 0x2E	; 46
    5870:	25 e6       	ldi	r18, 0x65	; 101
    5872:	30 e0       	ldi	r19, 0x00	; 0
    5874:	e6 e0       	ldi	r30, 0x06	; 6
    5876:	f7 e0       	ldi	r31, 0x07	; 7
    5878:	b9 01       	movw	r22, r18
    587a:	45 e5       	ldi	r20, 0x55	; 85
    587c:	50 e0       	ldi	r21, 0x00	; 0
    587e:	20 e0       	ldi	r18, 0x00	; 0
    5880:	30 e0       	ldi	r19, 0x00	; 0
    5882:	03 e0       	ldi	r16, 0x03	; 3
    5884:	7f 01       	movw	r14, r30
    5886:	0e 94 35 18 	call	0x306a	; 0x306a <xTaskCreate>
    588a:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    588c:	89 81       	ldd	r24, Y+1	; 0x01
    }
    588e:	0f 90       	pop	r0
    5890:	cf 91       	pop	r28
    5892:	df 91       	pop	r29
    5894:	0f 91       	pop	r16
    5896:	ff 90       	pop	r15
    5898:	ef 90       	pop	r14
    589a:	08 95       	ret

0000589c <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    589c:	ef 92       	push	r14
    589e:	ff 92       	push	r15
    58a0:	0f 93       	push	r16
    58a2:	1f 93       	push	r17
    58a4:	df 93       	push	r29
    58a6:	cf 93       	push	r28
    58a8:	cd b7       	in	r28, 0x3d	; 61
    58aa:	de b7       	in	r29, 0x3e	; 62
    58ac:	2b 97       	sbiw	r28, 0x0b	; 11
    58ae:	0f b6       	in	r0, 0x3f	; 63
    58b0:	f8 94       	cli
    58b2:	de bf       	out	0x3e, r29	; 62
    58b4:	0f be       	out	0x3f, r0	; 63
    58b6:	cd bf       	out	0x3d, r28	; 61
    58b8:	9c 83       	std	Y+4, r25	; 0x04
    58ba:	8b 83       	std	Y+3, r24	; 0x03
    58bc:	7e 83       	std	Y+6, r23	; 0x06
    58be:	6d 83       	std	Y+5, r22	; 0x05
    58c0:	4f 83       	std	Y+7, r20	; 0x07
    58c2:	39 87       	std	Y+9, r19	; 0x09
    58c4:	28 87       	std	Y+8, r18	; 0x08
    58c6:	1b 87       	std	Y+11, r17	; 0x0b
    58c8:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    58ca:	83 e1       	ldi	r24, 0x13	; 19
    58cc:	90 e0       	ldi	r25, 0x00	; 0
    58ce:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    58d2:	9a 83       	std	Y+2, r25	; 0x02
    58d4:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    58d6:	89 81       	ldd	r24, Y+1	; 0x01
    58d8:	9a 81       	ldd	r25, Y+2	; 0x02
    58da:	00 97       	sbiw	r24, 0x00	; 0
    58dc:	99 f0       	breq	.+38     	; 0x5904 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    58de:	e9 81       	ldd	r30, Y+1	; 0x01
    58e0:	fa 81       	ldd	r31, Y+2	; 0x02
    58e2:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    58e4:	8b 81       	ldd	r24, Y+3	; 0x03
    58e6:	9c 81       	ldd	r25, Y+4	; 0x04
    58e8:	2d 81       	ldd	r18, Y+5	; 0x05
    58ea:	3e 81       	ldd	r19, Y+6	; 0x06
    58ec:	e8 85       	ldd	r30, Y+8	; 0x08
    58ee:	f9 85       	ldd	r31, Y+9	; 0x09
    58f0:	aa 85       	ldd	r26, Y+10	; 0x0a
    58f2:	bb 85       	ldd	r27, Y+11	; 0x0b
    58f4:	e9 80       	ldd	r14, Y+1	; 0x01
    58f6:	fa 80       	ldd	r15, Y+2	; 0x02
    58f8:	b9 01       	movw	r22, r18
    58fa:	4f 81       	ldd	r20, Y+7	; 0x07
    58fc:	9f 01       	movw	r18, r30
    58fe:	8d 01       	movw	r16, r26
    5900:	0e 94 91 2c 	call	0x5922	; 0x5922 <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    5904:	89 81       	ldd	r24, Y+1	; 0x01
    5906:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    5908:	2b 96       	adiw	r28, 0x0b	; 11
    590a:	0f b6       	in	r0, 0x3f	; 63
    590c:	f8 94       	cli
    590e:	de bf       	out	0x3e, r29	; 62
    5910:	0f be       	out	0x3f, r0	; 63
    5912:	cd bf       	out	0x3d, r28	; 61
    5914:	cf 91       	pop	r28
    5916:	df 91       	pop	r29
    5918:	1f 91       	pop	r17
    591a:	0f 91       	pop	r16
    591c:	ff 90       	pop	r15
    591e:	ef 90       	pop	r14
    5920:	08 95       	ret

00005922 <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    5922:	ef 92       	push	r14
    5924:	ff 92       	push	r15
    5926:	0f 93       	push	r16
    5928:	1f 93       	push	r17
    592a:	df 93       	push	r29
    592c:	cf 93       	push	r28
    592e:	cd b7       	in	r28, 0x3d	; 61
    5930:	de b7       	in	r29, 0x3e	; 62
    5932:	2b 97       	sbiw	r28, 0x0b	; 11
    5934:	0f b6       	in	r0, 0x3f	; 63
    5936:	f8 94       	cli
    5938:	de bf       	out	0x3e, r29	; 62
    593a:	0f be       	out	0x3f, r0	; 63
    593c:	cd bf       	out	0x3d, r28	; 61
    593e:	9a 83       	std	Y+2, r25	; 0x02
    5940:	89 83       	std	Y+1, r24	; 0x01
    5942:	7c 83       	std	Y+4, r23	; 0x04
    5944:	6b 83       	std	Y+3, r22	; 0x03
    5946:	4d 83       	std	Y+5, r20	; 0x05
    5948:	3f 83       	std	Y+7, r19	; 0x07
    594a:	2e 83       	std	Y+6, r18	; 0x06
    594c:	19 87       	std	Y+9, r17	; 0x09
    594e:	08 87       	std	Y+8, r16	; 0x08
    5950:	fb 86       	std	Y+11, r15	; 0x0b
    5952:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    5954:	0e 94 e4 30 	call	0x61c8	; 0x61c8 <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    5958:	ea 85       	ldd	r30, Y+10	; 0x0a
    595a:	fb 85       	ldd	r31, Y+11	; 0x0b
    595c:	89 81       	ldd	r24, Y+1	; 0x01
    595e:	9a 81       	ldd	r25, Y+2	; 0x02
    5960:	91 83       	std	Z+1, r25	; 0x01
    5962:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    5964:	ea 85       	ldd	r30, Y+10	; 0x0a
    5966:	fb 85       	ldd	r31, Y+11	; 0x0b
    5968:	8b 81       	ldd	r24, Y+3	; 0x03
    596a:	9c 81       	ldd	r25, Y+4	; 0x04
    596c:	95 87       	std	Z+13, r25	; 0x0d
    596e:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    5970:	ea 85       	ldd	r30, Y+10	; 0x0a
    5972:	fb 85       	ldd	r31, Y+11	; 0x0b
    5974:	8e 81       	ldd	r24, Y+6	; 0x06
    5976:	9f 81       	ldd	r25, Y+7	; 0x07
    5978:	97 87       	std	Z+15, r25	; 0x0f
    597a:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    597c:	ea 85       	ldd	r30, Y+10	; 0x0a
    597e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5980:	88 85       	ldd	r24, Y+8	; 0x08
    5982:	99 85       	ldd	r25, Y+9	; 0x09
    5984:	91 8b       	std	Z+17, r25	; 0x11
    5986:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    5988:	8a 85       	ldd	r24, Y+10	; 0x0a
    598a:	9b 85       	ldd	r25, Y+11	; 0x0b
    598c:	02 96       	adiw	r24, 0x02	; 2
    598e:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    5992:	8d 81       	ldd	r24, Y+5	; 0x05
    5994:	88 23       	and	r24, r24
    5996:	39 f0       	breq	.+14     	; 0x59a6 <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5998:	ea 85       	ldd	r30, Y+10	; 0x0a
    599a:	fb 85       	ldd	r31, Y+11	; 0x0b
    599c:	82 89       	ldd	r24, Z+18	; 0x12
    599e:	84 60       	ori	r24, 0x04	; 4
    59a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    59a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    59a4:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    59a6:	2b 96       	adiw	r28, 0x0b	; 11
    59a8:	0f b6       	in	r0, 0x3f	; 63
    59aa:	f8 94       	cli
    59ac:	de bf       	out	0x3e, r29	; 62
    59ae:	0f be       	out	0x3f, r0	; 63
    59b0:	cd bf       	out	0x3d, r28	; 61
    59b2:	cf 91       	pop	r28
    59b4:	df 91       	pop	r29
    59b6:	1f 91       	pop	r17
    59b8:	0f 91       	pop	r16
    59ba:	ff 90       	pop	r15
    59bc:	ef 90       	pop	r14
    59be:	08 95       	ret

000059c0 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    59c0:	0f 93       	push	r16
    59c2:	1f 93       	push	r17
    59c4:	df 93       	push	r29
    59c6:	cf 93       	push	r28
    59c8:	cd b7       	in	r28, 0x3d	; 61
    59ca:	de b7       	in	r29, 0x3e	; 62
    59cc:	2f 97       	sbiw	r28, 0x0f	; 15
    59ce:	0f b6       	in	r0, 0x3f	; 63
    59d0:	f8 94       	cli
    59d2:	de bf       	out	0x3e, r29	; 62
    59d4:	0f be       	out	0x3f, r0	; 63
    59d6:	cd bf       	out	0x3d, r28	; 61
    59d8:	98 87       	std	Y+8, r25	; 0x08
    59da:	8f 83       	std	Y+7, r24	; 0x07
    59dc:	69 87       	std	Y+9, r22	; 0x09
    59de:	5b 87       	std	Y+11, r21	; 0x0b
    59e0:	4a 87       	std	Y+10, r20	; 0x0a
    59e2:	3d 87       	std	Y+13, r19	; 0x0d
    59e4:	2c 87       	std	Y+12, r18	; 0x0c
    59e6:	1f 87       	std	Y+15, r17	; 0x0f
    59e8:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    59ea:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    59ec:	80 91 04 07 	lds	r24, 0x0704
    59f0:	90 91 05 07 	lds	r25, 0x0705
    59f4:	00 97       	sbiw	r24, 0x00	; 0
    59f6:	e9 f1       	breq	.+122    	; 0x5a72 <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    59f8:	89 85       	ldd	r24, Y+9	; 0x09
    59fa:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    59fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    59fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    5a00:	9c 83       	std	Y+4, r25	; 0x04
    5a02:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    5a04:	8f 81       	ldd	r24, Y+7	; 0x07
    5a06:	98 85       	ldd	r25, Y+8	; 0x08
    5a08:	9e 83       	std	Y+6, r25	; 0x06
    5a0a:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    5a0c:	89 85       	ldd	r24, Y+9	; 0x09
    5a0e:	86 30       	cpi	r24, 0x06	; 6
    5a10:	14 f5       	brge	.+68     	; 0x5a56 <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    5a12:	0e 94 fa 23 	call	0x47f4	; 0x47f4 <xTaskGetSchedulerState>
    5a16:	82 30       	cpi	r24, 0x02	; 2
    5a18:	79 f4       	brne	.+30     	; 0x5a38 <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    5a1a:	80 91 04 07 	lds	r24, 0x0704
    5a1e:	90 91 05 07 	lds	r25, 0x0705
    5a22:	9e 01       	movw	r18, r28
    5a24:	2e 5f       	subi	r18, 0xFE	; 254
    5a26:	3f 4f       	sbci	r19, 0xFF	; 255
    5a28:	4e 85       	ldd	r20, Y+14	; 0x0e
    5a2a:	5f 85       	ldd	r21, Y+15	; 0x0f
    5a2c:	b9 01       	movw	r22, r18
    5a2e:	20 e0       	ldi	r18, 0x00	; 0
    5a30:	0e 94 39 10 	call	0x2072	; 0x2072 <xQueueGenericSend>
    5a34:	89 83       	std	Y+1, r24	; 0x01
    5a36:	1d c0       	rjmp	.+58     	; 0x5a72 <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    5a38:	80 91 04 07 	lds	r24, 0x0704
    5a3c:	90 91 05 07 	lds	r25, 0x0705
    5a40:	9e 01       	movw	r18, r28
    5a42:	2e 5f       	subi	r18, 0xFE	; 254
    5a44:	3f 4f       	sbci	r19, 0xFF	; 255
    5a46:	b9 01       	movw	r22, r18
    5a48:	40 e0       	ldi	r20, 0x00	; 0
    5a4a:	50 e0       	ldi	r21, 0x00	; 0
    5a4c:	20 e0       	ldi	r18, 0x00	; 0
    5a4e:	0e 94 39 10 	call	0x2072	; 0x2072 <xQueueGenericSend>
    5a52:	89 83       	std	Y+1, r24	; 0x01
    5a54:	0e c0       	rjmp	.+28     	; 0x5a72 <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    5a56:	80 91 04 07 	lds	r24, 0x0704
    5a5a:	90 91 05 07 	lds	r25, 0x0705
    5a5e:	9e 01       	movw	r18, r28
    5a60:	2e 5f       	subi	r18, 0xFE	; 254
    5a62:	3f 4f       	sbci	r19, 0xFF	; 255
    5a64:	4c 85       	ldd	r20, Y+12	; 0x0c
    5a66:	5d 85       	ldd	r21, Y+13	; 0x0d
    5a68:	b9 01       	movw	r22, r18
    5a6a:	20 e0       	ldi	r18, 0x00	; 0
    5a6c:	0e 94 e5 10 	call	0x21ca	; 0x21ca <xQueueGenericSendFromISR>
    5a70:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    5a72:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5a74:	2f 96       	adiw	r28, 0x0f	; 15
    5a76:	0f b6       	in	r0, 0x3f	; 63
    5a78:	f8 94       	cli
    5a7a:	de bf       	out	0x3e, r29	; 62
    5a7c:	0f be       	out	0x3f, r0	; 63
    5a7e:	cd bf       	out	0x3d, r28	; 61
    5a80:	cf 91       	pop	r28
    5a82:	df 91       	pop	r29
    5a84:	1f 91       	pop	r17
    5a86:	0f 91       	pop	r16
    5a88:	08 95       	ret

00005a8a <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    5a8a:	df 93       	push	r29
    5a8c:	cf 93       	push	r28
    5a8e:	cd b7       	in	r28, 0x3d	; 61
    5a90:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    5a92:	80 91 06 07 	lds	r24, 0x0706
    5a96:	90 91 07 07 	lds	r25, 0x0707
    }
    5a9a:	cf 91       	pop	r28
    5a9c:	df 91       	pop	r29
    5a9e:	08 95       	ret

00005aa0 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    5aa0:	df 93       	push	r29
    5aa2:	cf 93       	push	r28
    5aa4:	00 d0       	rcall	.+0      	; 0x5aa6 <xTimerGetPeriod+0x6>
    5aa6:	00 d0       	rcall	.+0      	; 0x5aa8 <xTimerGetPeriod+0x8>
    5aa8:	cd b7       	in	r28, 0x3d	; 61
    5aaa:	de b7       	in	r29, 0x3e	; 62
    5aac:	9c 83       	std	Y+4, r25	; 0x04
    5aae:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ab2:	9c 81       	ldd	r25, Y+4	; 0x04
    5ab4:	9a 83       	std	Y+2, r25	; 0x02
    5ab6:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    5ab8:	e9 81       	ldd	r30, Y+1	; 0x01
    5aba:	fa 81       	ldd	r31, Y+2	; 0x02
    5abc:	84 85       	ldd	r24, Z+12	; 0x0c
    5abe:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    5ac0:	0f 90       	pop	r0
    5ac2:	0f 90       	pop	r0
    5ac4:	0f 90       	pop	r0
    5ac6:	0f 90       	pop	r0
    5ac8:	cf 91       	pop	r28
    5aca:	df 91       	pop	r29
    5acc:	08 95       	ret

00005ace <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    5ace:	df 93       	push	r29
    5ad0:	cf 93       	push	r28
    5ad2:	00 d0       	rcall	.+0      	; 0x5ad4 <vTimerSetReloadMode+0x6>
    5ad4:	00 d0       	rcall	.+0      	; 0x5ad6 <vTimerSetReloadMode+0x8>
    5ad6:	0f 92       	push	r0
    5ad8:	cd b7       	in	r28, 0x3d	; 61
    5ada:	de b7       	in	r29, 0x3e	; 62
    5adc:	9c 83       	std	Y+4, r25	; 0x04
    5ade:	8b 83       	std	Y+3, r24	; 0x03
    5ae0:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    5ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    5ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    5ae6:	9a 83       	std	Y+2, r25	; 0x02
    5ae8:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5aea:	0f b6       	in	r0, 0x3f	; 63
    5aec:	f8 94       	cli
    5aee:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    5af0:	8d 81       	ldd	r24, Y+5	; 0x05
    5af2:	88 23       	and	r24, r24
    5af4:	41 f0       	breq	.+16     	; 0x5b06 <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5af6:	e9 81       	ldd	r30, Y+1	; 0x01
    5af8:	fa 81       	ldd	r31, Y+2	; 0x02
    5afa:	82 89       	ldd	r24, Z+18	; 0x12
    5afc:	84 60       	ori	r24, 0x04	; 4
    5afe:	e9 81       	ldd	r30, Y+1	; 0x01
    5b00:	fa 81       	ldd	r31, Y+2	; 0x02
    5b02:	82 8b       	std	Z+18, r24	; 0x12
    5b04:	07 c0       	rjmp	.+14     	; 0x5b14 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    5b06:	e9 81       	ldd	r30, Y+1	; 0x01
    5b08:	fa 81       	ldd	r31, Y+2	; 0x02
    5b0a:	82 89       	ldd	r24, Z+18	; 0x12
    5b0c:	8b 7f       	andi	r24, 0xFB	; 251
    5b0e:	e9 81       	ldd	r30, Y+1	; 0x01
    5b10:	fa 81       	ldd	r31, Y+2	; 0x02
    5b12:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    5b14:	0f 90       	pop	r0
    5b16:	0f be       	out	0x3f, r0	; 63
    }
    5b18:	0f 90       	pop	r0
    5b1a:	0f 90       	pop	r0
    5b1c:	0f 90       	pop	r0
    5b1e:	0f 90       	pop	r0
    5b20:	0f 90       	pop	r0
    5b22:	cf 91       	pop	r28
    5b24:	df 91       	pop	r29
    5b26:	08 95       	ret

00005b28 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    5b28:	df 93       	push	r29
    5b2a:	cf 93       	push	r28
    5b2c:	00 d0       	rcall	.+0      	; 0x5b2e <uxTimerGetReloadMode+0x6>
    5b2e:	00 d0       	rcall	.+0      	; 0x5b30 <uxTimerGetReloadMode+0x8>
    5b30:	0f 92       	push	r0
    5b32:	cd b7       	in	r28, 0x3d	; 61
    5b34:	de b7       	in	r29, 0x3e	; 62
    5b36:	9d 83       	std	Y+5, r25	; 0x05
    5b38:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    5b3a:	8c 81       	ldd	r24, Y+4	; 0x04
    5b3c:	9d 81       	ldd	r25, Y+5	; 0x05
    5b3e:	9b 83       	std	Y+3, r25	; 0x03
    5b40:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5b42:	0f b6       	in	r0, 0x3f	; 63
    5b44:	f8 94       	cli
    5b46:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    5b48:	ea 81       	ldd	r30, Y+2	; 0x02
    5b4a:	fb 81       	ldd	r31, Y+3	; 0x03
    5b4c:	82 89       	ldd	r24, Z+18	; 0x12
    5b4e:	88 2f       	mov	r24, r24
    5b50:	90 e0       	ldi	r25, 0x00	; 0
    5b52:	84 70       	andi	r24, 0x04	; 4
    5b54:	90 70       	andi	r25, 0x00	; 0
    5b56:	00 97       	sbiw	r24, 0x00	; 0
    5b58:	11 f4       	brne	.+4      	; 0x5b5e <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    5b5a:	19 82       	std	Y+1, r1	; 0x01
    5b5c:	02 c0       	rjmp	.+4      	; 0x5b62 <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    5b5e:	81 e0       	ldi	r24, 0x01	; 1
    5b60:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5b62:	0f 90       	pop	r0
    5b64:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    5b66:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5b68:	0f 90       	pop	r0
    5b6a:	0f 90       	pop	r0
    5b6c:	0f 90       	pop	r0
    5b6e:	0f 90       	pop	r0
    5b70:	0f 90       	pop	r0
    5b72:	cf 91       	pop	r28
    5b74:	df 91       	pop	r29
    5b76:	08 95       	ret

00005b78 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    5b78:	df 93       	push	r29
    5b7a:	cf 93       	push	r28
    5b7c:	00 d0       	rcall	.+0      	; 0x5b7e <xTimerGetExpiryTime+0x6>
    5b7e:	00 d0       	rcall	.+0      	; 0x5b80 <xTimerGetExpiryTime+0x8>
    5b80:	00 d0       	rcall	.+0      	; 0x5b82 <xTimerGetExpiryTime+0xa>
    5b82:	cd b7       	in	r28, 0x3d	; 61
    5b84:	de b7       	in	r29, 0x3e	; 62
    5b86:	9e 83       	std	Y+6, r25	; 0x06
    5b88:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    5b8a:	8d 81       	ldd	r24, Y+5	; 0x05
    5b8c:	9e 81       	ldd	r25, Y+6	; 0x06
    5b8e:	9c 83       	std	Y+4, r25	; 0x04
    5b90:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    5b92:	eb 81       	ldd	r30, Y+3	; 0x03
    5b94:	fc 81       	ldd	r31, Y+4	; 0x04
    5b96:	82 81       	ldd	r24, Z+2	; 0x02
    5b98:	93 81       	ldd	r25, Z+3	; 0x03
    5b9a:	9a 83       	std	Y+2, r25	; 0x02
    5b9c:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    5b9e:	89 81       	ldd	r24, Y+1	; 0x01
    5ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5ba2:	26 96       	adiw	r28, 0x06	; 6
    5ba4:	0f b6       	in	r0, 0x3f	; 63
    5ba6:	f8 94       	cli
    5ba8:	de bf       	out	0x3e, r29	; 62
    5baa:	0f be       	out	0x3f, r0	; 63
    5bac:	cd bf       	out	0x3d, r28	; 61
    5bae:	cf 91       	pop	r28
    5bb0:	df 91       	pop	r29
    5bb2:	08 95       	ret

00005bb4 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    5bb4:	df 93       	push	r29
    5bb6:	cf 93       	push	r28
    5bb8:	00 d0       	rcall	.+0      	; 0x5bba <pcTimerGetName+0x6>
    5bba:	00 d0       	rcall	.+0      	; 0x5bbc <pcTimerGetName+0x8>
    5bbc:	cd b7       	in	r28, 0x3d	; 61
    5bbe:	de b7       	in	r29, 0x3e	; 62
    5bc0:	9c 83       	std	Y+4, r25	; 0x04
    5bc2:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    5bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    5bc8:	9a 83       	std	Y+2, r25	; 0x02
    5bca:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    5bcc:	e9 81       	ldd	r30, Y+1	; 0x01
    5bce:	fa 81       	ldd	r31, Y+2	; 0x02
    5bd0:	80 81       	ld	r24, Z
    5bd2:	91 81       	ldd	r25, Z+1	; 0x01
    }
    5bd4:	0f 90       	pop	r0
    5bd6:	0f 90       	pop	r0
    5bd8:	0f 90       	pop	r0
    5bda:	0f 90       	pop	r0
    5bdc:	cf 91       	pop	r28
    5bde:	df 91       	pop	r29
    5be0:	08 95       	ret

00005be2 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    5be2:	df 93       	push	r29
    5be4:	cf 93       	push	r28
    5be6:	00 d0       	rcall	.+0      	; 0x5be8 <prvReloadTimer+0x6>
    5be8:	00 d0       	rcall	.+0      	; 0x5bea <prvReloadTimer+0x8>
    5bea:	00 d0       	rcall	.+0      	; 0x5bec <prvReloadTimer+0xa>
    5bec:	cd b7       	in	r28, 0x3d	; 61
    5bee:	de b7       	in	r29, 0x3e	; 62
    5bf0:	9a 83       	std	Y+2, r25	; 0x02
    5bf2:	89 83       	std	Y+1, r24	; 0x01
    5bf4:	7c 83       	std	Y+4, r23	; 0x04
    5bf6:	6b 83       	std	Y+3, r22	; 0x03
    5bf8:	5e 83       	std	Y+6, r21	; 0x06
    5bfa:	4d 83       	std	Y+5, r20	; 0x05
    5bfc:	12 c0       	rjmp	.+36     	; 0x5c22 <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    5bfe:	e9 81       	ldd	r30, Y+1	; 0x01
    5c00:	fa 81       	ldd	r31, Y+2	; 0x02
    5c02:	24 85       	ldd	r18, Z+12	; 0x0c
    5c04:	35 85       	ldd	r19, Z+13	; 0x0d
    5c06:	8b 81       	ldd	r24, Y+3	; 0x03
    5c08:	9c 81       	ldd	r25, Y+4	; 0x04
    5c0a:	82 0f       	add	r24, r18
    5c0c:	93 1f       	adc	r25, r19
    5c0e:	9c 83       	std	Y+4, r25	; 0x04
    5c10:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5c12:	e9 81       	ldd	r30, Y+1	; 0x01
    5c14:	fa 81       	ldd	r31, Y+2	; 0x02
    5c16:	00 88       	ldd	r0, Z+16	; 0x10
    5c18:	f1 89       	ldd	r31, Z+17	; 0x11
    5c1a:	e0 2d       	mov	r30, r0
    5c1c:	89 81       	ldd	r24, Y+1	; 0x01
    5c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    5c20:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    5c22:	e9 81       	ldd	r30, Y+1	; 0x01
    5c24:	fa 81       	ldd	r31, Y+2	; 0x02
    5c26:	24 85       	ldd	r18, Z+12	; 0x0c
    5c28:	35 85       	ldd	r19, Z+13	; 0x0d
    5c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    5c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    5c2e:	a9 01       	movw	r20, r18
    5c30:	48 0f       	add	r20, r24
    5c32:	59 1f       	adc	r21, r25
    5c34:	89 81       	ldd	r24, Y+1	; 0x01
    5c36:	9a 81       	ldd	r25, Y+2	; 0x02
    5c38:	2d 81       	ldd	r18, Y+5	; 0x05
    5c3a:	3e 81       	ldd	r19, Y+6	; 0x06
    5c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    5c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    5c40:	ba 01       	movw	r22, r20
    5c42:	a9 01       	movw	r20, r18
    5c44:	9f 01       	movw	r18, r30
    5c46:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <prvInsertTimerInActiveList>
    5c4a:	88 23       	and	r24, r24
    5c4c:	c1 f6       	brne	.-80     	; 0x5bfe <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    5c4e:	26 96       	adiw	r28, 0x06	; 6
    5c50:	0f b6       	in	r0, 0x3f	; 63
    5c52:	f8 94       	cli
    5c54:	de bf       	out	0x3e, r29	; 62
    5c56:	0f be       	out	0x3f, r0	; 63
    5c58:	cd bf       	out	0x3d, r28	; 61
    5c5a:	cf 91       	pop	r28
    5c5c:	df 91       	pop	r29
    5c5e:	08 95       	ret

00005c60 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    5c60:	df 93       	push	r29
    5c62:	cf 93       	push	r28
    5c64:	00 d0       	rcall	.+0      	; 0x5c66 <prvProcessExpiredTimer+0x6>
    5c66:	00 d0       	rcall	.+0      	; 0x5c68 <prvProcessExpiredTimer+0x8>
    5c68:	00 d0       	rcall	.+0      	; 0x5c6a <prvProcessExpiredTimer+0xa>
    5c6a:	cd b7       	in	r28, 0x3d	; 61
    5c6c:	de b7       	in	r29, 0x3e	; 62
    5c6e:	9c 83       	std	Y+4, r25	; 0x04
    5c70:	8b 83       	std	Y+3, r24	; 0x03
    5c72:	7e 83       	std	Y+6, r23	; 0x06
    5c74:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5c76:	e0 91 1c 07 	lds	r30, 0x071C
    5c7a:	f0 91 1d 07 	lds	r31, 0x071D
    5c7e:	05 80       	ldd	r0, Z+5	; 0x05
    5c80:	f6 81       	ldd	r31, Z+6	; 0x06
    5c82:	e0 2d       	mov	r30, r0
    5c84:	86 81       	ldd	r24, Z+6	; 0x06
    5c86:	97 81       	ldd	r25, Z+7	; 0x07
    5c88:	9a 83       	std	Y+2, r25	; 0x02
    5c8a:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5c8c:	89 81       	ldd	r24, Y+1	; 0x01
    5c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    5c90:	02 96       	adiw	r24, 0x02	; 2
    5c92:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    5c96:	e9 81       	ldd	r30, Y+1	; 0x01
    5c98:	fa 81       	ldd	r31, Y+2	; 0x02
    5c9a:	82 89       	ldd	r24, Z+18	; 0x12
    5c9c:	88 2f       	mov	r24, r24
    5c9e:	90 e0       	ldi	r25, 0x00	; 0
    5ca0:	84 70       	andi	r24, 0x04	; 4
    5ca2:	90 70       	andi	r25, 0x00	; 0
    5ca4:	00 97       	sbiw	r24, 0x00	; 0
    5ca6:	51 f0       	breq	.+20     	; 0x5cbc <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    5ca8:	89 81       	ldd	r24, Y+1	; 0x01
    5caa:	9a 81       	ldd	r25, Y+2	; 0x02
    5cac:	2b 81       	ldd	r18, Y+3	; 0x03
    5cae:	3c 81       	ldd	r19, Y+4	; 0x04
    5cb0:	4d 81       	ldd	r20, Y+5	; 0x05
    5cb2:	5e 81       	ldd	r21, Y+6	; 0x06
    5cb4:	b9 01       	movw	r22, r18
    5cb6:	0e 94 f1 2d 	call	0x5be2	; 0x5be2 <prvReloadTimer>
    5cba:	07 c0       	rjmp	.+14     	; 0x5cca <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    5cbc:	e9 81       	ldd	r30, Y+1	; 0x01
    5cbe:	fa 81       	ldd	r31, Y+2	; 0x02
    5cc0:	82 89       	ldd	r24, Z+18	; 0x12
    5cc2:	8e 7f       	andi	r24, 0xFE	; 254
    5cc4:	e9 81       	ldd	r30, Y+1	; 0x01
    5cc6:	fa 81       	ldd	r31, Y+2	; 0x02
    5cc8:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5cca:	e9 81       	ldd	r30, Y+1	; 0x01
    5ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    5cce:	00 88       	ldd	r0, Z+16	; 0x10
    5cd0:	f1 89       	ldd	r31, Z+17	; 0x11
    5cd2:	e0 2d       	mov	r30, r0
    5cd4:	89 81       	ldd	r24, Y+1	; 0x01
    5cd6:	9a 81       	ldd	r25, Y+2	; 0x02
    5cd8:	09 95       	icall
    }
    5cda:	26 96       	adiw	r28, 0x06	; 6
    5cdc:	0f b6       	in	r0, 0x3f	; 63
    5cde:	f8 94       	cli
    5ce0:	de bf       	out	0x3e, r29	; 62
    5ce2:	0f be       	out	0x3f, r0	; 63
    5ce4:	cd bf       	out	0x3d, r28	; 61
    5ce6:	cf 91       	pop	r28
    5ce8:	df 91       	pop	r29
    5cea:	08 95       	ret

00005cec <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    5cec:	df 93       	push	r29
    5cee:	cf 93       	push	r28
    5cf0:	00 d0       	rcall	.+0      	; 0x5cf2 <prvTimerTask+0x6>
    5cf2:	00 d0       	rcall	.+0      	; 0x5cf4 <prvTimerTask+0x8>
    5cf4:	0f 92       	push	r0
    5cf6:	cd b7       	in	r28, 0x3d	; 61
    5cf8:	de b7       	in	r29, 0x3e	; 62
    5cfa:	9d 83       	std	Y+5, r25	; 0x05
    5cfc:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    5cfe:	ce 01       	movw	r24, r28
    5d00:	03 96       	adiw	r24, 0x03	; 3
    5d02:	0e 94 e5 2e 	call	0x5dca	; 0x5dca <prvGetNextExpireTime>
    5d06:	9a 83       	std	Y+2, r25	; 0x02
    5d08:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    5d0a:	2b 81       	ldd	r18, Y+3	; 0x03
    5d0c:	89 81       	ldd	r24, Y+1	; 0x01
    5d0e:	9a 81       	ldd	r25, Y+2	; 0x02
    5d10:	62 2f       	mov	r22, r18
    5d12:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    5d16:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <prvProcessReceivedCommands>
    5d1a:	f1 cf       	rjmp	.-30     	; 0x5cfe <prvTimerTask+0x12>

00005d1c <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    5d1c:	df 93       	push	r29
    5d1e:	cf 93       	push	r28
    5d20:	00 d0       	rcall	.+0      	; 0x5d22 <prvProcessTimerOrBlockTask+0x6>
    5d22:	00 d0       	rcall	.+0      	; 0x5d24 <prvProcessTimerOrBlockTask+0x8>
    5d24:	00 d0       	rcall	.+0      	; 0x5d26 <prvProcessTimerOrBlockTask+0xa>
    5d26:	cd b7       	in	r28, 0x3d	; 61
    5d28:	de b7       	in	r29, 0x3e	; 62
    5d2a:	9d 83       	std	Y+5, r25	; 0x05
    5d2c:	8c 83       	std	Y+4, r24	; 0x04
    5d2e:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    5d30:	0e 94 86 1b 	call	0x370c	; 0x370c <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5d34:	ce 01       	movw	r24, r28
    5d36:	03 96       	adiw	r24, 0x03	; 3
    5d38:	0e 94 19 2f 	call	0x5e32	; 0x5e32 <prvSampleTimeNow>
    5d3c:	9a 83       	std	Y+2, r25	; 0x02
    5d3e:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    5d40:	8b 81       	ldd	r24, Y+3	; 0x03
    5d42:	88 23       	and	r24, r24
    5d44:	b9 f5       	brne	.+110    	; 0x5db4 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    5d46:	8e 81       	ldd	r24, Y+6	; 0x06
    5d48:	88 23       	and	r24, r24
    5d4a:	89 f4       	brne	.+34     	; 0x5d6e <prvProcessTimerOrBlockTask+0x52>
    5d4c:	2c 81       	ldd	r18, Y+4	; 0x04
    5d4e:	3d 81       	ldd	r19, Y+5	; 0x05
    5d50:	89 81       	ldd	r24, Y+1	; 0x01
    5d52:	9a 81       	ldd	r25, Y+2	; 0x02
    5d54:	82 17       	cp	r24, r18
    5d56:	93 07       	cpc	r25, r19
    5d58:	50 f0       	brcs	.+20     	; 0x5d6e <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    5d5a:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    5d5e:	8c 81       	ldd	r24, Y+4	; 0x04
    5d60:	9d 81       	ldd	r25, Y+5	; 0x05
    5d62:	29 81       	ldd	r18, Y+1	; 0x01
    5d64:	3a 81       	ldd	r19, Y+2	; 0x02
    5d66:	b9 01       	movw	r22, r18
    5d68:	0e 94 30 2e 	call	0x5c60	; 0x5c60 <prvProcessExpiredTimer>
    5d6c:	25 c0       	rjmp	.+74     	; 0x5db8 <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    5d6e:	8e 81       	ldd	r24, Y+6	; 0x06
    5d70:	88 23       	and	r24, r24
    5d72:	51 f0       	breq	.+20     	; 0x5d88 <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    5d74:	e0 91 1e 07 	lds	r30, 0x071E
    5d78:	f0 91 1f 07 	lds	r31, 0x071F
    5d7c:	80 81       	ld	r24, Z
    5d7e:	1e 82       	std	Y+6, r1	; 0x06
    5d80:	88 23       	and	r24, r24
    5d82:	11 f4       	brne	.+4      	; 0x5d88 <prvProcessTimerOrBlockTask+0x6c>
    5d84:	81 e0       	ldi	r24, 0x01	; 1
    5d86:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    5d88:	40 91 04 07 	lds	r20, 0x0704
    5d8c:	50 91 05 07 	lds	r21, 0x0705
    5d90:	2c 81       	ldd	r18, Y+4	; 0x04
    5d92:	3d 81       	ldd	r19, Y+5	; 0x05
    5d94:	89 81       	ldd	r24, Y+1	; 0x01
    5d96:	9a 81       	ldd	r25, Y+2	; 0x02
    5d98:	28 1b       	sub	r18, r24
    5d9a:	39 0b       	sbc	r19, r25
    5d9c:	ca 01       	movw	r24, r20
    5d9e:	b9 01       	movw	r22, r18
    5da0:	4e 81       	ldd	r20, Y+6	; 0x06
    5da2:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    5da6:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
    5daa:	88 23       	and	r24, r24
    5dac:	29 f4       	brne	.+10     	; 0x5db8 <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    5dae:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    5db2:	02 c0       	rjmp	.+4      	; 0x5db8 <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    5db4:	0e 94 92 1b 	call	0x3724	; 0x3724 <xTaskResumeAll>
            }
        }
    }
    5db8:	26 96       	adiw	r28, 0x06	; 6
    5dba:	0f b6       	in	r0, 0x3f	; 63
    5dbc:	f8 94       	cli
    5dbe:	de bf       	out	0x3e, r29	; 62
    5dc0:	0f be       	out	0x3f, r0	; 63
    5dc2:	cd bf       	out	0x3d, r28	; 61
    5dc4:	cf 91       	pop	r28
    5dc6:	df 91       	pop	r29
    5dc8:	08 95       	ret

00005dca <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    5dca:	df 93       	push	r29
    5dcc:	cf 93       	push	r28
    5dce:	00 d0       	rcall	.+0      	; 0x5dd0 <prvGetNextExpireTime+0x6>
    5dd0:	00 d0       	rcall	.+0      	; 0x5dd2 <prvGetNextExpireTime+0x8>
    5dd2:	0f 92       	push	r0
    5dd4:	cd b7       	in	r28, 0x3d	; 61
    5dd6:	de b7       	in	r29, 0x3e	; 62
    5dd8:	9c 83       	std	Y+4, r25	; 0x04
    5dda:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    5ddc:	e0 91 1c 07 	lds	r30, 0x071C
    5de0:	f0 91 1d 07 	lds	r31, 0x071D
    5de4:	80 81       	ld	r24, Z
    5de6:	1d 82       	std	Y+5, r1	; 0x05
    5de8:	88 23       	and	r24, r24
    5dea:	11 f4       	brne	.+4      	; 0x5df0 <prvGetNextExpireTime+0x26>
    5dec:	81 e0       	ldi	r24, 0x01	; 1
    5dee:	8d 83       	std	Y+5, r24	; 0x05
    5df0:	eb 81       	ldd	r30, Y+3	; 0x03
    5df2:	fc 81       	ldd	r31, Y+4	; 0x04
    5df4:	8d 81       	ldd	r24, Y+5	; 0x05
    5df6:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    5df8:	eb 81       	ldd	r30, Y+3	; 0x03
    5dfa:	fc 81       	ldd	r31, Y+4	; 0x04
    5dfc:	80 81       	ld	r24, Z
    5dfe:	88 23       	and	r24, r24
    5e00:	61 f4       	brne	.+24     	; 0x5e1a <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    5e02:	e0 91 1c 07 	lds	r30, 0x071C
    5e06:	f0 91 1d 07 	lds	r31, 0x071D
    5e0a:	05 80       	ldd	r0, Z+5	; 0x05
    5e0c:	f6 81       	ldd	r31, Z+6	; 0x06
    5e0e:	e0 2d       	mov	r30, r0
    5e10:	80 81       	ld	r24, Z
    5e12:	91 81       	ldd	r25, Z+1	; 0x01
    5e14:	9a 83       	std	Y+2, r25	; 0x02
    5e16:	89 83       	std	Y+1, r24	; 0x01
    5e18:	02 c0       	rjmp	.+4      	; 0x5e1e <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    5e1a:	1a 82       	std	Y+2, r1	; 0x02
    5e1c:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    5e1e:	89 81       	ldd	r24, Y+1	; 0x01
    5e20:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5e22:	0f 90       	pop	r0
    5e24:	0f 90       	pop	r0
    5e26:	0f 90       	pop	r0
    5e28:	0f 90       	pop	r0
    5e2a:	0f 90       	pop	r0
    5e2c:	cf 91       	pop	r28
    5e2e:	df 91       	pop	r29
    5e30:	08 95       	ret

00005e32 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    5e32:	df 93       	push	r29
    5e34:	cf 93       	push	r28
    5e36:	00 d0       	rcall	.+0      	; 0x5e38 <prvSampleTimeNow+0x6>
    5e38:	00 d0       	rcall	.+0      	; 0x5e3a <prvSampleTimeNow+0x8>
    5e3a:	cd b7       	in	r28, 0x3d	; 61
    5e3c:	de b7       	in	r29, 0x3e	; 62
    5e3e:	9c 83       	std	Y+4, r25	; 0x04
    5e40:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    5e42:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <xTaskGetTickCount>
    5e46:	9a 83       	std	Y+2, r25	; 0x02
    5e48:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    5e4a:	20 91 08 07 	lds	r18, 0x0708
    5e4e:	30 91 09 07 	lds	r19, 0x0709
    5e52:	89 81       	ldd	r24, Y+1	; 0x01
    5e54:	9a 81       	ldd	r25, Y+2	; 0x02
    5e56:	82 17       	cp	r24, r18
    5e58:	93 07       	cpc	r25, r19
    5e5a:	38 f4       	brcc	.+14     	; 0x5e6a <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    5e5c:	0e 94 aa 30 	call	0x6154	; 0x6154 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    5e60:	eb 81       	ldd	r30, Y+3	; 0x03
    5e62:	fc 81       	ldd	r31, Y+4	; 0x04
    5e64:	81 e0       	ldi	r24, 0x01	; 1
    5e66:	80 83       	st	Z, r24
    5e68:	03 c0       	rjmp	.+6      	; 0x5e70 <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    5e6a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e6c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e6e:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    5e70:	89 81       	ldd	r24, Y+1	; 0x01
    5e72:	9a 81       	ldd	r25, Y+2	; 0x02
    5e74:	90 93 09 07 	sts	0x0709, r25
    5e78:	80 93 08 07 	sts	0x0708, r24

        return xTimeNow;
    5e7c:	89 81       	ldd	r24, Y+1	; 0x01
    5e7e:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5e80:	0f 90       	pop	r0
    5e82:	0f 90       	pop	r0
    5e84:	0f 90       	pop	r0
    5e86:	0f 90       	pop	r0
    5e88:	cf 91       	pop	r28
    5e8a:	df 91       	pop	r29
    5e8c:	08 95       	ret

00005e8e <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    5e8e:	df 93       	push	r29
    5e90:	cf 93       	push	r28
    5e92:	cd b7       	in	r28, 0x3d	; 61
    5e94:	de b7       	in	r29, 0x3e	; 62
    5e96:	29 97       	sbiw	r28, 0x09	; 9
    5e98:	0f b6       	in	r0, 0x3f	; 63
    5e9a:	f8 94       	cli
    5e9c:	de bf       	out	0x3e, r29	; 62
    5e9e:	0f be       	out	0x3f, r0	; 63
    5ea0:	cd bf       	out	0x3d, r28	; 61
    5ea2:	9b 83       	std	Y+3, r25	; 0x03
    5ea4:	8a 83       	std	Y+2, r24	; 0x02
    5ea6:	7d 83       	std	Y+5, r23	; 0x05
    5ea8:	6c 83       	std	Y+4, r22	; 0x04
    5eaa:	5f 83       	std	Y+7, r21	; 0x07
    5eac:	4e 83       	std	Y+6, r20	; 0x06
    5eae:	39 87       	std	Y+9, r19	; 0x09
    5eb0:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    5eb2:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    5eb4:	ea 81       	ldd	r30, Y+2	; 0x02
    5eb6:	fb 81       	ldd	r31, Y+3	; 0x03
    5eb8:	8c 81       	ldd	r24, Y+4	; 0x04
    5eba:	9d 81       	ldd	r25, Y+5	; 0x05
    5ebc:	93 83       	std	Z+3, r25	; 0x03
    5ebe:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    5ec0:	ea 81       	ldd	r30, Y+2	; 0x02
    5ec2:	fb 81       	ldd	r31, Y+3	; 0x03
    5ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ec6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ec8:	91 87       	std	Z+9, r25	; 0x09
    5eca:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    5ecc:	2c 81       	ldd	r18, Y+4	; 0x04
    5ece:	3d 81       	ldd	r19, Y+5	; 0x05
    5ed0:	8e 81       	ldd	r24, Y+6	; 0x06
    5ed2:	9f 81       	ldd	r25, Y+7	; 0x07
    5ed4:	82 17       	cp	r24, r18
    5ed6:	93 07       	cpc	r25, r19
    5ed8:	e0 f0       	brcs	.+56     	; 0x5f12 <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5eda:	2e 81       	ldd	r18, Y+6	; 0x06
    5edc:	3f 81       	ldd	r19, Y+7	; 0x07
    5ede:	88 85       	ldd	r24, Y+8	; 0x08
    5ee0:	99 85       	ldd	r25, Y+9	; 0x09
    5ee2:	28 1b       	sub	r18, r24
    5ee4:	39 0b       	sbc	r19, r25
    5ee6:	ea 81       	ldd	r30, Y+2	; 0x02
    5ee8:	fb 81       	ldd	r31, Y+3	; 0x03
    5eea:	84 85       	ldd	r24, Z+12	; 0x0c
    5eec:	95 85       	ldd	r25, Z+13	; 0x0d
    5eee:	28 17       	cp	r18, r24
    5ef0:	39 07       	cpc	r19, r25
    5ef2:	18 f0       	brcs	.+6      	; 0x5efa <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    5ef4:	81 e0       	ldi	r24, 0x01	; 1
    5ef6:	89 83       	std	Y+1, r24	; 0x01
    5ef8:	28 c0       	rjmp	.+80     	; 0x5f4a <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    5efa:	80 91 1e 07 	lds	r24, 0x071E
    5efe:	90 91 1f 07 	lds	r25, 0x071F
    5f02:	2a 81       	ldd	r18, Y+2	; 0x02
    5f04:	3b 81       	ldd	r19, Y+3	; 0x03
    5f06:	2e 5f       	subi	r18, 0xFE	; 254
    5f08:	3f 4f       	sbci	r19, 0xFF	; 255
    5f0a:	b9 01       	movw	r22, r18
    5f0c:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <vListInsert>
    5f10:	1c c0       	rjmp	.+56     	; 0x5f4a <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    5f12:	2e 81       	ldd	r18, Y+6	; 0x06
    5f14:	3f 81       	ldd	r19, Y+7	; 0x07
    5f16:	88 85       	ldd	r24, Y+8	; 0x08
    5f18:	99 85       	ldd	r25, Y+9	; 0x09
    5f1a:	28 17       	cp	r18, r24
    5f1c:	39 07       	cpc	r19, r25
    5f1e:	50 f4       	brcc	.+20     	; 0x5f34 <prvInsertTimerInActiveList+0xa6>
    5f20:	2c 81       	ldd	r18, Y+4	; 0x04
    5f22:	3d 81       	ldd	r19, Y+5	; 0x05
    5f24:	88 85       	ldd	r24, Y+8	; 0x08
    5f26:	99 85       	ldd	r25, Y+9	; 0x09
    5f28:	28 17       	cp	r18, r24
    5f2a:	39 07       	cpc	r19, r25
    5f2c:	18 f0       	brcs	.+6      	; 0x5f34 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    5f2e:	81 e0       	ldi	r24, 0x01	; 1
    5f30:	89 83       	std	Y+1, r24	; 0x01
    5f32:	0b c0       	rjmp	.+22     	; 0x5f4a <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    5f34:	80 91 1c 07 	lds	r24, 0x071C
    5f38:	90 91 1d 07 	lds	r25, 0x071D
    5f3c:	2a 81       	ldd	r18, Y+2	; 0x02
    5f3e:	3b 81       	ldd	r19, Y+3	; 0x03
    5f40:	2e 5f       	subi	r18, 0xFE	; 254
    5f42:	3f 4f       	sbci	r19, 0xFF	; 255
    5f44:	b9 01       	movw	r22, r18
    5f46:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <vListInsert>
            }
        }

        return xProcessTimerNow;
    5f4a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5f4c:	29 96       	adiw	r28, 0x09	; 9
    5f4e:	0f b6       	in	r0, 0x3f	; 63
    5f50:	f8 94       	cli
    5f52:	de bf       	out	0x3e, r29	; 62
    5f54:	0f be       	out	0x3f, r0	; 63
    5f56:	cd bf       	out	0x3d, r28	; 61
    5f58:	cf 91       	pop	r28
    5f5a:	df 91       	pop	r29
    5f5c:	08 95       	ret

00005f5e <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    5f5e:	df 93       	push	r29
    5f60:	cf 93       	push	r28
    5f62:	cd b7       	in	r28, 0x3d	; 61
    5f64:	de b7       	in	r29, 0x3e	; 62
    5f66:	2c 97       	sbiw	r28, 0x0c	; 12
    5f68:	0f b6       	in	r0, 0x3f	; 63
    5f6a:	f8 94       	cli
    5f6c:	de bf       	out	0x3e, r29	; 62
    5f6e:	0f be       	out	0x3f, r0	; 63
    5f70:	cd bf       	out	0x3d, r28	; 61
    5f72:	d8 c0       	rjmp	.+432    	; 0x6124 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    5f74:	8d 81       	ldd	r24, Y+5	; 0x05
    5f76:	88 23       	and	r24, r24
    5f78:	0c f4       	brge	.+2      	; 0x5f7c <prvProcessReceivedCommands+0x1e>
    5f7a:	d4 c0       	rjmp	.+424    	; 0x6124 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    5f7c:	88 85       	ldd	r24, Y+8	; 0x08
    5f7e:	99 85       	ldd	r25, Y+9	; 0x09
    5f80:	9c 83       	std	Y+4, r25	; 0x04
    5f82:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    5f84:	eb 81       	ldd	r30, Y+3	; 0x03
    5f86:	fc 81       	ldd	r31, Y+4	; 0x04
    5f88:	82 85       	ldd	r24, Z+10	; 0x0a
    5f8a:	93 85       	ldd	r25, Z+11	; 0x0b
    5f8c:	00 97       	sbiw	r24, 0x00	; 0
    5f8e:	29 f0       	breq	.+10     	; 0x5f9a <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5f90:	8b 81       	ldd	r24, Y+3	; 0x03
    5f92:	9c 81       	ldd	r25, Y+4	; 0x04
    5f94:	02 96       	adiw	r24, 0x02	; 2
    5f96:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5f9a:	ce 01       	movw	r24, r28
    5f9c:	0a 96       	adiw	r24, 0x0a	; 10
    5f9e:	0e 94 19 2f 	call	0x5e32	; 0x5e32 <prvSampleTimeNow>
    5fa2:	9a 83       	std	Y+2, r25	; 0x02
    5fa4:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    5fa6:	8d 81       	ldd	r24, Y+5	; 0x05
    5fa8:	28 2f       	mov	r18, r24
    5faa:	33 27       	eor	r19, r19
    5fac:	27 fd       	sbrc	r18, 7
    5fae:	30 95       	com	r19
    5fb0:	3c 87       	std	Y+12, r19	; 0x0c
    5fb2:	2b 87       	std	Y+11, r18	; 0x0b
    5fb4:	8b 85       	ldd	r24, Y+11	; 0x0b
    5fb6:	9c 85       	ldd	r25, Y+12	; 0x0c
    5fb8:	85 30       	cpi	r24, 0x05	; 5
    5fba:	91 05       	cpc	r25, r1
    5fbc:	09 f4       	brne	.+2      	; 0x5fc0 <prvProcessReceivedCommands+0x62>
    5fbe:	9d c0       	rjmp	.+314    	; 0x60fa <prvProcessReceivedCommands+0x19c>
    5fc0:	2b 85       	ldd	r18, Y+11	; 0x0b
    5fc2:	3c 85       	ldd	r19, Y+12	; 0x0c
    5fc4:	26 30       	cpi	r18, 0x06	; 6
    5fc6:	31 05       	cpc	r19, r1
    5fc8:	9c f4       	brge	.+38     	; 0x5ff0 <prvProcessReceivedCommands+0x92>
    5fca:	8b 85       	ldd	r24, Y+11	; 0x0b
    5fcc:	9c 85       	ldd	r25, Y+12	; 0x0c
    5fce:	83 30       	cpi	r24, 0x03	; 3
    5fd0:	91 05       	cpc	r25, r1
    5fd2:	09 f4       	brne	.+2      	; 0x5fd6 <prvProcessReceivedCommands+0x78>
    5fd4:	68 c0       	rjmp	.+208    	; 0x60a6 <prvProcessReceivedCommands+0x148>
    5fd6:	2b 85       	ldd	r18, Y+11	; 0x0b
    5fd8:	3c 85       	ldd	r19, Y+12	; 0x0c
    5fda:	24 30       	cpi	r18, 0x04	; 4
    5fdc:	31 05       	cpc	r19, r1
    5fde:	0c f0       	brlt	.+2      	; 0x5fe2 <prvProcessReceivedCommands+0x84>
    5fe0:	6a c0       	rjmp	.+212    	; 0x60b6 <prvProcessReceivedCommands+0x158>
    5fe2:	8b 85       	ldd	r24, Y+11	; 0x0b
    5fe4:	9c 85       	ldd	r25, Y+12	; 0x0c
    5fe6:	81 30       	cpi	r24, 0x01	; 1
    5fe8:	91 05       	cpc	r25, r1
    5fea:	0c f4       	brge	.+2      	; 0x5fee <prvProcessReceivedCommands+0x90>
    5fec:	9b c0       	rjmp	.+310    	; 0x6124 <prvProcessReceivedCommands+0x1c6>
    5fee:	12 c0       	rjmp	.+36     	; 0x6014 <prvProcessReceivedCommands+0xb6>
    5ff0:	2b 85       	ldd	r18, Y+11	; 0x0b
    5ff2:	3c 85       	ldd	r19, Y+12	; 0x0c
    5ff4:	28 30       	cpi	r18, 0x08	; 8
    5ff6:	31 05       	cpc	r19, r1
    5ff8:	09 f4       	brne	.+2      	; 0x5ffc <prvProcessReceivedCommands+0x9e>
    5ffa:	55 c0       	rjmp	.+170    	; 0x60a6 <prvProcessReceivedCommands+0x148>
    5ffc:	8b 85       	ldd	r24, Y+11	; 0x0b
    5ffe:	9c 85       	ldd	r25, Y+12	; 0x0c
    6000:	88 30       	cpi	r24, 0x08	; 8
    6002:	91 05       	cpc	r25, r1
    6004:	3c f0       	brlt	.+14     	; 0x6014 <prvProcessReceivedCommands+0xb6>
    6006:	2b 85       	ldd	r18, Y+11	; 0x0b
    6008:	3c 85       	ldd	r19, Y+12	; 0x0c
    600a:	29 30       	cpi	r18, 0x09	; 9
    600c:	31 05       	cpc	r19, r1
    600e:	09 f4       	brne	.+2      	; 0x6012 <prvProcessReceivedCommands+0xb4>
    6010:	52 c0       	rjmp	.+164    	; 0x60b6 <prvProcessReceivedCommands+0x158>
    6012:	88 c0       	rjmp	.+272    	; 0x6124 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    6014:	eb 81       	ldd	r30, Y+3	; 0x03
    6016:	fc 81       	ldd	r31, Y+4	; 0x04
    6018:	82 89       	ldd	r24, Z+18	; 0x12
    601a:	81 60       	ori	r24, 0x01	; 1
    601c:	eb 81       	ldd	r30, Y+3	; 0x03
    601e:	fc 81       	ldd	r31, Y+4	; 0x04
    6020:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    6022:	2e 81       	ldd	r18, Y+6	; 0x06
    6024:	3f 81       	ldd	r19, Y+7	; 0x07
    6026:	eb 81       	ldd	r30, Y+3	; 0x03
    6028:	fc 81       	ldd	r31, Y+4	; 0x04
    602a:	84 85       	ldd	r24, Z+12	; 0x0c
    602c:	95 85       	ldd	r25, Z+13	; 0x0d
    602e:	a9 01       	movw	r20, r18
    6030:	48 0f       	add	r20, r24
    6032:	59 1f       	adc	r21, r25
    6034:	ee 81       	ldd	r30, Y+6	; 0x06
    6036:	ff 81       	ldd	r31, Y+7	; 0x07
    6038:	8b 81       	ldd	r24, Y+3	; 0x03
    603a:	9c 81       	ldd	r25, Y+4	; 0x04
    603c:	29 81       	ldd	r18, Y+1	; 0x01
    603e:	3a 81       	ldd	r19, Y+2	; 0x02
    6040:	ba 01       	movw	r22, r20
    6042:	a9 01       	movw	r20, r18
    6044:	9f 01       	movw	r18, r30
    6046:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <prvInsertTimerInActiveList>
    604a:	88 23       	and	r24, r24
    604c:	09 f4       	brne	.+2      	; 0x6050 <prvProcessReceivedCommands+0xf2>
    604e:	6a c0       	rjmp	.+212    	; 0x6124 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    6050:	eb 81       	ldd	r30, Y+3	; 0x03
    6052:	fc 81       	ldd	r31, Y+4	; 0x04
    6054:	82 89       	ldd	r24, Z+18	; 0x12
    6056:	88 2f       	mov	r24, r24
    6058:	90 e0       	ldi	r25, 0x00	; 0
    605a:	84 70       	andi	r24, 0x04	; 4
    605c:	90 70       	andi	r25, 0x00	; 0
    605e:	00 97       	sbiw	r24, 0x00	; 0
    6060:	91 f0       	breq	.+36     	; 0x6086 <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    6062:	2e 81       	ldd	r18, Y+6	; 0x06
    6064:	3f 81       	ldd	r19, Y+7	; 0x07
    6066:	eb 81       	ldd	r30, Y+3	; 0x03
    6068:	fc 81       	ldd	r31, Y+4	; 0x04
    606a:	84 85       	ldd	r24, Z+12	; 0x0c
    606c:	95 85       	ldd	r25, Z+13	; 0x0d
    606e:	a9 01       	movw	r20, r18
    6070:	48 0f       	add	r20, r24
    6072:	59 1f       	adc	r21, r25
    6074:	8b 81       	ldd	r24, Y+3	; 0x03
    6076:	9c 81       	ldd	r25, Y+4	; 0x04
    6078:	29 81       	ldd	r18, Y+1	; 0x01
    607a:	3a 81       	ldd	r19, Y+2	; 0x02
    607c:	ba 01       	movw	r22, r20
    607e:	a9 01       	movw	r20, r18
    6080:	0e 94 f1 2d 	call	0x5be2	; 0x5be2 <prvReloadTimer>
    6084:	07 c0       	rjmp	.+14     	; 0x6094 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6086:	eb 81       	ldd	r30, Y+3	; 0x03
    6088:	fc 81       	ldd	r31, Y+4	; 0x04
    608a:	82 89       	ldd	r24, Z+18	; 0x12
    608c:	8e 7f       	andi	r24, 0xFE	; 254
    608e:	eb 81       	ldd	r30, Y+3	; 0x03
    6090:	fc 81       	ldd	r31, Y+4	; 0x04
    6092:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6094:	eb 81       	ldd	r30, Y+3	; 0x03
    6096:	fc 81       	ldd	r31, Y+4	; 0x04
    6098:	00 88       	ldd	r0, Z+16	; 0x10
    609a:	f1 89       	ldd	r31, Z+17	; 0x11
    609c:	e0 2d       	mov	r30, r0
    609e:	8b 81       	ldd	r24, Y+3	; 0x03
    60a0:	9c 81       	ldd	r25, Y+4	; 0x04
    60a2:	09 95       	icall
    60a4:	3f c0       	rjmp	.+126    	; 0x6124 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    60a6:	eb 81       	ldd	r30, Y+3	; 0x03
    60a8:	fc 81       	ldd	r31, Y+4	; 0x04
    60aa:	82 89       	ldd	r24, Z+18	; 0x12
    60ac:	8e 7f       	andi	r24, 0xFE	; 254
    60ae:	eb 81       	ldd	r30, Y+3	; 0x03
    60b0:	fc 81       	ldd	r31, Y+4	; 0x04
    60b2:	82 8b       	std	Z+18, r24	; 0x12
    60b4:	37 c0       	rjmp	.+110    	; 0x6124 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    60b6:	eb 81       	ldd	r30, Y+3	; 0x03
    60b8:	fc 81       	ldd	r31, Y+4	; 0x04
    60ba:	82 89       	ldd	r24, Z+18	; 0x12
    60bc:	81 60       	ori	r24, 0x01	; 1
    60be:	eb 81       	ldd	r30, Y+3	; 0x03
    60c0:	fc 81       	ldd	r31, Y+4	; 0x04
    60c2:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    60c4:	8e 81       	ldd	r24, Y+6	; 0x06
    60c6:	9f 81       	ldd	r25, Y+7	; 0x07
    60c8:	eb 81       	ldd	r30, Y+3	; 0x03
    60ca:	fc 81       	ldd	r31, Y+4	; 0x04
    60cc:	95 87       	std	Z+13, r25	; 0x0d
    60ce:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    60d0:	eb 81       	ldd	r30, Y+3	; 0x03
    60d2:	fc 81       	ldd	r31, Y+4	; 0x04
    60d4:	24 85       	ldd	r18, Z+12	; 0x0c
    60d6:	35 85       	ldd	r19, Z+13	; 0x0d
    60d8:	89 81       	ldd	r24, Y+1	; 0x01
    60da:	9a 81       	ldd	r25, Y+2	; 0x02
    60dc:	a9 01       	movw	r20, r18
    60de:	48 0f       	add	r20, r24
    60e0:	59 1f       	adc	r21, r25
    60e2:	8b 81       	ldd	r24, Y+3	; 0x03
    60e4:	9c 81       	ldd	r25, Y+4	; 0x04
    60e6:	29 81       	ldd	r18, Y+1	; 0x01
    60e8:	3a 81       	ldd	r19, Y+2	; 0x02
    60ea:	e9 81       	ldd	r30, Y+1	; 0x01
    60ec:	fa 81       	ldd	r31, Y+2	; 0x02
    60ee:	ba 01       	movw	r22, r20
    60f0:	a9 01       	movw	r20, r18
    60f2:	9f 01       	movw	r18, r30
    60f4:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <prvInsertTimerInActiveList>
    60f8:	15 c0       	rjmp	.+42     	; 0x6124 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    60fa:	eb 81       	ldd	r30, Y+3	; 0x03
    60fc:	fc 81       	ldd	r31, Y+4	; 0x04
    60fe:	82 89       	ldd	r24, Z+18	; 0x12
    6100:	88 2f       	mov	r24, r24
    6102:	90 e0       	ldi	r25, 0x00	; 0
    6104:	82 70       	andi	r24, 0x02	; 2
    6106:	90 70       	andi	r25, 0x00	; 0
    6108:	00 97       	sbiw	r24, 0x00	; 0
    610a:	29 f4       	brne	.+10     	; 0x6116 <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    610c:	8b 81       	ldd	r24, Y+3	; 0x03
    610e:	9c 81       	ldd	r25, Y+4	; 0x04
    6110:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    6114:	07 c0       	rjmp	.+14     	; 0x6124 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6116:	eb 81       	ldd	r30, Y+3	; 0x03
    6118:	fc 81       	ldd	r31, Y+4	; 0x04
    611a:	82 89       	ldd	r24, Z+18	; 0x12
    611c:	8e 7f       	andi	r24, 0xFE	; 254
    611e:	eb 81       	ldd	r30, Y+3	; 0x03
    6120:	fc 81       	ldd	r31, Y+4	; 0x04
    6122:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    6124:	80 91 04 07 	lds	r24, 0x0704
    6128:	90 91 05 07 	lds	r25, 0x0705
    612c:	9e 01       	movw	r18, r28
    612e:	2b 5f       	subi	r18, 0xFB	; 251
    6130:	3f 4f       	sbci	r19, 0xFF	; 255
    6132:	b9 01       	movw	r22, r18
    6134:	40 e0       	ldi	r20, 0x00	; 0
    6136:	50 e0       	ldi	r21, 0x00	; 0
    6138:	0e 94 92 11 	call	0x2324	; 0x2324 <xQueueReceive>
    613c:	88 23       	and	r24, r24
    613e:	09 f0       	breq	.+2      	; 0x6142 <prvProcessReceivedCommands+0x1e4>
    6140:	19 cf       	rjmp	.-462    	; 0x5f74 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    6142:	2c 96       	adiw	r28, 0x0c	; 12
    6144:	0f b6       	in	r0, 0x3f	; 63
    6146:	f8 94       	cli
    6148:	de bf       	out	0x3e, r29	; 62
    614a:	0f be       	out	0x3f, r0	; 63
    614c:	cd bf       	out	0x3d, r28	; 61
    614e:	cf 91       	pop	r28
    6150:	df 91       	pop	r29
    6152:	08 95       	ret

00006154 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    6154:	df 93       	push	r29
    6156:	cf 93       	push	r28
    6158:	00 d0       	rcall	.+0      	; 0x615a <prvSwitchTimerLists+0x6>
    615a:	00 d0       	rcall	.+0      	; 0x615c <prvSwitchTimerLists+0x8>
    615c:	cd b7       	in	r28, 0x3d	; 61
    615e:	de b7       	in	r29, 0x3e	; 62
    6160:	11 c0       	rjmp	.+34     	; 0x6184 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    6162:	e0 91 1c 07 	lds	r30, 0x071C
    6166:	f0 91 1d 07 	lds	r31, 0x071D
    616a:	05 80       	ldd	r0, Z+5	; 0x05
    616c:	f6 81       	ldd	r31, Z+6	; 0x06
    616e:	e0 2d       	mov	r30, r0
    6170:	80 81       	ld	r24, Z
    6172:	91 81       	ldd	r25, Z+1	; 0x01
    6174:	9c 83       	std	Y+4, r25	; 0x04
    6176:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    6178:	8b 81       	ldd	r24, Y+3	; 0x03
    617a:	9c 81       	ldd	r25, Y+4	; 0x04
    617c:	6f ef       	ldi	r22, 0xFF	; 255
    617e:	7f ef       	ldi	r23, 0xFF	; 255
    6180:	0e 94 30 2e 	call	0x5c60	; 0x5c60 <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    6184:	e0 91 1c 07 	lds	r30, 0x071C
    6188:	f0 91 1d 07 	lds	r31, 0x071D
    618c:	80 81       	ld	r24, Z
    618e:	88 23       	and	r24, r24
    6190:	41 f7       	brne	.-48     	; 0x6162 <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    6192:	80 91 1c 07 	lds	r24, 0x071C
    6196:	90 91 1d 07 	lds	r25, 0x071D
    619a:	9a 83       	std	Y+2, r25	; 0x02
    619c:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    619e:	80 91 1e 07 	lds	r24, 0x071E
    61a2:	90 91 1f 07 	lds	r25, 0x071F
    61a6:	90 93 1d 07 	sts	0x071D, r25
    61aa:	80 93 1c 07 	sts	0x071C, r24
        pxOverflowTimerList = pxTemp;
    61ae:	89 81       	ldd	r24, Y+1	; 0x01
    61b0:	9a 81       	ldd	r25, Y+2	; 0x02
    61b2:	90 93 1f 07 	sts	0x071F, r25
    61b6:	80 93 1e 07 	sts	0x071E, r24
    }
    61ba:	0f 90       	pop	r0
    61bc:	0f 90       	pop	r0
    61be:	0f 90       	pop	r0
    61c0:	0f 90       	pop	r0
    61c2:	cf 91       	pop	r28
    61c4:	df 91       	pop	r29
    61c6:	08 95       	ret

000061c8 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    61c8:	df 93       	push	r29
    61ca:	cf 93       	push	r28
    61cc:	cd b7       	in	r28, 0x3d	; 61
    61ce:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    61d0:	0f b6       	in	r0, 0x3f	; 63
    61d2:	f8 94       	cli
    61d4:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    61d6:	80 91 04 07 	lds	r24, 0x0704
    61da:	90 91 05 07 	lds	r25, 0x0705
    61de:	00 97       	sbiw	r24, 0x00	; 0
    61e0:	e9 f4       	brne	.+58     	; 0x621c <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    61e2:	8a e0       	ldi	r24, 0x0A	; 10
    61e4:	97 e0       	ldi	r25, 0x07	; 7
    61e6:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    61ea:	83 e1       	ldi	r24, 0x13	; 19
    61ec:	97 e0       	ldi	r25, 0x07	; 7
    61ee:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    61f2:	8a e0       	ldi	r24, 0x0A	; 10
    61f4:	97 e0       	ldi	r25, 0x07	; 7
    61f6:	90 93 1d 07 	sts	0x071D, r25
    61fa:	80 93 1c 07 	sts	0x071C, r24
                pxOverflowTimerList = &xActiveTimerList2;
    61fe:	83 e1       	ldi	r24, 0x13	; 19
    6200:	97 e0       	ldi	r25, 0x07	; 7
    6202:	90 93 1f 07 	sts	0x071F, r25
    6206:	80 93 1e 07 	sts	0x071E, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    620a:	8a e0       	ldi	r24, 0x0A	; 10
    620c:	65 e0       	ldi	r22, 0x05	; 5
    620e:	40 e0       	ldi	r20, 0x00	; 0
    6210:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <xQueueGenericCreate>
    6214:	90 93 05 07 	sts	0x0705, r25
    6218:	80 93 04 07 	sts	0x0704, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    621c:	0f 90       	pop	r0
    621e:	0f be       	out	0x3f, r0	; 63
    }
    6220:	cf 91       	pop	r28
    6222:	df 91       	pop	r29
    6224:	08 95       	ret

00006226 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    6226:	df 93       	push	r29
    6228:	cf 93       	push	r28
    622a:	00 d0       	rcall	.+0      	; 0x622c <xTimerIsTimerActive+0x6>
    622c:	00 d0       	rcall	.+0      	; 0x622e <xTimerIsTimerActive+0x8>
    622e:	0f 92       	push	r0
    6230:	cd b7       	in	r28, 0x3d	; 61
    6232:	de b7       	in	r29, 0x3e	; 62
    6234:	9d 83       	std	Y+5, r25	; 0x05
    6236:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    6238:	8c 81       	ldd	r24, Y+4	; 0x04
    623a:	9d 81       	ldd	r25, Y+5	; 0x05
    623c:	9a 83       	std	Y+2, r25	; 0x02
    623e:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    6240:	0f b6       	in	r0, 0x3f	; 63
    6242:	f8 94       	cli
    6244:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    6246:	e9 81       	ldd	r30, Y+1	; 0x01
    6248:	fa 81       	ldd	r31, Y+2	; 0x02
    624a:	82 89       	ldd	r24, Z+18	; 0x12
    624c:	88 2f       	mov	r24, r24
    624e:	90 e0       	ldi	r25, 0x00	; 0
    6250:	81 70       	andi	r24, 0x01	; 1
    6252:	90 70       	andi	r25, 0x00	; 0
    6254:	00 97       	sbiw	r24, 0x00	; 0
    6256:	11 f4       	brne	.+4      	; 0x625c <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    6258:	1b 82       	std	Y+3, r1	; 0x03
    625a:	02 c0       	rjmp	.+4      	; 0x6260 <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    625c:	81 e0       	ldi	r24, 0x01	; 1
    625e:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    6260:	0f 90       	pop	r0
    6262:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6264:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    6266:	0f 90       	pop	r0
    6268:	0f 90       	pop	r0
    626a:	0f 90       	pop	r0
    626c:	0f 90       	pop	r0
    626e:	0f 90       	pop	r0
    6270:	cf 91       	pop	r28
    6272:	df 91       	pop	r29
    6274:	08 95       	ret

00006276 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    6276:	df 93       	push	r29
    6278:	cf 93       	push	r28
    627a:	00 d0       	rcall	.+0      	; 0x627c <pvTimerGetTimerID+0x6>
    627c:	00 d0       	rcall	.+0      	; 0x627e <pvTimerGetTimerID+0x8>
    627e:	00 d0       	rcall	.+0      	; 0x6280 <pvTimerGetTimerID+0xa>
    6280:	cd b7       	in	r28, 0x3d	; 61
    6282:	de b7       	in	r29, 0x3e	; 62
    6284:	9e 83       	std	Y+6, r25	; 0x06
    6286:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    6288:	8d 81       	ldd	r24, Y+5	; 0x05
    628a:	9e 81       	ldd	r25, Y+6	; 0x06
    628c:	9c 83       	std	Y+4, r25	; 0x04
    628e:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    6290:	0f b6       	in	r0, 0x3f	; 63
    6292:	f8 94       	cli
    6294:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    6296:	eb 81       	ldd	r30, Y+3	; 0x03
    6298:	fc 81       	ldd	r31, Y+4	; 0x04
    629a:	86 85       	ldd	r24, Z+14	; 0x0e
    629c:	97 85       	ldd	r25, Z+15	; 0x0f
    629e:	9a 83       	std	Y+2, r25	; 0x02
    62a0:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    62a2:	0f 90       	pop	r0
    62a4:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    62a6:	89 81       	ldd	r24, Y+1	; 0x01
    62a8:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    62aa:	26 96       	adiw	r28, 0x06	; 6
    62ac:	0f b6       	in	r0, 0x3f	; 63
    62ae:	f8 94       	cli
    62b0:	de bf       	out	0x3e, r29	; 62
    62b2:	0f be       	out	0x3f, r0	; 63
    62b4:	cd bf       	out	0x3d, r28	; 61
    62b6:	cf 91       	pop	r28
    62b8:	df 91       	pop	r29
    62ba:	08 95       	ret

000062bc <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    62bc:	df 93       	push	r29
    62be:	cf 93       	push	r28
    62c0:	00 d0       	rcall	.+0      	; 0x62c2 <vTimerSetTimerID+0x6>
    62c2:	00 d0       	rcall	.+0      	; 0x62c4 <vTimerSetTimerID+0x8>
    62c4:	00 d0       	rcall	.+0      	; 0x62c6 <vTimerSetTimerID+0xa>
    62c6:	cd b7       	in	r28, 0x3d	; 61
    62c8:	de b7       	in	r29, 0x3e	; 62
    62ca:	9c 83       	std	Y+4, r25	; 0x04
    62cc:	8b 83       	std	Y+3, r24	; 0x03
    62ce:	7e 83       	std	Y+6, r23	; 0x06
    62d0:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    62d2:	8b 81       	ldd	r24, Y+3	; 0x03
    62d4:	9c 81       	ldd	r25, Y+4	; 0x04
    62d6:	9a 83       	std	Y+2, r25	; 0x02
    62d8:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    62da:	0f b6       	in	r0, 0x3f	; 63
    62dc:	f8 94       	cli
    62de:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    62e0:	e9 81       	ldd	r30, Y+1	; 0x01
    62e2:	fa 81       	ldd	r31, Y+2	; 0x02
    62e4:	8d 81       	ldd	r24, Y+5	; 0x05
    62e6:	9e 81       	ldd	r25, Y+6	; 0x06
    62e8:	97 87       	std	Z+15, r25	; 0x0f
    62ea:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    62ec:	0f 90       	pop	r0
    62ee:	0f be       	out	0x3f, r0	; 63
    }
    62f0:	26 96       	adiw	r28, 0x06	; 6
    62f2:	0f b6       	in	r0, 0x3f	; 63
    62f4:	f8 94       	cli
    62f6:	de bf       	out	0x3e, r29	; 62
    62f8:	0f be       	out	0x3f, r0	; 63
    62fa:	cd bf       	out	0x3d, r28	; 61
    62fc:	cf 91       	pop	r28
    62fe:	df 91       	pop	r29
    6300:	08 95       	ret

00006302 <main>:
void toggle_led_mode(void);

TaskHandle_t task2ptr;

int main(void)
{
    6302:	ef 92       	push	r14
    6304:	ff 92       	push	r15
    6306:	0f 93       	push	r16
    6308:	1f 93       	push	r17
    630a:	df 93       	push	r29
    630c:	cf 93       	push	r28
    630e:	cd b7       	in	r28, 0x3d	; 61
    6310:	de b7       	in	r29, 0x3e	; 62


	PWM_INIT();
    6312:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <PWM_INIT>
	xButtonTimer = xTimerCreate
    6316:	e0 ef       	ldi	r30, 0xF0	; 240
    6318:	f1 e3       	ldi	r31, 0x31	; 49
    631a:	8d e6       	ldi	r24, 0x6D	; 109
    631c:	90 e0       	ldi	r25, 0x00	; 0
    631e:	65 e0       	ldi	r22, 0x05	; 5
    6320:	70 e0       	ldi	r23, 0x00	; 0
    6322:	41 e0       	ldi	r20, 0x01	; 1
    6324:	20 e0       	ldi	r18, 0x00	; 0
    6326:	30 e0       	ldi	r19, 0x00	; 0
    6328:	8f 01       	movw	r16, r30
    632a:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTimerCreate>
    632e:	90 93 21 07 	sts	0x0721, r25
    6332:	80 93 20 07 	sts	0x0720, r24
	                     ( void * ) 0,
	                     /* Each timer calls the same callback when
	                     it expires. */
						 get_readings
	                   );
	xLedBlinkingTimer = xTimerCreate
    6336:	ed ed       	ldi	r30, 0xDD	; 221
    6338:	f1 e3       	ldi	r31, 0x31	; 49
    633a:	8a e7       	ldi	r24, 0x7A	; 122
    633c:	90 e0       	ldi	r25, 0x00	; 0
    633e:	64 ef       	ldi	r22, 0xF4	; 244
    6340:	71 e0       	ldi	r23, 0x01	; 1
    6342:	41 e0       	ldi	r20, 0x01	; 1
    6344:	20 e0       	ldi	r18, 0x00	; 0
    6346:	30 e0       	ldi	r19, 0x00	; 0
    6348:	8f 01       	movw	r16, r30
    634a:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTimerCreate>
    634e:	90 93 23 07 	sts	0x0723, r25
    6352:	80 93 22 07 	sts	0x0722, r24
		                     ( void * ) 0,
		                     /* Each timer calls the same callback when
		                     it expires. */
							 toggle_led_mode
		                   );
	xTaskCreate(vState_machine,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    6356:	85 e7       	ldi	r24, 0x75	; 117
    6358:	92 e3       	ldi	r25, 0x32	; 50
    635a:	24 e8       	ldi	r18, 0x84	; 132
    635c:	30 e0       	ldi	r19, 0x00	; 0
    635e:	ed e2       	ldi	r30, 0x2D	; 45
    6360:	f7 e0       	ldi	r31, 0x07	; 7
    6362:	b9 01       	movw	r22, r18
    6364:	45 e5       	ldi	r20, 0x55	; 85
    6366:	50 e0       	ldi	r21, 0x00	; 0
    6368:	20 e0       	ldi	r18, 0x00	; 0
    636a:	30 e0       	ldi	r19, 0x00	; 0
    636c:	01 e0       	ldi	r16, 0x01	; 1
    636e:	7f 01       	movw	r14, r30
    6370:	0e 94 35 18 	call	0x306a	; 0x306a <xTaskCreate>
	xTimerStart(xButtonTimer, 10 );
    6374:	00 91 20 07 	lds	r16, 0x0720
    6378:	10 91 21 07 	lds	r17, 0x0721
    637c:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <xTaskGetTickCount>
    6380:	9c 01       	movw	r18, r24
    6382:	c8 01       	movw	r24, r16
    6384:	61 e0       	ldi	r22, 0x01	; 1
    6386:	a9 01       	movw	r20, r18
    6388:	20 e0       	ldi	r18, 0x00	; 0
    638a:	30 e0       	ldi	r19, 0x00	; 0
    638c:	0a e0       	ldi	r16, 0x0A	; 10
    638e:	10 e0       	ldi	r17, 0x00	; 0
    6390:	0e 94 e0 2c 	call	0x59c0	; 0x59c0 <xTimerGenericCommand>
	xTimerStart(xLedBlinkingTimer, 10 );
    6394:	00 91 22 07 	lds	r16, 0x0722
    6398:	10 91 23 07 	lds	r17, 0x0723
    639c:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <xTaskGetTickCount>
    63a0:	9c 01       	movw	r18, r24
    63a2:	c8 01       	movw	r24, r16
    63a4:	61 e0       	ldi	r22, 0x01	; 1
    63a6:	a9 01       	movw	r20, r18
    63a8:	20 e0       	ldi	r18, 0x00	; 0
    63aa:	30 e0       	ldi	r19, 0x00	; 0
    63ac:	0a e0       	ldi	r16, 0x0A	; 10
    63ae:	10 e0       	ldi	r17, 0x00	; 0
    63b0:	0e 94 e0 2c 	call	0x59c0	; 0x59c0 <xTimerGenericCommand>
	vTaskStartScheduler();
    63b4:	0e 94 3f 1b 	call	0x367e	; 0x367e <vTaskStartScheduler>
    63b8:	ff cf       	rjmp	.-2      	; 0x63b8 <main+0xb6>

000063ba <toggle_led_mode>:


	}
}

void toggle_led_mode(void){
    63ba:	df 93       	push	r29
    63bc:	cf 93       	push	r28
    63be:	0f 92       	push	r0
    63c0:	cd b7       	in	r28, 0x3d	; 61
    63c2:	de b7       	in	r29, 0x3e	; 62
		led_mode = !led_mode;
    63c4:	80 91 24 07 	lds	r24, 0x0724
    63c8:	19 82       	std	Y+1, r1	; 0x01
    63ca:	88 23       	and	r24, r24
    63cc:	11 f4       	brne	.+4      	; 0x63d2 <toggle_led_mode+0x18>
    63ce:	81 e0       	ldi	r24, 0x01	; 1
    63d0:	89 83       	std	Y+1, r24	; 0x01
    63d2:	89 81       	ldd	r24, Y+1	; 0x01
    63d4:	80 93 24 07 	sts	0x0724, r24
}
    63d8:	0f 90       	pop	r0
    63da:	cf 91       	pop	r28
    63dc:	df 91       	pop	r29
    63de:	08 95       	ret

000063e0 <get_readings>:
void get_readings(void)
{
    63e0:	df 93       	push	r29
    63e2:	cf 93       	push	r28
    63e4:	00 d0       	rcall	.+0      	; 0x63e6 <get_readings+0x6>
    63e6:	0f 92       	push	r0
    63e8:	cd b7       	in	r28, 0x3d	; 61
    63ea:	de b7       	in	r29, 0x3e	; 62

		ignition_button = READ_IGNITON();
    63ec:	0e 94 9d 03 	call	0x73a	; 0x73a <READ_IGNITON>
    63f0:	80 93 28 07 	sts	0x0728, r24


			uint8_t hazard_data = READ_HAZARD_Button();
    63f4:	0e 94 b1 03 	call	0x762	; 0x762 <READ_HAZARD_Button>
    63f8:	8b 83       	std	Y+3, r24	; 0x03
			uint8_t right_data = READ_RIGHT_Button();
    63fa:	0e 94 c5 03 	call	0x78a	; 0x78a <READ_RIGHT_Button>
    63fe:	8a 83       	std	Y+2, r24	; 0x02
			uint8_t left_data = READ_LEFT_Button();
    6400:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <READ_LEFT_Button>
    6404:	89 83       	std	Y+1, r24	; 0x01
			if(hazard_data){
    6406:	8b 81       	ldd	r24, Y+3	; 0x03
    6408:	88 23       	and	r24, r24
    640a:	41 f0       	breq	.+16     	; 0x641c <get_readings+0x3c>
				/*hazard btton pressed state*/
					Hazzred_button = 1;
    640c:	81 e0       	ldi	r24, 0x01	; 1
    640e:	80 93 2f 07 	sts	0x072F, r24
					L_button = 0;
    6412:	10 92 2c 07 	sts	0x072C, r1
					R_button = 0;
    6416:	10 92 29 07 	sts	0x0729, r1
    641a:	61 c0       	rjmp	.+194    	; 0x64de <get_readings+0xfe>
			}
			else if(right_data){
    641c:	8a 81       	ldd	r24, Y+2	; 0x02
    641e:	88 23       	and	r24, r24
    6420:	29 f1       	breq	.+74     	; 0x646c <get_readings+0x8c>
				/*Right button pressed state*/
				right_button_pressed_counter++;
    6422:	80 91 32 07 	lds	r24, 0x0732
    6426:	90 91 33 07 	lds	r25, 0x0733
    642a:	01 96       	adiw	r24, 0x01	; 1
    642c:	90 93 33 07 	sts	0x0733, r25
    6430:	80 93 32 07 	sts	0x0732, r24
				hazzred_button_pressed_counter=0;
    6434:	10 92 27 07 	sts	0x0727, r1
    6438:	10 92 26 07 	sts	0x0726, r1
				left_button_pressed_counter=0;
    643c:	10 92 31 07 	sts	0x0731, r1
    6440:	10 92 30 07 	sts	0x0730, r1
				if(!(right_button_pressed_counter%10)){
    6444:	80 91 32 07 	lds	r24, 0x0732
    6448:	90 91 33 07 	lds	r25, 0x0733
    644c:	2a e0       	ldi	r18, 0x0A	; 10
    644e:	30 e0       	ldi	r19, 0x00	; 0
    6450:	b9 01       	movw	r22, r18
    6452:	0e 94 bd 32 	call	0x657a	; 0x657a <__divmodhi4>
    6456:	00 97       	sbiw	r24, 0x00	; 0
    6458:	09 f0       	breq	.+2      	; 0x645c <get_readings+0x7c>
    645a:	41 c0       	rjmp	.+130    	; 0x64de <get_readings+0xfe>
					R_button = 1;
    645c:	81 e0       	ldi	r24, 0x01	; 1
    645e:	80 93 29 07 	sts	0x0729, r24
					Hazzred_button = 0;
    6462:	10 92 2f 07 	sts	0x072F, r1
					L_button = 0;
    6466:	10 92 2c 07 	sts	0x072C, r1
    646a:	39 c0       	rjmp	.+114    	; 0x64de <get_readings+0xfe>
				}
			}
			else if(left_data){
    646c:	89 81       	ldd	r24, Y+1	; 0x01
    646e:	88 23       	and	r24, r24
    6470:	21 f1       	breq	.+72     	; 0x64ba <get_readings+0xda>
				/*Left Button pressed state*/
				left_button_pressed_counter++;
    6472:	80 91 30 07 	lds	r24, 0x0730
    6476:	90 91 31 07 	lds	r25, 0x0731
    647a:	01 96       	adiw	r24, 0x01	; 1
    647c:	90 93 31 07 	sts	0x0731, r25
    6480:	80 93 30 07 	sts	0x0730, r24
				hazzred_button_pressed_counter=0;
    6484:	10 92 27 07 	sts	0x0727, r1
    6488:	10 92 26 07 	sts	0x0726, r1
				right_button_pressed_counter=0;
    648c:	10 92 33 07 	sts	0x0733, r1
    6490:	10 92 32 07 	sts	0x0732, r1
				if(!(left_button_pressed_counter%10)){
    6494:	80 91 30 07 	lds	r24, 0x0730
    6498:	90 91 31 07 	lds	r25, 0x0731
    649c:	2a e0       	ldi	r18, 0x0A	; 10
    649e:	30 e0       	ldi	r19, 0x00	; 0
    64a0:	b9 01       	movw	r22, r18
    64a2:	0e 94 bd 32 	call	0x657a	; 0x657a <__divmodhi4>
    64a6:	00 97       	sbiw	r24, 0x00	; 0
    64a8:	d1 f4       	brne	.+52     	; 0x64de <get_readings+0xfe>
					L_button = 1;
    64aa:	81 e0       	ldi	r24, 0x01	; 1
    64ac:	80 93 2c 07 	sts	0x072C, r24
					R_button = 0;
    64b0:	10 92 29 07 	sts	0x0729, r1
					Hazzred_button = 0;
    64b4:	10 92 2f 07 	sts	0x072F, r1
    64b8:	12 c0       	rjmp	.+36     	; 0x64de <get_readings+0xfe>
				}
			}
			else{
				/*neutral state no button pressed*/
				hazzred_button_pressed_counter=0;
    64ba:	10 92 27 07 	sts	0x0727, r1
    64be:	10 92 26 07 	sts	0x0726, r1
				right_button_pressed_counter=0;
    64c2:	10 92 33 07 	sts	0x0733, r1
    64c6:	10 92 32 07 	sts	0x0732, r1
				left_button_pressed_counter=0;
    64ca:	10 92 31 07 	sts	0x0731, r1
    64ce:	10 92 30 07 	sts	0x0730, r1
				L_button = 0;
    64d2:	10 92 2c 07 	sts	0x072C, r1
				R_button = 0;
    64d6:	10 92 29 07 	sts	0x0729, r1
				Hazzred_button = 0;
    64da:	10 92 2f 07 	sts	0x072F, r1

			}



}
    64de:	0f 90       	pop	r0
    64e0:	0f 90       	pop	r0
    64e2:	0f 90       	pop	r0
    64e4:	cf 91       	pop	r28
    64e6:	df 91       	pop	r29
    64e8:	08 95       	ret

000064ea <vState_machine>:


void vState_machine(void)
{
    64ea:	df 93       	push	r29
    64ec:	cf 93       	push	r28
    64ee:	cd b7       	in	r28, 0x3d	; 61
    64f0:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{//
		if(Hazzred_button){
    64f2:	80 91 2f 07 	lds	r24, 0x072F
    64f6:	88 23       	and	r24, r24
    64f8:	49 f0       	breq	.+18     	; 0x650c <vState_machine+0x22>
//			if(prev_state != hazzerd ){
//				xTimerReset( xButtonTimer, 1 );
//				xTimerStart( xButtonTimer, 10 );
//				prev_state = hazzerd;
//		}
			Blink_Right(led_mode);
    64fa:	80 91 24 07 	lds	r24, 0x0724
    64fe:	0e 94 c6 06 	call	0xd8c	; 0xd8c <Blink_Right>
			Blink_LEFT(led_mode);
    6502:	80 91 24 07 	lds	r24, 0x0724
    6506:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <Blink_LEFT>
    650a:	f3 cf       	rjmp	.-26     	; 0x64f2 <vState_machine+0x8>
		}
		else if(!ignition_button &&L_button ){
    650c:	80 91 28 07 	lds	r24, 0x0728
    6510:	88 23       	and	r24, r24
    6512:	59 f4       	brne	.+22     	; 0x652a <vState_machine+0x40>
    6514:	80 91 2c 07 	lds	r24, 0x072C
    6518:	88 23       	and	r24, r24
    651a:	39 f0       	breq	.+14     	; 0x652a <vState_machine+0x40>
		//				if(prev_state != right ){
		//					xTimerReset( xButtonTimer, 1 );
		//					xTimerStart( xButtonTimer, 10 );
		//					prev_state = right;
		//				}
			Stop_Blinking_Right();
    651c:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <Stop_Blinking_Right>
			Blink_LEFT(led_mode);
    6520:	80 91 24 07 	lds	r24, 0x0724
    6524:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <Blink_LEFT>
    6528:	e4 cf       	rjmp	.-56     	; 0x64f2 <vState_machine+0x8>


		}
		else if(!ignition_button && R_button ){
    652a:	80 91 28 07 	lds	r24, 0x0728
    652e:	88 23       	and	r24, r24
    6530:	59 f4       	brne	.+22     	; 0x6548 <vState_machine+0x5e>
    6532:	80 91 29 07 	lds	r24, 0x0729
    6536:	88 23       	and	r24, r24
    6538:	39 f0       	breq	.+14     	; 0x6548 <vState_machine+0x5e>
		//				if(prev_state != left ){
		//					xTimerReset( xButtonTimer, 1 );
		//					xTimerStart( xButtonTimer, 10 );
		//					prev_state = left;
		//				}
			Stop_Blinking_Left();
    653a:	0e 94 f3 06 	call	0xde6	; 0xde6 <Stop_Blinking_Left>
			Blink_Right(led_mode);
    653e:	80 91 24 07 	lds	r24, 0x0724
    6542:	0e 94 c6 06 	call	0xd8c	; 0xd8c <Blink_Right>
    6546:	d5 cf       	rjmp	.-86     	; 0x64f2 <vState_machine+0x8>
			}

		else{
			Stop_Blinking_Right();
    6548:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <Stop_Blinking_Right>
			Stop_Blinking_Left();
    654c:	0e 94 f3 06 	call	0xde6	; 0xde6 <Stop_Blinking_Left>
    6550:	d0 cf       	rjmp	.-96     	; 0x64f2 <vState_machine+0x8>

00006552 <__udivmodhi4>:
    6552:	aa 1b       	sub	r26, r26
    6554:	bb 1b       	sub	r27, r27
    6556:	51 e1       	ldi	r21, 0x11	; 17
    6558:	07 c0       	rjmp	.+14     	; 0x6568 <__udivmodhi4_ep>

0000655a <__udivmodhi4_loop>:
    655a:	aa 1f       	adc	r26, r26
    655c:	bb 1f       	adc	r27, r27
    655e:	a6 17       	cp	r26, r22
    6560:	b7 07       	cpc	r27, r23
    6562:	10 f0       	brcs	.+4      	; 0x6568 <__udivmodhi4_ep>
    6564:	a6 1b       	sub	r26, r22
    6566:	b7 0b       	sbc	r27, r23

00006568 <__udivmodhi4_ep>:
    6568:	88 1f       	adc	r24, r24
    656a:	99 1f       	adc	r25, r25
    656c:	5a 95       	dec	r21
    656e:	a9 f7       	brne	.-22     	; 0x655a <__udivmodhi4_loop>
    6570:	80 95       	com	r24
    6572:	90 95       	com	r25
    6574:	bc 01       	movw	r22, r24
    6576:	cd 01       	movw	r24, r26
    6578:	08 95       	ret

0000657a <__divmodhi4>:
    657a:	97 fb       	bst	r25, 7
    657c:	09 2e       	mov	r0, r25
    657e:	07 26       	eor	r0, r23
    6580:	0a d0       	rcall	.+20     	; 0x6596 <__divmodhi4_neg1>
    6582:	77 fd       	sbrc	r23, 7
    6584:	04 d0       	rcall	.+8      	; 0x658e <__divmodhi4_neg2>
    6586:	e5 df       	rcall	.-54     	; 0x6552 <__udivmodhi4>
    6588:	06 d0       	rcall	.+12     	; 0x6596 <__divmodhi4_neg1>
    658a:	00 20       	and	r0, r0
    658c:	1a f4       	brpl	.+6      	; 0x6594 <__divmodhi4_exit>

0000658e <__divmodhi4_neg2>:
    658e:	70 95       	com	r23
    6590:	61 95       	neg	r22
    6592:	7f 4f       	sbci	r23, 0xFF	; 255

00006594 <__divmodhi4_exit>:
    6594:	08 95       	ret

00006596 <__divmodhi4_neg1>:
    6596:	f6 f7       	brtc	.-4      	; 0x6594 <__divmodhi4_exit>
    6598:	90 95       	com	r25
    659a:	81 95       	neg	r24
    659c:	9f 4f       	sbci	r25, 0xFF	; 255
    659e:	08 95       	ret

000065a0 <memcpy>:
    65a0:	fb 01       	movw	r30, r22
    65a2:	dc 01       	movw	r26, r24
    65a4:	02 c0       	rjmp	.+4      	; 0x65aa <memcpy+0xa>
    65a6:	01 90       	ld	r0, Z+
    65a8:	0d 92       	st	X+, r0
    65aa:	41 50       	subi	r20, 0x01	; 1
    65ac:	50 40       	sbci	r21, 0x00	; 0
    65ae:	d8 f7       	brcc	.-10     	; 0x65a6 <memcpy+0x6>
    65b0:	08 95       	ret

000065b2 <memset>:
    65b2:	dc 01       	movw	r26, r24
    65b4:	01 c0       	rjmp	.+2      	; 0x65b8 <memset+0x6>
    65b6:	6d 93       	st	X+, r22
    65b8:	41 50       	subi	r20, 0x01	; 1
    65ba:	50 40       	sbci	r21, 0x00	; 0
    65bc:	e0 f7       	brcc	.-8      	; 0x65b6 <memset+0x4>
    65be:	08 95       	ret

000065c0 <_exit>:
    65c0:	f8 94       	cli

000065c2 <__stop_program>:
    65c2:	ff cf       	rjmp	.-2      	; 0x65c2 <__stop_program>
